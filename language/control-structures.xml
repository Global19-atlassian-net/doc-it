<?xml version="1.0" encoding="iso-8859-1"?>
<!-- EN-Revision: 1.58 Maintainer: spisto  Status: ready -->
 <chapter id="control-structures">
  <title>Strutture di controllo</title>

  <simpara>
   Qualsiasi script PHP è costituito da una serie di istruzioni. Una istruzione
   può essere un'assegnazione, una chiamata di funzione, un loop, una istruzione condizionale
   che non fa nulla (istruzione vuota).
   Le istruzioni terminano con un punto e virgola. Inoltre, le istruzioni
   si possono raggruppare in blocchi di istruzioni racchiudendole tra
   parentesi graffa.
   Un gruppo di istruzioni è, a sua volta, un'istruzione. Il presente capitolo
   descrive i differenti tipi di istruzioni.
  </simpara>

  <sect1 id="control-structures.if">
   <title><literal>if</literal></title>
   <para>
    Il costrutto <literal>if</literal> è una delle più importanti
    caratteristiche di qualsiasi linguaggio, incluso PHP.
    Permette l'esecuzione condizionata di frammenti di codice.
    La struttura di controllo <literal>if</literal> di PHP è simile a quella del linguaggio C:
    <informalexample>
     <programlisting>
<![CDATA[
if (espressione)
    istruzione
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Come descritto nella <link linkend="language.expressions">sezione sulle
    espressioni</link>, <replaceable>espressione</replaceable> restiruirà il suo
    valore booleano. Se <replaceable>espressione</replaceable> vale &true;,
   PHP eseguirà <replaceable>istruzione</replaceable>, e se essa vale
    &false; - la ignorerà. Più informazioni riguardo i valori valutati
    &false; possono essere trovati nella sezione <link
    linkend="language.types.boolean.casting">'Conversione in booleano'</link>
    .
   </simpara>
   <para>
    L'esempio che segue visualizzerà <computeroutput>a è maggiore
    di b</computeroutput> se <replaceable>$a</replaceable> sarà maggiore
    di <replaceable>$b</replaceable>:
    <informalexample>
     <programlisting role="php">
<![CDATA[
if ($a > $b)
    print "a è maggiore di b";
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Spesso sarà necessario eseguire più di una istruzione
    condizionale.  Naturalmente non è necessario, utilizzare una singola clausola
    <literal>if</literal> per ciascuna istruzione. Si possono raggruppare diverse istruzioni
    in un singolo gruppo di istruzioni. Per esempio, il codice che segue
    visualizzerà <computeroutput>a è maggiore di b</computeroutput>
    se <replaceable>$a</replaceable> è maggiore di <replaceable>$b</replaceable>,
    e successivamente assegnerà il valore della variabile <replaceable>$a</replaceable>
    alla variabile <replaceable>$b</replaceable>:
    <informalexample>
     <programlisting role="php">
<![CDATA[
if ($a > $b) {
    print "a è maggiore di b";
    $b = $a;
}
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Si possono annidare indefinitamente istruzioni
    <literal>if</literal>, la qual cosa fornisce piena
    flessibilità per l'esecuzione di istruzioni condizionali in diversi punti del
    programma.
   </simpara>
  </sect1>

  <sect1 id="control-structures.else">
   <title><literal>else</literal></title>
   <para>
    Spesso è necessario eseguire un'istruzione se una proposizione è vera
    e un'altra istruzione se la proposizione è falsa. Per questo
    si usa la clausola <literal>else</literal>. <literal>else</literal>
    estende il costrutto <literal>if</literal> aggiungendo la possibilità
    di eseguire un'istruzione se l'espressione nel ramo <literal>if</literal>
    è &false;. L'esempio che segue
    visualizzerà <computeroutput>a è maggiore
    di b</computeroutput> se <replaceable>$a</replaceable> è maggiore di
    <replaceable>$b</replaceable> e <computeroutput>a NON è maggiore
    di b</computeroutput> altrimenti:
    <informalexample>
     <programlisting role="php">
<![CDATA[
if ($a > $b) {
    print "a è maggiore di b";
} else {
    print "a NON è maggiore di b";
}
]]>
     </programlisting>
    </informalexample>

    Il ramo <literal>else</literal> viene eseguito solo se l'espressione
    nel ramo <literal>if</literal> è
    &false;, e, nel caso ci fossero delle clausole
    <literal>elseif</literal>, solamente se le espressioni in esse contenute fossero
    anch'esse &false; (vedere <link
    linkend="control-structures.elseif">elseif</link>).

   </para>
  </sect1>

  <sect1 id="control-structures.elseif">
   <title><literal>elseif</literal></title>
   <para>
    <literal>elseif</literal>, come è facile intuire, è una combinazione
    di <literal>if</literal> ed <literal>else</literal>. Analogamente ad
    <literal>else</literal>, estende <literal>if</literal>
    aggiungendo la possibilità di eseguire un'altra istruzione nel caso
    in cui l'espressione contenuta nel ramo <literal>if</literal>
    sia &false;. Però, a differenza
    di <literal>else</literal>, si eseguirà l'istruzione alternativa
    solamente se l'espressione contenuta nel ramo <literal>elseif</literal>
    sarà &true;. L'esempio
    che segue, visualizzerà <computeroutput>a è maggiore di
    b</computeroutput>, <computeroutput>a è uguale a b</computeroutput>
    oppure <computeroutput>a è minore di b</computeroutput>:
    <informalexample>
     <programlisting role="php">
<![CDATA[
if ($a > $b) {
    print "a è maggiore di b";
} elseif ($a == $b) {
    print "a è uguale a b";
} else {
    print "a è minore di b";
}
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Nel medesimo blocco <literal>if</literal> possono essere presenti
    più di una clausola <literal>elseif</literal>. Verrà eseguita
    l'istruzione del primo ramo <literal>elseif</literal> la cui espressione
    sia &true;. In PHP è possibile
    scrivere 'else if' (due parole) e il significato sarà
    lo stesso di 'elseif' (una sola parola). Il significato sintattico
    è leggermente differente (se si ha familiarità con il linguaggio C, esso ha lo stesso
    comportamento) però al lato pratico l'effetto è
    il medesimo.
   </simpara>
   <simpara>
    L'istruzione di un ramo <literal>elseif</literal> verrà eseguita solo se l'espressione del
    ramo <literal>if</literal> e le espressioni dei
    rami <literal>elseif</literal> precedenti sono
    &false;, e se l'espressione
    del ramo <literal>elseif</literal> è
    &true;.
   </simpara>
  </sect1>

  <sect1 id="control-structures.alternative-syntax">
   <title>Sintassi alternativa per le strutture di controllo</title>
   <para>
    PHP offre una sintassi alternativa per alcune delle sue strutture di controllo;
    vale a dire, <literal>if</literal>,
    <literal>while</literal>, <literal>for</literal>,
    <literal>foreach</literal> e <literal>switch</literal>.
    Fondamentalmente la sintassi alternativa consiste nel sostituire
    la prima parentesi graffa con il carattere "duepunti" (:) e la seconda parentesi graffa con
    <literal>endif;</literal>, <literal>endwhile;</literal>,
    <literal>endfor;</literal>, <literal>endforeach;</literal>, oppure
    <literal>endswitch;</literal>, rispettivamente.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php if ($a == 5): ?>
a è uguale a 5
<?php endif; ?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Nell'esempio precedente, il blocco HTML "a è uguale a 5" è incluso nel ramo
    <literal>if</literal> scritto utilizzando la sintassi alternativa.
    Il blocco HTML verrà visualizzato solamente se $a è uguale a 5.
   </simpara>
   <para>
    La sintassi alternativa si applica anche ad <literal>else</literal> ed
    <literal>elseif</literal>. Nell'esempio che segue si mostra come utilizzare la sintassi alternativa
    nel caso di un <literal>if</literal> con <literal>elseif</literal> ed
    <literal>else</literal>:
    <informalexample>
     <programlisting role="php">
<![CDATA[
if ($a == 5):
    print "a è uguale a 5";
    print "...";
elseif ($a == 6):
    print "a è uguale a 6";
    print "!!!";
else:
    print "a non è nè 5 nè 6";
endif;
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Vedere anche <link linkend="control-structures.while">while</link>,
    <link linkend="control-structures.for">for</link>, e <link
    linkend="control-structures.if">if</link> per ulteriori esempi.
   </para>
  </sect1>

  <sect1 id="control-structures.while">
   <title><literal>while</literal></title>
   <para>
    Il ciclo <literal>while</literal> è la forma di ciclo più semplice
    tra quelle possibili in PHP. Si comporta come la sua controparte nel linguaggio C.
    La forma di base di un ciclo <literal>while</literal> è la seguente:
    <informalexample>
     <programlisting>
<![CDATA[
while (espressione) istruzione
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Il significato di un ciclo <literal>while</literal> è semplice.
    Istruisce l'interprete PHP perchè esegua l'istruzione (o le istruzioni)
    in esso racchiuse, ripetutamente, fintanto che l'espressione contenuta
    nella clausola <literal>while</literal> ha valore &true;.
    Il valore dell'espressione viene verificato ogni volta che il ciclo
    si ripete (iterazione), così che anche se il valore dell'espressione cambia durante
    l'esecuzione dell'istruzione, il ciclo non termina fino
    all'iterazione successiva.
    Ovviamente, se l'espressione nella clausola <literal>while</literal> ha valore
    &false; dall'inizio, l'istruzione racchiusa nel blocco non verrà eseguita nemmeno
    una volta.
   </simpara>
   <para>
    Come nel caso della struttura di controllo <literal>if</literal>, si possono raggruppare
    più istruzioni nello medesimo ciclo <literal>while</literal>
    racchiudendo le istruzioni in parentesi graffa, oppure
    utilizzando la sintassi alternativa:
    <informalexample>
     <programlisting>
<![CDATA[
while (espressione): istruzione ... endwhile;
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Gli esempi seguenti sono identici e entrambi visualizzano i numeri da
    1 a 10:
    <informalexample>
     <programlisting>
<![CDATA[
/* esempio 1 */

$i = 1;
while ($i <= 10) {
    print $i++;  /* Il valore visualizzato è il valore della
                    variabile $i prima dell'incremento
                    (post-incremento) */
}

/* esempio 2 */

$i = 1;
while ($i <= 10):
    print $i;
    $i++;
endwhile;
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 id="control-structures.do.while">
   <title><literal>do..while</literal></title>
   <simpara>
    Il ciclo <literal>do..while</literal> è simile al ciclo
    <literal>while</literal>, con l'unica differenza che il valore dell'espressione
    viene controllato alla fine di ogni iterazione anzichè all'inizio.
    La differenza più importante rispetto a <literal>while</literal> è che
    la prima iterazione di un blocco <literal>do..while</literal> verrà
    sempre eseguita (il valore dell'espressione viene controllato alla fine
    del ciclo), mentre non sarà necessariamente eseguito in un
    ciclo <literal>while</literal> (il valore dell'espressione viene
    controllato all'inizio del ciclo, e se tale valore è
    &false; dall'inizio, l'esecuzione del ciclo
    termina immediatamente).
   </simpara>
   <para>
    È ammessa una sola sintassi per il ciclo <literal>do..while</literal>:

    <informalexample>
     <programlisting role="php">
<![CDATA[
$i = 0;
do {
   print $i;
} while ($i>0);
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
     Il ciclo precedente verrà eseguito un'unica volta, dal momento che
     alla prima iterazione, quando si controlla l'espressione, il suo valore sarà
     &false; ($i non è maggiore di 0) e il ciclo di
     esecuzioni, termina.
   </simpara>
   <para>
    Chi ha utilizzato il linguaggio C conosce probabilmente un'altro modo di utilizzare
    il ciclo <literal>do..while</literal>, che permette di terminare l'esecuzione
    delle istruzioni durante l'esecuzione stessa, utilizzando
    <literal>do..while</literal>(0), e usando l'istruzione <link
    linkend="control-structures.break"><literal>break</literal></link>.
    Il codice che segue esemplifica questa possibilità:
    <informalexample>
     <programlisting role="php">
<![CDATA[
do {
    if ($i < 5) {
        print "i non è abbastanza grande";
        break;
    }
    $i *= $factor;
    if ($i < $minimum_limit) {
        break;
    }
    print "i è ok";

     ...processa i...

} while(0);
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Non vi preoccupate se l'esempio non è sufficientemente chiaro.
    Si possono scrivere ottimi programmi PHP anche senza far ricorso a questa
    'possibilità'.
   </simpara>
  </sect1>

  <sect1 id="control-structures.for">
   <title><literal>for</literal></title>
   <para>
    Il ciclo <literal>for</literal> è il ciclo più complesso tra quelli disponibili in PHP.
    Si comporta come la sua controparte nel linguaggio C.
    La sintassi di un clico <literal>for</literal> è:
    <informalexample>
     <programlisting>
<![CDATA[
for (espressione1; espressione2; espressione3) istruzione
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
   Il valore della prima espressione (<replaceable>espressione1</replaceable>) viene
   verificato (eseguito) una sola volta incondizionatamente all'inizio del
   ciclo.
   </simpara>
   <simpara>
    Ad ogni iterazione,
    si controlla il valore di <replaceable>espressione2</replaceable>. Se è
    &true;, il ciclo prosegue e viene eseguita
    l'istruzione (o le istruzioni) contenuta nel blocco;
    se è &false;, l'esecuzione del ciclo termina.
   </simpara>
   <simpara>
    Al termine di ogni iterazione, si verifica (si esegue)
    il valore di <replaceable>espressione3</replaceable>.
   </simpara>
   <simpara>
    Le due espressioni possono anche non essere presenti.
    Se non esiste <replaceable>espressione2</replaceable> significa che il ciclo deve
    essere eseguito indefinitamente (PHP considera implicitamente che il
    suo valore è &true;, come in C). Questa possibilità in fondo non è
    utile come può sembrare perchè obbliga a terminare il ciclo utilizzando
    l'istruzione <link
    linkend="control-structures.break"><literal>break</literal></link>
    invece di utilizzare le espressioni booleane del ciclo <literal>for</literal>
    .
   </simpara>
   <para>
    Si considerino gli esempi seguenti. In ciascun caso si visualizzeranno
    i numeri da 1 a 10:
    <informalexample>
     <programlisting role="php">
<![CDATA[
/* esempio 1 */

for ($i = 1; $i <= 10; $i++) {
    print $i;
}

/* esempio 2 */

for ($i = 1;;$i++) {
    if ($i > 10) {
        break;
    }
    print $i;
}

/* esempio 3 */

$i = 1;
for (;;) {
    if ($i > 10) {
        break;
    }
    print $i;
    $i++;
}

/* esempio 4 */

for ($i = 1; $i <= 10; print $i, $i++) ;
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Naturalmente il primo esempio sembra il migliore (o
    forse il quarto),  ma l'uso del
    ciclo <literal>for</literal> senza espressioni può essere utile
    in molti casi.
   </simpara>
   <para>
    PHP offre una sintassi alternativa (con i "punto e virgola") per i
    cicli <literal>for</literal>.
    <informalexample>
     <programlisting>
<![CDATA[
for (espressione1; espressione2; espressione3): istruzione; ...; endfor;
]]>
     </programlisting>
     </informalexample>
   </para>
   <para>
    Alcuni linguaggi permettono l'uso della struttura di controllo <literal>foreach</literal> per
    attraversare un array o una tabella hash. PHP 3 non premette l'uso di tale ciclo mentre PHP 4 si
    (vedere <link
    linkend="control-structures.foreach">foreach</link>). In PHP 3 è
    possibile combinare <link linkend="control-structures.while">while</link>
    con la funzione <function>list</function> e <function>each</function>
    per ottenere la stessa funzionalià. Si veda la documentazione di queste funzioni
    per ulteriori esempi.
   </para>

  </sect1>

  <sect1 id="control-structures.foreach">
   <title><literal>foreach</literal></title>
   <para>
    PHP 4 (non PHP 3) permette l'uso della struttura di controllo <literal>foreach</literal>,
    alla stessa maniera del linguaggio Perl e altri. Ciò semplicemente fornisce
    una facile metodo per attraversare un array. Esistono due possibili notazioni sintattiche; la seconda è
    un'utile estensione della prima:
    <informalexample>
     <programlisting>
<![CDATA[
foreach(array_expression as $value) istruzione
foreach(array_expression as $key => $value) istruzione
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    La prima attraversa l'array dato da
    <literal>array_expression</literal>. Ad ogni ciclo, si assegna il valore
    dell'elemento corrente a <literal>$value</literal> e
    il puntatore interno avanza di una posizione (in modo tale che al ciclo successivo
    l'elemento corrente sarà il successivo elemento dell'array).
   </simpara>
   <simpara>
    La seconda esegue lo stesso ciclo con la differenza che il
    valore dell'indice corrente viene assegnato ad ogni ciclo,
    alla variabile <literal>$key</literal>.
   </simpara>
   <para>
    <note>
     <para>
      All'inizio dell'esecuzione di un ciclo <literal>foreach</literal>
      il puntatore interno viene automaticamente posizionato nella prima
      posizione. Questo significa che non è necessario utilizzare la
      funzione <function>reset</function> prima di un ciclo 
      <literal>foreach</literal>.
     </para>
    </note>
   </para>
   <para>
    <note>
     <para>
      È importante notare che <literal>foreach</literal> opera su una copia
      dell'array, non sull'array stesso, pertanto il puntatore dell'array originale
      non viene modificato come accade utilizzando la funzione <function>each</function>
      e le modifiche agli elementi dell'array non
      appaiono nell'array originale.
     </para>
    </note>
   </para>
   <note>
    <para>
     <literal>foreach</literal> non offre la possibilità di annullare la generazione
     di messaggi d'errore utilizzando il carattere '@'.
    </para>
   </note>
   <para>
    Avete probabilmente notato che i due cicli seguenti sono identici da un
    punto di vista funzionale:
    <informalexample>
     <programlisting role="php">
<![CDATA[
reset ($arr);
while (list(, $value) = each ($arr)) {
    echo "Valore: $value<br>\n";
}

foreach ($arr as $value) {
    echo "Valore: $value<br>\n";
}
]]>
     </programlisting>
    </informalexample>
    Allo stesso modo i due cicli seguenti sono identici:
    <informalexample>
     <programlisting role="php">
<![CDATA[
reset ($arr);
while (list($key, $value) = each ($arr)) {
    echo "Chiave: $key; Valore: $value<br>\n";
}

foreach ($arr as $key => $value) {
    echo "Chiave: $key; Valore: $value<br>\n";
}
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Di seguito, altri esempi per mostrare possibili utilizzi:
    <informalexample>
     <programlisting role="php">
<![CDATA[
/* esempio 1 foreach: solo il valore */

$a = array (1, 2, 3, 17);

foreach ($a as $v) {
   print "Valore corrente di \$a: $v.\n";
}

/* esempio 2 foreach: valore (con la chiave stampata) */

$a = array (1, 2, 3, 17);

$i = 0; /* solo per un proposito illustrativo */

foreach($a as $v) {
    print "\$a[$i] => $v.\n";
    $i++;
}

/* esempio 3 foreach: chiave e valore */

$a = array (
    "uno" => 1,
    "due" => 2,
    "tre" => 3,
    "diciassette" => 17
);

foreach($a as $k => $v) {
    print "\$a[$k] => $v.\n";
}

/* esempio 4 foreach: array multidimensionali */

$a[0][0] = "a";
$a[0][1] = "b";
$a[1][0] = "y";
$a[1][1] = "z";

foreach($a as $v1) {
    foreach ($v1 as $v2) {
        print "$v2\n";
    }
}

/* esempio 5 foreach: array dinamici */

foreach(array(1, 2, 3, 4, 5) as $v) {
    print "$v\n";
}
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 id="control-structures.break">
   <title><literal>break</literal></title>
   <simpara>
    <literal>break</literal> termina l'esecuzione di una struttura
    <literal>for</literal>, <literal>foreach</literal>
    <literal>while</literal>, <literal>do..while</literal> o
    <literal>switch</literal>.
   </simpara>
   <simpara>
    <literal>break</literal> accetta un argomento opzionale che definisce,
    nel caso di cicli annidati, il livello del ciclo che è da
    interrompere.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
$arr = array ('uno', 'due', 'tre', 'quattro', 'stop', 'cinque');
while (list (, $val) = each ($arr)) {
    if ($val == 'stop') {
        break;    /* Qui si può anche usare 'break 1;'. */
    }
    echo "$val<br>\n";
}

/* Uso dell'argomento opzionale. */

$i = 0;
while (++$i) {
    switch ($i) {
    case 5:
        echo "At 5<br>\n";
        break 1;  /* Interrompe solo awitch. */
    case 10:
        echo "At 10; quitting<br>\n";
        break 2;  /* Interrompe switch e while. */
    default:
        break;
    }
}
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 id="control-structures.continue">
   <title><literal>continue</literal></title>
   <simpara>
    <literal>continue</literal> si utilizza per interrompere l'esecuzione
    del ciclo corrente e continuare con l'esecuzione
    all'inizio del ciclo successivo.
   </simpara>
   <simpara>
    <literal>continue</literal> accetta un argomento numerico opzionale
    che definisce, nel caso di cicli annidati, il numero di cicli da interrompere
    e da cui iniziare l'esecuzione dell'iterazione successiva.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
while (list ($key, $value) = each ($arr)) {
    if (!($key % 2)) { // salta odd members
        continue;
    }
    do_something_odd ($value);
}

$i = 0;
while ($i++ < 5) {
    echo "Esterno<br>\n";
    while (1) {
        echo "&nbsp;&nbsp;Centrale<br>\n";
        while (1) {
            echo "&nbsp;&nbsp;Interno<br>\n";
            continue 3;
        }
        echo "Questo non sarà mai stampato.<br>\n";
    }
    echo "Nemmeno questo.<br>\n";
}
]]>
     </programlisting>
     </informalexample>
    </para>
  </sect1>

  <sect1 id="control-structures.switch">
   <title><literal>switch</literal></title>
   <simpara>
    <literal>switch</literal> è simile a una serie di
    if sulla stessa espressione. In molti casi può essere
    necessario confrontare una variabile (o espressione) con
    differenti valori ed eseguire un differente blocco di istruzioni a seconda
    del valore di detta variabile. Questo è esattamente quello che fa la struttura
    di controllo <literal>switch</literal>.
   </simpara>
   <para>
    Gli esempi seguenti mostrano due maniere differenti di scrivere
    la stessa cosa, uno utilizzando una serie di <literal>if</literal>,
    l'altro utilizzando <literal>switch</literal>
    :
    <informalexample>
     <programlisting role="php">
<![CDATA[
if ($i == 0) {
    print "i è uguale a 0";
}
if ($i == 1) {
    print "i è uguale a 1";
}
if ($i == 2) {
    print "i è uguale a 2";
}

switch ($i) {
    case 0:
        print "i è uguale a 0";
        break;
    case 1:
        print "i è uguale a 1";
        break;
    case 2:
        print "i è uguale a 2";
        break;
}
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    È importante comprendere esattamente come viene eseguita la
    clausola <literal>switch</literal> per evitare errori.
    Un'istruzione <literal>switch</literal> esegue linea dopo linea
    le istruzioni in essa contenuta. All'inizio non viene eseguito
    alcun codice. Solamente quando incontra una clausola <literal>case</literal>
    il cui valore è uguale al valore della viariabile, PHP inizia ad
    eseguire le istruzioni contenute nel blocco <literal>case</literal>.
    PHP continua l'esecuzione delle istruzioni fino alla termine del
    blocco <literal>switch</literal>, o quando incontra un'istruzione
    <literal>break</literal>. Se non esiste alcuna
    istruzione <literal>break</literal> al termine di un blocco case
    PHP continuerà l'esecuzione delle istruzioni del blocco case successivo.
    Per esempio:
    <informalexample>
     <programlisting role="php">
<![CDATA[
switch ($i) {
    case 0:
        print "i è uguale a 0";
    case 1:
        print "i è uguale a 1";
    case 2:
        print "i è uguale a 2";
}
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    In questo caso se $i è uguale a 0, PHP eseguirà tutte le
    istruzioni contenute nei blocchi case. Se $i è uguale a 1,
    PHP eseguirà le istruzioni degli ultimi due blocchi case e
    solamente se $i è uguale a 2 otterremo il risultato voluto
    e si visualizzerà solo '$i è uguale a 2'. Pertanto
    è importante non dimenticare l'istruzione <literal>break</literal>
    (anche se in alcuni casi potrà essere necessario non utilizzarla).
   </simpara>
   <simpara>
    In un'istruzione <literal>switch</literal>, la condizione in parentesi
    viene valutata una sola volta e il risultato viene confrontato con
    ciascun ramo <literal>case</literal>. Utilizzando <literal>elseif</literal>,
    la condizione viene valutata una seconda volta. Se tale condizione è più
    complessa di un semplice confronto e/o è in un ciclo piuttosto pesante,
    l'uso di <literal>switch</literal> dovrebbe garantire un minor tempo di esecuzione.
   </simpara>
   <para>
    Un blocco case può anche non contenere istruzioni, nel qual caso
    il controllo passa semplicemente al successivo blocco case.
    <informalexample>
     <programlisting role="php">
<![CDATA[
switch ($i) {
    case 0:
    case 1:
    case 2:
        print "i è minore di 3 ma non negativo";
        break;
    case 3:
        print "i è 3";
}
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Un blocco case speciale è il il blocco case di default.
    Uguaglia tutte le condizioni non uguagliate nei blocchi case precedenti
    e dev'essere l'ultimo blocco <literal>case</literal>. Per esempio:
   <informalexample>
     <programlisting role="php">
<![CDATA[
switch ($i) {
    case 0:
        print "i è uguale a 0";
        break;
    case 1:
        print "i è uguale a 1";
        break;
    case 2:
        print "i è uguale a 2";
        break;
    default:
        print "i è diverso da 0, 1 o 2";
}
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    L'espressione in un ramo <literal>case</literal> può essere
    qualsiasi espressione il cui valore sarà di tipo intero, decimale,
    numerico e stringa. Array e oggetti (objects) non sono ammessi
    a meno che non siano dereferenziati a un tipo di dato semplice tra quelli precedentemente elencati.
   </para>
   <para>
    Come per altre strutture di controllo è possibile utilizzare una sintassi
    alternativa. Si veda
    <link linkend="control-structures.alternative-syntax">Sintassi alternativa per le strutture di controllo</link>
    per ulteriori esempi.
    <informalexample>
     <programlisting role="php">
<![CDATA[
switch ($i):
    case 0:
        print "i è uguale a 0";
        break;
    case 1:
        print "i è uguale a 1";
        break;
    case 2:
        print "i è uguale a 2";
        break;
    default:
        print "i è diverso da 0, 1 o 2";
endswitch;
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 id="control-structures.declare">
   <title><literal>declare</literal></title>
   <para>
    Il costrutto <literal>declare</literal> si usa per definire
    direttive di esecuzione per blocchi di istruzioni.
    La sintassi è simile alla sintassi
    di altre strutture di controllo:
    <informalexample>
     <programlisting>
<![CDATA[
declare (direttiva) istruzione
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    La sezione <literal>direttiva</literal> permette di
    impostare il comportamento del blocco <literal>declare</literal>
    .
    Attualmente è riconosciuta una sola direttiva: la
    direttiva <literal>ticks</literal>. (Fare riferimento più in basso per ulteriori
    informazioni relative alla
    direttiva
    <link linkend="control-structures.declare.ticks">ticks</link>)
   </para>
   <para>
    Verrà eseguita la parte <literal>istruzione</literal> del
    blocco <literal>declare</literal> - come
    verrà eseguita e quali effetti collaterali emergeranno durante l'esecuzione
    potrà dipendere dalla direttiva impostata nel
    blocco <literal>direttiva</literal>.
   </para>
   <sect2 id="control-structures.declare.ticks">
    <title>Ticks</title>
    <para>Un tick è un evento che si verifica per ogni
    <replaceable>N</replaceable> istruzioni di basso livello eseguite
    dal parser all'interno del blocco <literal>declare</literal>.
    Il valore per <replaceable>N</replaceable> viene specificato
    usando <literal>ticks=<replaceable>N</replaceable></literal>
    all'interno della sezione <literal>direttiva</literal> del blocco
    <literal>declare</literal>.
   </para>
   <para>
    L'evento (o gli eventi) che si verifica su ogni tick è specificato usando
    <function>register_tick_function</function>. Vedere l'esempio
    più in basso per ulteriori dettagli. Notare che può verificarsi più di un evento
    per ogni tick.
   </para>
   <para>
    <example>
     <title>Segue una sezione di codice PHP</title>
     <programlisting role="php">
<![CDATA[
<?php
// Una funzione che registra il tempo quando viene chiamata
function profile ($dump = FALSE)
{
    static $profile;

    // Restituisce il tempo immagazinato in $profile, successivamente lo cancella
    if ($dump) {
        $temp = $profile;
        unset ($profile);
        return ($temp);
    }

    $profile[] = microtime ();
}

// Imposta un tick handler
register_tick_function("profile");

// Inizializza la funzione prima del blocco declare
profile ();

// Esegue un blocco di codice, attraverso un tick ogni seconda istruzione
declare (ticks = 2) {
    for ($x = 1; $x < 50; ++$x) {
        echo similar_text (md5($x), md5($x*$x)), "<br />";
    }
}

// Mostra i dati immagazionati nel profilo
print_r (profile (TRUE));
?>
]]>
     </programlisting>
    </example>
    L'esempio descrive il codice PHP all'interno del blocco 'declare',
    registrando il tempo in cui è stata eseguita ogni seconda istruzione
    di basso livello. Questa informazione può
    poi essere usata per trovare le aree lente all'interno di particolari
    segmenti di codice. Questo processo può essere ottimizzato usando altri
    metodi: usando i tick è più conveniente e facile da
    implementare.
   </para>
   <simpara>
    I tick sono ben adeguati per il debugging, l'implementazione di semplici
    multitasking, backgrounded I/O e molti altri compiti.
   </simpara>
   <simpara>
    Vedere anche <function>register_tick_function</function> e
    <function>unregister_tick_function</function>.
   </simpara>
   </sect2>
  </sect1>

  <sect1 id="function.return">
   <title>return</title>
   <simpara>
    Se viene chiamato all'interno di una funzione, l'istruzione <function>return</function>
    termina immediatamente l'esecuzione della funzione corrente, e
    restituisce il suo argomento come valore della funzione
    chiamata. <function>return</function> terminerà anche l'esecuzione di un'istruzione
    <function>eval</function> o di un file di script.
   </simpara>
   <simpara>
    Se viene chiamato in uno scope globale, allora verrà terrminata l'esecuzione
    del file di script corrente. Nel caso in cui il file di script corrente sia un file chiamato da
    <function>include</function> o <function>require</function>,
    il controllo viene passato al file chiamante. Ciononostante, se
    il file di script corrente è un file chiamato da <function>include</function>, allora
    il valore dato da <function>return</function> verrà restituito
    come valore della chiamata <function>include</function>. Se
    viene chiamato <function>return</function> all'interno del file di script
    principale, allora l'esecuzione dello script terminerà. Se il file di script corrente
    è stato nominato da <link
    linkend="ini.auto-prepend-file">auto_prepend_file</link> o <link
    linkend="ini.auto-append-file">auto_append_file</link>
    con le opzioni di configurazione nel <link linkend="configuration.file">
    file di configurazione</link>, allora l'esecuzione di quello script
    termina.
   </simpara>
   <simpara>Per maggiori informazioni, consultare <link
   linkend="functions.returning-values">Valori restituiti</link>.
   </simpara>
   <note>
    <simpara>
     Notate che poichè <function>return</function> è un costrutto di linguaggio
     e non una funzione, le parentesi che circondano i suoi
     argomenti <emphasis>non</emphasis> sono richieste --infatti, è
     più comune evitarle che usarle, nonostante ciò
     non c'è motivo di preferire un modo o l'altro.
    </simpara>
   </note>
  </sect1>


 <sect1 id="function.require">
   <title><function>require</function></title>

   <simpara>
    L'istruzione <function>require</function> include e valuta
    il file specifico.
   </simpara>
   <simpara>
     <function>require</function> include e valuta uno specifico file.
     Informazioni dettagliate su come funziona quest'inclusione sono descritte nella
     documentazione di <function>include</function>.
   </simpara>
   <simpara>
     <function>require</function> e <function>include</function>
     sono identiche in ogni senso eccetto per come esse trattano gli errori.
     <function>include</function> produce un
     <link linkend="internal.e-warning">Warning</link> mentre
     <function>require</function> restituisce un <link linkend="internal.e-error">
     Fatal Error</link>. In altre parole, non esitate ad usare
     <function>require</function> se volete che un file mancante fermi l'esecuzione
     della pagina. <function>include</function> non si comporta in questo modo, lo
     script continuerà nonostante tutto. Assicuratevi di avere un appropriato
     <link linkend="ini.include-path">include_path</link> impostato a dovere.
   </simpara>
   <para>
    <example>
     <title>Esempio di base con <function>require</function></title>
     <programlisting role="php">
<![CDATA[
<?php

require 'prepend.php';

require $qualche_file;

require ('qualche_file.txt');

?>
]]>
     </programlisting>
   </example>
   </para>
   <simpara>
    Vedere la documentazione di <function>include</function> per più esempi.
   </simpara>
   <note>
    <simpara>
     Prima di PHP 4.0.2, si applica la seguente logica: <function>require</function>
     tenterà sempre di leggere il file chiamato, anche se la riga su cui si trova non verrà mai eseguita.
     L'istruzione condizionale non avrà effetto su <function>require</function>. Comunque,
     se la riga su cui si verifica <function>require</function> non viene eseguita,
     non sarà eseguito nemmeno il codice del file incluso. Similmente, le strutture
     cicliche non avranno effetto sul comportamento di <function>require</function>. Sebbene
     il codice contenuto nel file incluso è ancora soggetto a ciclo,
     <function>require</function> stesso si verifica solo una volta.
    </simpara>
   </note>
   <simpara>
    Vedere anche <function>include</function>, <function>require_once</function>,
    <function>include_once</function>, <function>eval</function>,
    <function>file</function>, <function>readfile</function>,
    <function>virtual</function> e <link linkend="ini.include-path">include_path</link>.
   </simpara>
  </sect1>

 <sect1 id="function.include">
   <title><function>include</function></title>
   <simpara>
    L'istruzione <function>include</function> include e valuta
    il file specificato.
   </simpara>
   <simpara>
     La documentazione seguente si applica anche a <function>require</function>.
     I due costrutti sono identici in ogni aspetto eccetto per come essi trattano
     gli errori. <function>include</function> produce un
     <link linkend="internal.e-warning">Warning</link> mentre <function>require</function>
     restituisce un <link linkend="internal.e-error">Fatal Error</link>.
     In altre parole, usate <function>require</function> se volete che
     un file mancante fermi l'esecuzione della pagina. <function>include</function>
     non si comporta in questo modo, lo script continuerà nonostante tutto. Assicuratevi di avere un
     appropriato <link linkend="ini.include-path">include_path</link> impostato a dovere.
   </simpara>
   <simpara>
     Quando un file viene incluso, il codice che esso contiene eredita lo
     <link linkend="language.variables.scope">scope delle variabili</link> della
     riga in cui si verifica l'inclusione. Qualsiasi variabile disponibile in quella riga
     nella chiamata al file sarà disponibile all'interno del file chiamato, da
     quel punto in avanti.
   </simpara>
   <para>
     <example>
      <title>Esempio di base con <function>include</function></title>
      <programlisting role="php">
<![CDATA[
vars.php
<?php

$colore = 'verde';
$frutto = 'mela';

?>

test.php
<?php

echo "Una $frutto $colore"; // Una

include 'vars.php';

echo "Una $frutto $colore"; // Una mela verde

?>
]]>
      </programlisting>
     </example>
   </para>
   <simpara>
     Se l'inclusione si verifica dentro una funzione all'interno del file chiamato,
     allora tutto il codice contenuto nel file chiamato si comporterà come
     se esso sia stato definito all'interno di una funzione. Così, esso seguirà
     lo scope delle variabili di quella funzione.
   </simpara>
   <para>
     <example>
     <title>Inclusione all'interno di funzioni</title>
      <programlisting role="php">
<![CDATA[
<?php

function foo()
{
global $frutto;

    include 'vars.php';

    echo "Una $frutto $colore";
}

/* vars.php è nello scope di foo() così    *
 * $colore NON è disponibile fuori di      *
 * questo scope. $frutto si perchè è stato *
 * dichiarato globale.                     */

foo();                        // Una mela verde
echo "Una $frutto $colore";   // Una mela

?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
     Quando un file viene incluso, il parsing esce dalla modalità PHP e
     entra in modalità HTML all'inizio del file incluso, e riprende
     alla fine. Per questa ragione, qualunque codice all'interno del
     file incluso che dovrebbe essere eseguito come codice PHP deve essere incluso all'interno
     dei <link linkend="language.basic-syntax.phpmode">tag PHP validi di apertura
     e chiusura</link>.
   </simpara>
   <simpara>
     Se "<link linkend="ini.allow-url-fopen">URL fopen wrappers</link>"
     nel PHP sono abilitati (come nella configurazione di default),
     potete specificare il file da includere usando un URL (via HTTP)
     invece che un percorso locale. Se il server chiamato interpreta
     il file incluso come codice PHP, le variabili possono essere passate
     al file incluso usando una stringa di richiesta URL come con l'utilizzo di HTTP GET. Non è
     proprio parlare della stessa cosa includere il file e averlo
     ereditato dallo scope di variabili del file chiamante; lo script è stato attualmente
     eseguito su un server remoto e il risultato è poi stato
     incluso nello script locale.
   </simpara>
   <para>
    <example>
     <title><function>include</function> attraverso HTTP</title>
     <programlisting role="php">
<![CDATA[
<?php

/* Questo esempio assume che www.example.com è configurato per eseguire file *
 * .php e non file .txt. Anche, 'Funziona' qui significa che le variabili    *
 * $foo e $bar sono disponibili all'interno del file incluso.                */

// Non funzionerà; file.txt non è stato trattato da www.example.com come PHP
include 'http://www.example.com/file.txt?foo=1&bar=2';

// Non funzionerà; cercare un file chiamato'file.php?foo=1&bar=2' nel
// filesystem locale.
include 'file.php?foo=1&bar=2';

// Funziona.
include 'http://www.example.com/file.php?foo=1&bar=2';

$foo = 1;
$bar = 2;
include 'file.txt';  // Funziona.
include 'file.php';  // Funziona.

?>
]]>
     </programlisting>
    </example>
     Vedere anche <link linkend="features.remote-files">Remote files</link>,
     <function>fopen</function> e <function>file</function> per informazioni
     correlate.
   </para>
   <para>
     Poichè <function>include</function> e <function>require</function>
     sono speciali costrutti di linguaggio, dovete includerli all'interno di
     blocchi di istruzioni se si trovano in un blocco condizionale.
   </para>
   <para>
    <example>
     <title>include() e i blocchi condizionali</title>
     <programlisting role="php">
<![CDATA[
<?php

// Questo NON VA BENE e non funzionerà come desiderato.
if ($condizione)
    include $file;
else
    include $un_altro;


// Questo è CORRETTO.
if ($condizione) {
    include $file;
} else {
    include $un_altro;
}

?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Trattamento dei valori restituiti: È possibile eseguire un'istruzione <function>return</function>
    in un file incluso per terminare l'esecuzione di quel
    file e restituirlo allo script che l'ha chiamato. È anche possibile restituire
    valori dai file inclusi. Potete prendere il valore di una chiamata di inclusione come
    fareste con una normale funzione.
   </simpara>
   <note>
    <simpara>
     In PHP 3, return potrebbe non apparire in un blocco a meno che esso sia
     un blocco di funzione, nel qual caso <function>return</function> si applica
     a quella funzione e non all'intero file.
    </simpara>
   </note>
   <para>
    <example>
     <title><function>include</function> and the <function>return</function> statement</title>
      <programlisting role="php">
<![CDATA[
return.php
<?php

$var = 'PHP';

return $var;

?>

noreturn.php
<?php

$var = 'PHP';

?>

testreturns.php
<?php

$foo = include 'return.php';

echo $foo; // stampa 'PHP'

$bar = include 'noreturn.php';

echo $bar; // stampa 1

?>
]]>
      </programlisting>
    </example>
   </para>
   <simpara>
    <literal>$bar</literal> ha valore <literal>1</literal> perchè l'inclusione
    è stata eseguita con successo. Notare la differenza tra gli esempi sopra. Il primo usa
    <function>return</function> all'interno di un file incluso mentre l'altro no.
    Pochi altri modi di "includere" file in variabili sono con
    <function>fopen</function>, <function>file</function> o usando
    <function>include</function> insieme con
    <link linkend="ref.outcontrol">Output Control Functions</link>.
   </simpara>

   <simpara>
    Vedere anche <function>require</function>, <function>require_once</function>,
    <function>include_once</function>, <function>readfile</function>,
    <function>virtual</function>, e
    <link linkend="ini.include-path">include_path</link>.
   </simpara>

</sect1>

 <sect1 id="function.require-once">
   <title><function>require_once</function></title>
   <para>
    L'istruzione <function>require_once</function> include e valuta
    il file specificato durante l'esecuzione dello script.
    È un comportamento simile all'istruzione <function>require</function>,
    con la sola differenza che se il codice di un file è stato
    già incluso, esso non sarà incluso nuovamente. Vedere la documentazione di
    <function>require</function> per maggiori informazioni su come funziona
    quest'istruzione.
   </para>
   <para>
    <function>require_once</function> dovrebbe essere usato nei casi dove
    lo stesso file potrebbe essere incluso e valutato più di una volta durante
    una particolare esecuzione di uno script, e volete essere sicuri  che esso sia
    incluso esattamente una volta per evitare problemi con la ridefinizione di funzioni,
    riassegnazione di valori a variabili, etc.
   </para>
   <para>
     Per esempi sull'utilizzo di <function>require_once</function> e
     <function>include_once</function>, consultare il codice
     <ulink url="&url.php.pear;">PEAR</ulink> incluso
     nell'ultima distribuzione del codice sorgente di PHP.
   </para>
   <note>
    <para>
     <function>require_once</function> è stato aggiunto in PHP 4.0.1pl2
    </para>
   </note>
   <para>
    Vedere anche: <function>require</function>,
    <function>include</function>, <function>include_once</function>,
    <function>get_required_files</function>,
    <function>get_included_files</function>, <function>readfile</function>,
    e <function>virtual</function>.
   </para>
  </sect1>

 <sect1 id="function.include-once">
   <title><function>include_once</function></title>
   <para>
    L'istruzione <function>include_once</function> include e valuta
    il file specificato durante l'esecuzione dello script.
    È un comportamento simile all'istruzione <function>include</function>,
    con la sola differenza che se il codice di un file è stato
    già incluso, esso non sarà incluso nuovamente. Come suggerisce il nome,
    esso sarà incluso solo una volta.
   </para>
   <para>
    <function>include_once</function> dovrebbe essere usato nei casi dove
    lo stesso file potrebbe essere incluso e valutato più di una volta durante
    una particolare esecuzione di uno script, e volete essere sicuri  che esso sia
    incluso esattamente una volta per evitare problemi con la ridefinizione di funzioni,
    riassegnazione di valori a variabili, etc.
   </para>
   <para>
     Per maggiori esempi sull'utilizzo di <function>require_once</function> e
     <function>include_once</function>, consultare il codice
     <ulink url="&url.php.pear;">PEAR</ulink> incluso
     nell'ultima distribuzione del codice sorgente di PHP.
   </para>
   <note>
    <para>
     <function>include_once</function> è stato aggiunto in PHP 4.0.1pl2
    </para>
   </note>
   <para>
    Vedere anche <function>include</function>,
    <function>require</function>, <function>require_once</function>,
    <function>get_required_files</function>,
    <function>get_included_files</function>, <function>readfile</function>
    e <function>virtual</function>.
   </para>
  </sect1>

 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
