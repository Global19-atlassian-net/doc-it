<?xml version="1.0" encoding="iso-8859-1"?>
<!-- EN-Revision: n/a Maintainer: spisto  Status: ready -->
  <chapter xml:id="language.control-structures" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>Strutture di controllo</title>

  <simpara>
   Qualsiasi script PHP è costituito da una serie di istruzioni. Una istruzione
   può essere un'assegnazione, una chiamata di funzione, un loop, una istruzione condizionale
   che non fa nulla (istruzione vuota).
   Le istruzioni terminano con un punto e virgola. Inoltre, le istruzioni
   si possono raggruppare in blocchi di istruzioni racchiudendole tra
   parentesi graffa.
   Un gruppo di istruzioni è, a sua volta, un'istruzione. Il presente capitolo
   descrive i differenti tipi di istruzioni.
  </simpara>

  <sect1 xml:id="control-structures.if">
   <title><literal>if</literal></title>
   <para>
    Il costrutto <literal>if</literal> è una delle più importanti
    caratteristiche di qualsiasi linguaggio, incluso PHP.
    Permette l'esecuzione condizionata di frammenti di codice.
    La struttura di controllo <literal>if</literal> di PHP è simile a quella del linguaggio C:
    <informalexample>
     <programlisting>
<![CDATA[
<?php
if (expression)
    istruzione
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Come descritto nella <link linkend="language.expressions">sezione sulle
    espressioni</link>, <replaceable>espressione</replaceable> restiruirà il suo
    valore booleano. Se <replaceable>espressione</replaceable> vale &true;,
    PHP eseguirà <replaceable>istruzione</replaceable>, e se essa vale
    &false; - la ignorerà. Più informazioni riguardo i valori valutati
    &false; possono essere trovati nella sezione <link
    linkend="language.types.boolean.casting">'Conversione in booleano'</link>
    .
   </simpara>
   <para>
    L'esempio che segue visualizzerà <computeroutput>a è maggiore
    di b</computeroutput> se <varname>$a</varname> sarà maggiore
    di <varname>$b</varname>:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
if ($a > $b)
    echo "a è maggiore di b";
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Spesso sarà necessario eseguire più di una istruzione
    condizionale.  Naturalmente non è necessario, utilizzare una singola clausola
    <literal>if</literal> per ciascuna istruzione. Si possono raggruppare diverse istruzioni
    in un singolo gruppo di istruzioni. Per esempio, il codice che segue
    visualizzerà <computeroutput>a è maggiore di b</computeroutput>
    se <varname>$a</varname> è maggiore di <varname>$b</varname>,
    e successivamente assegnerà il valore della variabile <varname>$a</varname>
    alla variabile <varname>$b</varname>:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
if ($a > $b) {
    echo "a è maggiore di b";
    $b = $a;
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Si possono annidare indefinitamente istruzioni
    <literal>if</literal>, la qual cosa fornisce piena
    flessibilità per l'esecuzione di istruzioni condizionali in diversi punti del
    programma.
   </simpara>
  </sect1>

  <sect1 xml:id="control-structures.else">
   <title><literal>else</literal></title>
   <para>
    Spesso è necessario eseguire un'istruzione se una proposizione è vera
    e un'altra istruzione se la proposizione è falsa. Per questo
    si usa la clausola <literal>else</literal>. <literal>else</literal>
    estende il costrutto <literal>if</literal> aggiungendo la possibilità
    di eseguire un'istruzione se l'espressione nel ramo <literal>if</literal>
    è &false;. L'esempio che segue
    visualizzerà <computeroutput>a è maggiore
    di b</computeroutput> se <varname>$a</varname> è maggiore di
    <varname>$b</varname> e <computeroutput>a NON è maggiore
    di b</computeroutput> altrimenti:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
if ($a > $b) {
    echo "a è maggiore di b";
} else {
    echo "a NON è maggiore di b";
}
?>
]]>
     </programlisting>
    </informalexample>

    Il ramo <literal>else</literal> viene eseguito solo se l'espressione
    nel ramo <literal>if</literal> è
    &false;, e, nel caso ci fossero delle clausole
    <literal>elseif</literal>, solamente se le espressioni in esse contenute fossero
    anch'esse &false; (vedere <link
    linkend="control-structures.elseif">elseif</link>).

   </para>
  </sect1>

  <sect1 xml:id="control-structures.elseif">
   <title><literal>elseif</literal></title>
   <para>
    <literal>elseif</literal>, come è facile intuire, è una combinazione
    di <literal>if</literal> ed <literal>else</literal>. Analogamente ad
    <literal>else</literal>, estende <literal>if</literal>
    aggiungendo la possibilità di eseguire un'altra istruzione nel caso
    in cui l'espressione contenuta nel ramo <literal>if</literal>
    sia &false;. Però, a differenza
    di <literal>else</literal>, si eseguirà l'istruzione alternativa
    solamente se l'espressione contenuta nel ramo <literal>elseif</literal>
    sarà &true;. L'esempio
    che segue, visualizzerà <computeroutput>a è maggiore di
    b</computeroutput>, <computeroutput>a è uguale a b</computeroutput>
    oppure <computeroutput>a è minore di b</computeroutput>:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
if ($a > $b) {
    echo "a è maggiore di b";
} elseif ($a == $b) {
    echo "a è uguale a b";
} else {
    echo "a è minore di b";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Nel medesimo blocco <literal>if</literal> possono essere presenti
    più di una clausola <literal>elseif</literal>. Verrà eseguita
    l'istruzione del primo ramo <literal>elseif</literal> la cui espressione
    sia &true;. In PHP è possibile
    scrivere 'else if' (due parole) e il significato sarà
    lo stesso di 'elseif' (una sola parola). Il significato sintattico
    è leggermente differente (se si ha familiarità con il linguaggio C, esso ha lo stesso
    comportamento) però al lato pratico l'effetto è
    il medesimo.
   </simpara>
   <simpara>
    L'istruzione di un ramo <literal>elseif</literal> verrà eseguita solo se l'espressione del
    ramo <literal>if</literal> e le espressioni dei
    rami <literal>elseif</literal> precedenti sono
    &false;, e se l'espressione
    del ramo <literal>elseif</literal> è
    &true;.
   </simpara>
  </sect1>

  <sect1 xml:id="control-structures.alternative-syntax">
   <title>Sintassi alternativa per le strutture di controllo</title>
   <para>
    PHP offre una sintassi alternativa per alcune delle sue strutture di controllo;
    vale a dire, <literal>if</literal>,
    <literal>while</literal>, <literal>for</literal>,
    <literal>foreach</literal> e <literal>switch</literal>.
    Fondamentalmente la sintassi alternativa consiste nel sostituire
    la prima parentesi graffa con il carattere "duepunti" (:) e la seconda parentesi graffa con
    <literal>endif;</literal>, <literal>endwhile;</literal>,
    <literal>endfor;</literal>, <literal>endforeach;</literal>, oppure
    <literal>endswitch;</literal>, rispettivamente.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php if ($a == 5): ?>
a è uguale a 5
<?php endif; ?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Nell'esempio precedente, il blocco HTML "a è uguale a 5" è incluso nel ramo
    <literal>if</literal> scritto utilizzando la sintassi alternativa.
    Il blocco HTML verrà visualizzato solamente se <varname>$a</varname> è uguale a 5.
   </simpara>
   <para>
    La sintassi alternativa si applica anche ad <literal>else</literal> ed
    <literal>elseif</literal>. Nell'esempio che segue si mostra come utilizzare la sintassi alternativa
    nel caso di un <literal>if</literal> con <literal>elseif</literal> ed
    <literal>else</literal>:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
if ($a == 5):
    echo  "a è uguale a 5";
    echo  "...";
elseif ($a == 6):
    echo  "a è uguale a 6";
    echo  "!!!";
else:
    echo  "a non è nè 5 nè 6";
endif;
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Vedere anche <link linkend="control-structures.while">while</link>,
    <link linkend="control-structures.for">for</link>, e <link
    linkend="control-structures.if">if</link> per ulteriori esempi.
   </para>
  </sect1>

  <sect1 xml:id="control-structures.while">
   <title><literal>while</literal></title>
   <para>
    Il ciclo <literal>while</literal> è la forma di ciclo più semplice
    tra quelle possibili in PHP. Si comporta come la sua controparte nel linguaggio C.
    La forma di base di un ciclo <literal>while</literal> è la seguente:
    <informalexample>
     <programlisting>
<![CDATA[
while (espressione) 
   istruzione
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Il significato di un ciclo <literal>while</literal> è semplice.
    Istruisce l'interprete PHP perchè esegua l'istruzione (o le istruzioni)
    in esso racchiuse, ripetutamente, fintanto che l'espressione contenuta
    nella clausola <literal>while</literal> ha valore &true;.
    Il valore dell'espressione viene verificato ogni volta che il ciclo
    si ripete (iterazione), così che anche se il valore dell'espressione cambia durante
    l'esecuzione dell'istruzione, il ciclo non termina fino
    all'iterazione successiva.
    Ovviamente, se l'espressione nella clausola <literal>while</literal> ha valore
    &false; dall'inizio, l'istruzione racchiusa nel blocco non verrà eseguita nemmeno
    una volta.
   </simpara>
   <para>
    Come nel caso della struttura di controllo <literal>if</literal>, si possono raggruppare
    più istruzioni nello medesimo ciclo <literal>while</literal>
    racchiudendo le istruzioni in parentesi graffa, oppure
    utilizzando la sintassi alternativa:
    <informalexample>
     <programlisting>
<![CDATA[
while (espressione): 
    istruzione 
    ... 
endwhile;
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Gli esempi seguenti sono identici e entrambi visualizzano i numeri da
    1 a 10:
    <informalexample>
     <programlisting>
<![CDATA[
<?php
/* esempio 1 */

$i = 1;
while ($i <= 10) {
    echo $i++;  /* Il valore visualizzato è il valore della
                    variabile $i prima dell'incremento
                    (post-incremento) */
}

/* esempio 2 */

$i = 1;
while ($i <= 10):
    echo $i;
    $i++;
endwhile;
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 xml:id="control-structures.do.while">
   <title><literal>do-while</literal></title>
   <simpara>
    Il ciclo <literal>do-while</literal> è simile al ciclo
    <literal>while</literal>, con l'unica differenza che il valore dell'espressione
    viene controllato alla fine di ogni iterazione anzichè all'inizio.
    La differenza più importante rispetto a <literal>while</literal> è che
    la prima iterazione di un blocco <literal>do-while</literal> verrà
    sempre eseguita (il valore dell'espressione viene controllato alla fine
    del ciclo), mentre non sarà necessariamente eseguito in un
    ciclo <literal>while</literal> (il valore dell'espressione viene
    controllato all'inizio del ciclo, e se tale valore è
    &false; dall'inizio, l'esecuzione del ciclo
    termina immediatamente).
   </simpara>
   <para>
    È ammessa una sola sintassi per il ciclo <literal>do-while</literal>:

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$i = 0;
do {
   echo $i;
} while ($i > 0);
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
     Il ciclo precedente verrà eseguito un'unica volta, dal momento che
     alla prima iterazione, quando si controlla l'espressione, il suo valore sarà
     &false; ($i non è maggiore di 0) e il ciclo di
     esecuzioni, termina.
   </simpara>
   <para>
    Chi ha utilizzato il linguaggio C conosce probabilmente un'altro modo di utilizzare
    il ciclo <literal>do-while</literal>, che permette di terminare l'esecuzione
    delle istruzioni durante l'esecuzione stessa, utilizzando
    <literal>do-while</literal>(0), e usando l'istruzione <link
    linkend="control-structures.break"><literal>break</literal></link>.
    Il codice che segue esemplifica questa possibilità:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
do {
    if ($i < 5) {
        echo "i non è abbastanza grande";
        break;
    }
    $i *= $factor;
    if ($i < $minimum_limit) {
        break;
    }
    echo "i è ok";
     /* processa i */
} while (0);
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Non vi preoccupate se l'esempio non è sufficientemente chiaro.
    Si possono scrivere ottimi programmi PHP anche senza far ricorso a questa
    'possibilità'.
   </simpara>
  </sect1>

  <sect1 xml:id="control-structures.for">
   <title><literal>for</literal></title>
   <para>
    Il ciclo <literal>for</literal> è il ciclo più complesso tra quelli disponibili in PHP.
    Si comporta come la sua controparte nel linguaggio C.
    La sintassi di un clico <literal>for</literal> è:
    <informalexample>
     <programlisting>
<![CDATA[
for (espressione1; espressione2; espressione3) 
    istruzione
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
   Il valore della prima espressione (<varname>espressione1</varname>) viene
   verificato (eseguito) una sola volta incondizionatamente all'inizio del
   ciclo.
   </simpara>
   <simpara>
    Ad ogni iterazione,
    si controlla il valore di <varname>espressione2</varname>. Se è
    &true;, il ciclo prosegue e viene eseguita
    l'istruzione (o le istruzioni) contenuta nel blocco;
    se è &false;, l'esecuzione del ciclo termina.
   </simpara>
   <simpara>
    Al termine di ogni iterazione, si verifica (si esegue)
    il valore di <varname>espressione3</varname>.
   </simpara>
   <simpara>
    Le due espressioni possono anche non essere presenti.
    Se non esiste <varname>espressione2</varname> significa che il ciclo deve
    essere eseguito indefinitamente (PHP considera implicitamente che il
    suo valore è &true;, come in C). Questa possibilità in fondo non è
    utile come può sembrare perchè obbliga a terminare il ciclo utilizzando
    l'istruzione <link
    linkend="control-structures.break"><literal>break</literal></link>
    invece di utilizzare le espressioni booleane del ciclo <literal>for</literal>
    .
   </simpara>
   <para>
    Si considerino gli esempi seguenti. In ciascun caso si visualizzeranno
    i numeri da 1 a 10:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
/* esempio 1 */

for ($i = 1; $i <= 10; $i++) {
    echo $i;
}

/* esempio 2 */

for ($i= 1; ; $i++) {
    if ($i > 10) {
        break;
    }
    echo $i;
}

/* esempio 3 */
$i = 1;
for (; ; ) {
    if ($i > 10) {
        break;
    }
    echo $i;
    $i++;
}

/* esempio 4 */
for ($i = 1; $i <= 10; print $i, $i++) ;
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Naturalmente il primo esempio sembra il migliore (o
    forse il quarto),  ma l'uso del
    ciclo <literal>for</literal> senza espressioni può essere utile
    in molti casi.
   </simpara>
   <para>
    PHP offre una sintassi alternativa (con i "punto e virgola") per i
    cicli <literal>for</literal>.
    <informalexample>
     <programlisting>
<![CDATA[
for (espressione1; espressione2; espressione3): 
   istruzione
   ...
endfor;
]]>
     </programlisting>
     </informalexample>
   </para>   
  </sect1>

  <sect1 xml:id="control-structures.foreach">
   <title><literal>foreach</literal></title>
   <para>
    PHP 4 (non PHP 3) permette l'uso della struttura di controllo <literal>foreach</literal>,
    alla stessa maniera del linguaggio Perl e altri. Ciò semplicemente fornisce
    una facile metodo per attraversare un array. <literal>foreach</literal> funziona solo con le matrici
    e genera un errore se si tenta di utilizzarlo con variabili di tipo diffente
    oppure non inizializzate. Esistono due possibili notazioni sintattiche; la seconda è
    un'utile estensione della prima:
    <informalexample>
     <programlisting>
<![CDATA[
foreach(array_expression as $value) 
      istruzione
foreach(array_expression as $key => $value) i
      struzione
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    La prima attraversa l'array dato da
    <literal>array_expression</literal>. Ad ogni ciclo, si assegna il valore
    dell'elemento corrente a <literal>$value</literal> e
    il puntatore interno avanza di una posizione (in modo tale che al ciclo successivo
    l'elemento corrente sarà il successivo elemento dell'array).
   </simpara>
   <simpara>
    La seconda esegue lo stesso ciclo con la differenza che il
    valore dell'indice corrente viene assegnato ad ogni ciclo,
    alla variabile <literal>$key</literal>.
   </simpara>
   <simpara>
    Dal PHP sono anche possibili
    <link linkend="language.oop5.iterations">cicli sugli oggetti</link>.
   </simpara>
   <para>
    <note>
     <para>
      All'inizio dell'esecuzione di un ciclo <literal>foreach</literal>
      il puntatore interno viene automaticamente posizionato nella prima
      posizione. Questo significa che non è necessario utilizzare la
      funzione <function>reset</function> prima di un ciclo 
      <literal>foreach</literal>.
     </para>
    </note>
   </para>
   <para>
    <note>
     <para>
      A meno che la matrice non sia <link linkend="language.references">per riferimento</link>,
      <literal>foreach</literal> agisce su una copia e non
      sulla matrice stessa. Pertanto il puntatore dell'array originale
      non viene modificato come accade utilizzando la funzione <function>each</function>
      e le modifiche agli elementi dell'array non
      appaiono nell'array originale.
      Tuttavia il puntatore interno della matrice originale 
      <emphasis>viene</emphasis> avanzato durante l'elaborazione della
      matrice. Se si assume che il ciclo foreach giunga al termine, allorasi avrà che
      il puntatore interno della matrcie sarà al termine della matrice stessa.
     </para>
     <para>
      Dal PHP 5 si può modificare facilmente gli elementi di una matrice anteponendo
      &amp; a <literal>$value</literal> with &amp;. Questo assegna un
      <link linkend="language.references">riferimento</link> anzichè copiare
      il valore.
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$arr = array(1, 2, 3, 4);
foreach ($arr as &$value) {
    $value = $value * 2;
}
// $arr vale ora array(2, 4, 6, 8)
?>
]]>
       </programlisting>
      </informalexample>
      Questo è possibile soltanto se l'array indicato può essere referenziato
      (ad esempio è una variabile).
     </para>
    </note>
   </para>
   <para>
    <note>
     <para>
      <literal>foreach</literal> non offre la possibilità di annullare la generazione
     di messaggi d'errore utilizzando il carattere '@'.
     </para>
    </note>
   </para>
   <para>
    Avete probabilmente notato che i due cicli seguenti sono identici da un
    punto di vista funzionale:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$arr = array("one", "two", "three");
reset ($arr);
while (list(, $value) = each ($arr)) {
    echo "Valore: $value<br />\n";
}

foreach ($arr as $value) {
    echo "Valore: $value<br />\n";
}
?>
]]>
     </programlisting>
    </informalexample>
    Allo stesso modo i due cicli seguenti sono identici:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$arr = array("one", "two", "three");
reset ($arr);
while (list($key, $value) = each ($arr)) {
    echo "Chiave: $key; Valore: $value<br />\n";
}

foreach ($arr as $key => $value) {
    echo "Chiave: $key; Valore: $value<br>\n";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Di seguito, altri esempi per mostrare possibili utilizzi:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
/* esempio 1 foreach: solo il valore */
$a = array(1, 2, 3, 17);

foreach ($a as $v) {
   echo "Valore corrente di \$a: $v.\n";
}

/* esempio 2 foreach: valore (con la chiave stampata) */

$a = array(1, 2, 3, 17);

$i = 0; /* solo per un proposito illustrativo */

foreach ($a as $v) {
    echo "\$a[$i] => $v.\n";
    $i++;
}

/* esempio 3 foreach: chiave e valore */

$a = array(
    "uno" => 1,
    "due" => 2,
    "tre" => 3,
    "diciassette" => 17
);

foreach ($a as $k => $v) {
    echo "\$a[$k] => $v.\n";
}

/* esempio 4 foreach: array multidimensionali */
$a = array();
$a[0][0] = "a";
$a[0][1] = "b";
$a[1][0] = "y";
$a[1][1] = "z";

foreach ($a as $v1) {
    foreach ($v1 as $v2) {
        echo "$v2\n";
    }
}

/* esempio 5 foreach: array dinamici */

foreach (array(1, 2, 3, 4, 5) as $v) {
    echo "$v\n";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 xml:id="control-structures.break">
   <title><literal>break</literal></title>
   <simpara>
    <literal>break</literal> termina l'esecuzione di una struttura
    <literal>for</literal>, <literal>foreach</literal>,
    <literal>while</literal>, <literal>do-while</literal> o
    <literal>switch</literal>.
   </simpara>
   <simpara>
    <literal>break</literal> accetta un argomento opzionale che definisce,
    nel caso di cicli annidati, il livello del ciclo che è da
    interrompere.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$arr = array ('uno', 'due', 'tre', 'quattro', 'stop', 'cinque');
while (list (, $val) = each ($arr)) {
    if ($val == 'stop') {
        break;    /* Qui si può anche usare 'break 1;'. */
    }
    echo "$val<br />\n";
}

/* Uso dell'argomento opzionale. */

$i = 0;
while (++$i) {
    switch ($i) {
    case 5:
        echo "At 5<br />\n";
        break 1;  /* Interrompe solo awitch. */
    case 10:
        echo "At 10; quitting<br />\n";
        break 2;  /* Interrompe switch e while. */
    default:
        break;
    }
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 xml:id="control-structures.continue">
   <title><literal>continue</literal></title>
   <simpara>
    <literal>continue</literal> si utilizza per interrompere l'esecuzione
    del ciclo corrente e continuare con l'esecuzione
    dall'inizio del ciclo successivo dopo avere valutato la condizione.
   </simpara>
   <note>
    <simpara>
     Si noti che in PHP l'istruzione
     <link linkend="control-structures.switch">switch</link> è considerata un'elemento
     di loop per gli scopi di 
     <literal>continue</literal>.
    </simpara>
   </note>
   <simpara>
    <literal>continue</literal> accetta un argomento numerico opzionale
    che definisce, nel caso di cicli annidati, il numero di cicli da interrompere
    e da cui iniziare l'esecuzione dell'iterazione successiva.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
while (list($key, $value) = each ($arr)) {
    if (!($key % 2)) { // salta odd members
        continue;
    }
    do_something_odd($value);
}

$i = 0;
while ($i++ < 5) {
    echo "Esterno<br />\n";
    while (1) {
        echo "&nbsp;&nbsp;Centrale<br />\n";
        while (1) {
            echo "&nbsp;&nbsp;Interno<br />\n";
            continue 3;
        }
        echo "Questo non sarà mai stampato.<br />\n";
    }
    echo "Nemmeno questo.<br />\n";
}
?>
]]>
     </programlisting>
     </informalexample>
    </para>
    <para>
     L'omissione del punto e virgola dopo <literal>continue</literal> può creare 
     confuzione. Nel sseguente esempio si illustra cosa non di deve fare.
    </para>
    <para>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
  for ($i = 0; $i < 5; ++$i) {
      if ($i == 2)
          continue
      print "$i\n";
  }
?>
]]>
      </programlisting>
      <para>
       Ci si può aspettare come risultato:
      </para>
      <screen>
<![CDATA[

1
3
4
]]>
      </screen>
      <para>
       invece si avrà:
      </para>
      <screen>
<![CDATA[
2
]]>
      </screen>
      <para>
       poichè il valore restituida da <function>print</function>
       è <literal>int(1)</literal> e sembrerà il numero
       opzionale indicato in precedenza.
      </para>
     </informalexample>
    </para>
  </sect1>

  <sect1 xml:id="control-structures.switch">
   <title><literal>switch</literal></title>
   <simpara>
    <literal>switch</literal> è simile a una serie di
    if sulla stessa espressione. In molti casi può essere
    necessario confrontare una variabile (o espressione) con
    differenti valori ed eseguire un differente blocco di istruzioni a seconda
    del valore di detta variabile. Questo è esattamente quello che fa la struttura
    di controllo <literal>switch</literal>.
   </simpara>
   <note>
    <simpara>
     Si noti che a differenza di altri linguaggi, l'istruzione
     <link linkend="control-structures.continue">continue</link>
     si può utilizzare anche con switch ed ha un comportamento simile a <literal>break</literal>. 
     Se si ha uno switch all'interno di un ciclo e si desidera continuare con il prossimo ciclo
     del loop esterno, utilizzare <literal>continue 2</literal>.
    </simpara>
   </note>
   <para>
    Gli esempi seguenti mostrano due maniere differenti di scrivere
    la stessa cosa, uno utilizzando una serie di istruzioni <literal>if</literal> ed
    <literal>elseif</literal> l'altro utilizzando 
    <literal>switch</literal>:
    <example>
     <title>Struttura <literal>switch</literal></title>
     <programlisting role="php">
<![CDATA[
<?php
if ($i == 0) {
    echo  "i è uguale a 0";
} elseif ($i == 1) {
    echo  "i è uguale a 1";
} elseif ($i == 2) {
    echo  "i è uguale a 2";
}

switch ($i) {
    case 0:
        echo "i è uguale a 0";
        break;
    case 1:
        echo "i è uguale a 1";
        break;
    case 2:
        echo "i è uguale a 2";
        break;
}
?>
]]>
     </programlisting>
    </example>
    <example>
    <title>L'istruzione <literal>switch</literal> permette l'uso di stringhe</title>
     <programlisting role="php">
<![CDATA[
<?php
switch ($i) {
case "apple":
    echo "i is apple";
    break;
case "bar":
    echo "i is bar";
    break;
case "cake":
    echo "i is cake";
    break;
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    È importante comprendere esattamente come viene eseguita la
    clausola <literal>switch</literal> per evitare errori.
    Un'istruzione <literal>switch</literal> esegue linea dopo linea
    le istruzioni in essa contenuta. All'inizio non viene eseguito
    alcun codice. Solamente quando incontra una clausola <literal>case</literal>
    il cui valore è uguale al valore della viariabile, PHP inizia ad
    eseguire le istruzioni contenute nel blocco <literal>case</literal>.
    PHP continua l'esecuzione delle istruzioni fino alla termine del
    blocco <literal>switch</literal>, o quando incontra un'istruzione
    <literal>break</literal>. Se non esiste alcuna
    istruzione <literal>break</literal> al termine di un blocco case
    PHP continuerà l'esecuzione delle istruzioni del blocco case successivo.
    Per esempio:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
switch ($i) {
    case 0:
        echo "i è uguale a 0";
    case 1:
        echo "i è uguale a 1";
    case 2:
        echo "i è uguale a 2";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    In questo caso se <varname>$i</varname> è uguale a 0, PHP eseguirà tutte le
    istruzioni echo!. Se <varname>$i</varname> è uguale a 1,  PHP eseguirà le ultime due
    echo. Si sarebbe ottenuto il comportamento atteso ( visualizzazione 
    di 'i uguale a 2') solamente se <varname>$i</varname> è uguale a 2. Pertanto
    è importante non dimenticare l'istruzione <literal>break</literal>
    (anche se in alcuni casi potrà essere necessario non utilizzarla).
   </simpara>
   <simpara>
    In un'istruzione <literal>switch</literal>, la condizione in parentesi
    viene valutata una sola volta e il risultato viene confrontato con
    ciascun ramo <literal>case</literal>. Utilizzando <literal>elseif</literal>,
    la condizione viene valutata una seconda volta. Se tale condizione è più
    complessa di un semplice confronto e/o è in un ciclo piuttosto pesante,
    l'uso di <literal>switch</literal> dovrebbe garantire un minor tempo di esecuzione.
   </simpara>
   <para>
    Un blocco case può anche non contenere istruzioni, nel qual caso
    il controllo passa semplicemente al successivo blocco case.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
switch ($i) {
case 0:
case 1:
case 2:
     print "i è minore di 3 ma non negativo";
     break;
case 3:
     print "i è 3";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Un blocco case speciale è il il blocco case di <literal>default</literal>.
    Uguaglia tutte le condizioni non uguagliate nei blocchi case precedenti
    e dev'essere l'ultimo blocco <literal>case</literal>. Per esempio:
   <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
switch ($i) {
case 0:
    echo "i è uguale a 0";
    break;
case 1:
    echo "i è uguale a 1";
    break;
case 2:
    echo "i è uguale a 2";
    break;
default:
    echo "i è diverso da 0, 1 o 2";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    L'espressione in un ramo <literal>case</literal> può essere
    qualsiasi espressione il cui valore sarà di tipo intero, decimale,
    numerico e stringa. Array e oggetti (objects) non sono ammessi
    a meno che non siano dereferenziati a un tipo di dato semplice tra quelli precedentemente elencati.
   </para>
   <para>
    Come per altre strutture di controllo è possibile utilizzare una sintassi
    alternativa. Si veda
    <link linkend="control-structures.alternative-syntax">Sintassi alternativa per le strutture di controllo</link>
    per ulteriori esempi.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
switch ($i):
case 0:
    echo "i è uguale a 0";
    break;
case 1:
    echo "i è uguale a 1";
    break;
case 2:
    echo "i è uguale a 2";
    break;
default:
    echo "i è diverso da 0, 1 o 2";
endswitch;
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 xml:id="control-structures.declare">
   <title><literal>declare</literal></title>
   <para>
    Il costrutto <literal>declare</literal> si usa per definire
    direttive di esecuzione per blocchi di istruzioni.
    La sintassi è simile alla sintassi
    di altre strutture di controllo:
    <informalexample>
     <programlisting>
<![CDATA[
declare (direttiva)
    istruzione
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    La sezione <literal>direttiva</literal> permette di
    impostare il comportamento del blocco <literal>declare</literal>
    .
    Attualmente è riconosciuta una sola direttiva: la
    direttiva <literal>ticks</literal>. (Fare riferimento più in basso per ulteriori
    informazioni relative alla
    direttiva
    <link linkend="control-structures.declare.ticks">ticks</link>)
   </para>
   <para>
    Verrà eseguita la parte <literal>istruzione</literal> del
    blocco <literal>declare</literal> -- come
    verrà eseguita e quali effetti collaterali emergeranno durante l'esecuzione
    potrà dipendere dalla direttiva impostata nel
    blocco <literal>direttiva</literal>.
   </para>
   <para>
    L'istruzione <literal>declare</literal> può essere usata anche con visubilità globale,
    influenzando tutto il codice che la segue.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
// queste righe hanno il medesimo effetto:
 
// si può utitlizzare in questo modo:
declare(ticks=1) {
    // inserire tutto il codice
}
 
// o in questo modo
declare(ticks=1);
// inserire tutto il codice
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <sect2 xml:id="control-structures.declare.ticks">
    <title>Ticks</title>
    <para>Un tick è un evento che si verifica per ogni
    <varname>N</varname> istruzioni di basso livello eseguite
    dal parser all'interno del blocco <literal>declare</literal>.
    Il valore per <varname>N</varname> viene specificato
    usando <literal>ticks=N</literal>
    all'interno della sezione <literal>direttiva</literal> del blocco
    <literal>declare</literal>.
   </para>
   <para>
    L'evento (o gli eventi) che si verifica su ogni tick è specificato usando
    <function>register_tick_function</function>. Vedere l'esempio
    più in basso per ulteriori dettagli. Notare che può verificarsi più di un evento
    per ogni tick.
   </para>
   <para>
    <example>
     <title>Segue una sezione di codice PHP</title>
     <programlisting role="php">
<![CDATA[
<?php
// Una funzione che registra il tempo quando viene chiamata
function profile($dump = FALSE)
{
    static $profile;

    // Restituisce il tempo immagazinato in $profile, successivamente lo cancella
    if ($dump) {
        $temp = $profile;
        unset($profile);
        return $temp;
    }

    $profile[] = microtime();
}

// Imposta un tick handler
register_tick_function("profile");

// Inizializza la funzione prima del blocco declare
profile();

// Esegue un blocco di codice, attraverso un tick ogni seconda istruzione
declare(ticks = 2) {
    for ($x = 1; $x < 50; ++$x) {
        echo similar_text(md5($x), md5($x*$x)), "<br />;";
    }
}

// Mostra i dati immagazionati nel profilo
print_r(profile(TRUE));
?>
]]>
     </programlisting>
    </example>
    L'esempio descrive il codice PHP all'interno del blocco 'declare',
    registrando il tempo in cui è stata eseguita ogni seconda istruzione
    di basso livello. Questa informazione può
    poi essere usata per trovare le aree lente all'interno di particolari
    segmenti di codice. Questo processo può essere ottimizzato usando altri
    metodi: usando i tick è più conveniente e facile da
    implementare.
   </para>
   <simpara>
    I tick sono ben adeguati per il debugging, l'implementazione di semplici
    multitasking, backgrounded I/O e molti altri compiti.
   </simpara>
   <simpara>
    Vedere anche <function>register_tick_function</function> e
    <function>unregister_tick_function</function>.
   </simpara>
   </sect2>
  </sect1>

  <sect1 xml:id="function.return">
   <title>return</title>
   <simpara>
    Se viene chiamato all'interno di una funzione, l'istruzione <function>return</function>
    termina immediatamente l'esecuzione della funzione corrente, e
    restituisce il suo argomento come valore della funzione
    chiamata. <function>return</function> terminerà anche l'esecuzione di un'istruzione
    <function>eval</function> o di un file di script.
   </simpara>
   <simpara>
    Se viene chiamato in uno scope globale, allora verrà terrminata l'esecuzione
    del file di script corrente. Nel caso in cui il file di script corrente sia un file chiamato da
    <function>include</function> o <function>require</function>,
    il controllo viene passato al file chiamante. Ciononostante, se
    il file di script corrente è un file chiamato da <function>include</function>, allora
    il valore dato da <function>return</function> verrà restituito
    come valore della chiamata <function>include</function>. Se
    viene chiamato <function>return</function> all'interno del file di script
    principale, allora l'esecuzione dello script terminerà. Se il file di script corrente
    è stato nominato da <link
    linkend="ini.auto-prepend-file">auto_prepend_file</link> o <link
    linkend="ini.auto-append-file">auto_append_file</link>
    con le opzioni di configurazione nel&php.ini;, allora l'esecuzione di quello script
    termina.
   </simpara>
   <simpara>Per maggiori informazioni, consultare <link
   linkend="functions.returning-values">Valori restituiti</link>.
   </simpara>
   <para>
    <note>
     <simpara>
      Notate che poichè <function>return</function> è un costrutto di linguaggio
      e non una funzione, le parentesi che circondano i suoi
      argomenti sono <emphasis>soltanto</emphasis> richieste se l'argomento
      contiene un'espressione. E' comune non utilizzarle quando si ritorna una variabile,
      ed inoltre il PHP ha meno lavoro da svolgere
      in questo caso.
     </simpara>
    </note>
    <note>
     <simpara>
      Non si dovrebbe <emphasis>mai</emphasis> utilizzare le parantesi intorno alle variabili restituite
      quando sono restituite per riferimento, poichè non funzionerebbe. Per riferimento
      si possono restituire solo variabili, non il risultato di un'istruzione.
      Se si utilizza <literal>return ($a);</literal> non si restituisce una variabile,
      ma il risultato dell'espressione <literal>($a)</literal>
      (che, ovviamente, è il valore di <varname>$a</varname>).
      </simpara>
     </note>
   </para>
  </sect1>


 <sect1 xml:id="function.require">
   <title><function>require</function></title>

   <simpara>
    L'istruzione <function>require</function> include e valuta
    il file specifico.
   </simpara>
   <simpara>
     <function>require</function> include e valuta uno specifico file.
     Informazioni dettagliate su come funziona quest'inclusione sono descritte nella
     documentazione di <function>include</function>.
   </simpara>
   <simpara>
     <function>require</function> e <function>include</function>
     sono identiche in ogni senso eccetto per come esse trattano gli errori.
     <function>include</function> produce un
     <link linkend="internal.e-warning">Warning</link> mentre
     <function>require</function> restituisce un <link linkend="internal.e-error">
     Fatal Error</link>. In altre parole, non esitate ad usare
     <function>require</function> se volete che un file mancante fermi l'esecuzione
     della pagina. <function>include</function> non si comporta in questo modo, lo
     script continuerà nonostante tutto. Assicuratevi di avere un appropriato
     <link linkend="ini.include-path">include_path</link> impostato a dovere.
   </simpara>
   <para>
    <example>
     <title>Esempio di base con <function>require</function></title>
     <programlisting role="php">
<![CDATA[
<?php

require 'prepend.php';

require $qualche_file;

require ('qualche_file.txt');

?>
]]>
     </programlisting>
   </example>
   </para>
   <simpara>
    Vedere la documentazione di <function>include</function> per più esempi.
   </simpara>
   <para>
    <note>
     <simpara>
      Prima di PHP 4.0.2, si applica la seguente logica: <function>require</function>
      tenterà sempre di leggere il file chiamato, anche se la riga su cui si trova non verrà mai eseguita.
      L'istruzione condizionale non avrà effetto su <function>require</function>. Comunque,
      se la riga su cui si verifica <function>require</function> non viene eseguita,
      non sarà eseguito nemmeno il codice del file incluso. Similmente, le strutture
      cicliche non avranno effetto sul 
      comportamento di <function>require</function>. Sebbene
      il codice contenuto nel file incluso è ancora soggetto a ciclo,
      <function>require</function> stesso si verifica solo una volta.
     </simpara>
    </note>
   </para>

   &note.language-construct;
 
   &warn.no-win32-fopen-wrapper;

   <simpara>
    Vedere anche <function>include</function>, <function>require_once</function>,
    <function>include_once</function>, <function>eval</function>,
    <function>file</function>, <function>readfile</function>,
    <function>virtual</function> e <link linkend="ini.include-path">include_path</link>.
   </simpara>
  </sect1>

 <sect1 xml:id="function.include">
   <title><function>include</function></title>
   <simpara>
    L'istruzione <function>include</function> include e valuta
    il file specificato.
   </simpara>
   <simpara>
     La documentazione seguente si applica anche a <function>require</function>.
     I due costrutti sono identici in ogni aspetto eccetto per come essi trattano
     gli errori. <function>include</function> produce un
     <link linkend="internal.e-warning">Warning</link> mentre <function>require</function>
     restituisce un <link linkend="internal.e-error">Fatal Error</link>.
     In altre parole, usate <function>require</function> se volete che
     un file mancante fermi l'esecuzione della pagina. <function>include</function>
     non si comporta in questo modo, lo script continuerà nonostante tutto. Assicuratevi di avere un
     appropriato <link linkend="ini.include-path">include_path</link> impostato a dovere.
     Attenzione che nelle versioni di PHP antecedenti la release 4.3.5 errori di parsing nei
     file inclusi non bloccavano l'esecuzione. Da questa versione lo fanno.
   </simpara>
   <simpara>
    I file da includere sono prima cercati nella include_path relativa rispetto alla directory di lavoro
    e quindi nella include_path relativa alla directory dello script. Ad esempio, se la include_path
    è impostata a <literal>.</literal>, e la directory di lavoro corrente è <filename class="directory">/www/</filename>,
    si può includere <filename>include/a.php</filename> e qui vi è <literal>include "b.php"</literal>,
    il file <filename>b.php</filename> verrà prima cercato in <filename class="directory">/www/</filename>
    e quindi in <filename class="directory">/www/include/</filename>.
    Se il nome del file inizia con <literal>../</literal>, viene cercato solo nella
    include_path relativa alla directory di lavoro corrente.
   </simpara>
   <simpara>
     Quando un file viene incluso, il codice che esso contiene eredita lo
     <link linkend="language.variables.scope">scope delle variabili</link> della
     riga in cui si verifica l'inclusione. Qualsiasi variabile disponibile in quella riga
     nella chiamata al file sarà disponibile all'interno del file chiamato, da
     quel punto in avanti.
     Tuttavia tutte le funzioni a le classi definite all'interno di un file di include hanno
     visibilità glibale.
   </simpara>
   <para>
     <example>
      <title>Esempio di base con <function>include</function></title>
      <programlisting role="php">
<![CDATA[
vars.php
<?php

$colore = 'verde';
$frutto = 'mela';

?>

test.php
<?php

echo "Una $frutto $colore"; // Una

include 'vars.php';

echo "Una $frutto $colore"; // Una mela verde

?>
]]>
      </programlisting>
     </example>
   </para>
   <simpara>
     Se l'inclusione si verifica dentro una funzione all'interno del file chiamato,
     allora tutto il codice contenuto nel file chiamato si comporterà come
     se esso sia stato definito all'interno di una funzione. Così, esso seguirà
     lo scope delle variabili di quella funzione.
   </simpara>
   <para>
     <example>
     <title>Inclusione all'interno di funzioni</title>
      <programlisting role="php">
<![CDATA[
<?php

function foo()
{
    global $frutto;

    include 'vars.php';

    echo "Una $frutto $colore";
}

/* vars.php è nello scope di foo() così    *
 * $colore NON è disponibile fuori di      *
 * questo scope. $frutto si perchè è stato *
 * dichiarato globale.                     */

foo();                        // Una mela verde
echo "Una $frutto $colore";   // Una mela

?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
     Quando un file viene incluso, il parsing esce dalla modalità PHP e
     entra in modalità HTML all'inizio del file incluso, e riprende
     alla fine. Per questa ragione, qualunque codice all'interno del
     file incluso che dovrebbe essere eseguito come codice PHP deve essere incluso all'interno
     dei <link linkend="language.basic-syntax.phpmode">tag PHP validi di apertura
     e chiusura</link>.
   </simpara>
   <simpara>
     Se "<link linkend="ini.allow-url-fopen">URL fopen wrappers</link>"
     nel PHP sono abilitati (come nella configurazione di default),
     potete specificare il file da includere usando un URL (via HTTP o
     altri wrapper supportati - vedere <xref linkend="wrappers"/> per avere la lista
     dei protocolli supportati ) invece che un percorso locale. Se il server chiamato interpreta
     il file incluso come codice PHP, le variabili possono essere passate
     al file incluso usando una stringa di richiesta URL come con l'utilizzo di HTTP GET. Non è
     proprio parlare della stessa cosa includere il file e averlo
     ereditato dallo scope di variabili del file chiamante; lo script è stato attualmente
     eseguito su un server remoto e il risultato è poi stato
     incluso nello script locale.
   </simpara>
   &warn.no-win32-fopen-wrapper;
   <para>
    <example>
     <title><function>include</function> attraverso HTTP</title>
     <programlisting role="php">
<![CDATA[
<?php

/* Questo esempio assume che www.example.com è configurato per eseguire file 
 * .php e non file .txt. Anche, 'Funziona' qui significa che le variabili    
 * $foo e $bar sono disponibili all'interno del file incluso.                */

// Non funzionerà; file.txt non è stato trattato da www.example.com come PHP
include 'http://www.example.com/file.txt?foo=1&bar=2';

// Non funzionerà; cercare un file chiamato'file.php?foo=1&bar=2' nel
// filesystem locale.
include 'file.php?foo=1&bar=2';

// Funziona.
include 'http://www.example.com/file.php?foo=1&bar=2';

$foo = 1;
$bar = 2;
include 'file.txt';  // Funziona.
include 'file.php';  // Funziona.

?>
]]>
     </programlisting>
    </example>
     Vedere anche <link linkend="features.remote-files">Remote files</link>,
     <function>fopen</function> e <function>file</function> per informazioni
     correlate.
   </para>
   <para>
     Poichè <function>include</function> e <function>require</function>
     sono speciali costrutti di linguaggio, dovete includerli all'interno di
     blocchi di istruzioni se si trovano in un blocco condizionale.
   </para>
   <para>
    <example>
     <title>include() e i blocchi condizionali</title>
     <programlisting role="php">
<![CDATA[
<?php

// Questo NON VA BENE e non funzionerà come desiderato.
if ($condizione)
    include $file;
else
    include $un_altro;


// Questo è CORRETTO.
if ($condizione) {
    include $file;
} else {
    include $un_altro;
}

?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Trattamento dei valori restituiti: È possibile eseguire un'istruzione <function>return</function>
    in un file incluso per terminare l'esecuzione di quel
    file e restituirlo allo script che l'ha chiamato. È anche possibile restituire
    valori dai file inclusi. Potete prendere il valore di una chiamata di inclusione come
    fareste con una normale funzione. Tuttavia questo non è possibile quando si include file
    remoti, a meno che l'output del file remoto non contenga <link linkend="language.basic-syntax.phpmode">tag di inizio
    e fine codice validi in PHP</link> (come i file locali). Si possono dichiarare variabili
    all'interno di questi tag e queste saranno inserite nel punto in cui il
    file è stato incluso.
   </simpara>
   <para>
    Poichè <function>include</function> è un costrutto del linguaggio speciale,
    non richiede le parentesi per i propri argomenti. Fare attenzione quando lo si confronta
    i valori restituiti.
    <example>
     <title>Confronto dei valori restituiti da include</title>
     <programlisting role="php">
<![CDATA[
<?php
// non funziona, viene trattato come include(('vars.php') == 'OK'), ad esempio. include('')
if (include('vars.php') == 'OK') {
    echo 'OK';
}
 
// funziona
if ((include 'vars.php') == 'OK') {
    echo 'OK';
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    <note>
     <simpara>
      In PHP 3, return potrebbe non apparire in un blocco a meno che esso sia
      un blocco di funzione, nel qual caso <function>return</function> si applica
      a quella funzione e non all'intero file.
     </simpara>
    </note>
   </para>
   <para>
    <example>
     <title><function>include</function> and the <function>return</function> statement</title>
      <programlisting role="php">
<![CDATA[
return.php
<?php

$var = 'PHP';

return $var;

?>

noreturn.php
<?php

$var = 'PHP';

?>

testreturns.php
<?php

$foo = include 'return.php';

echo $foo; // stampa 'PHP'

$bar = include 'noreturn.php';

echo $bar; // stampa 1

?>
]]>
      </programlisting>
    </example>
   </para>
   <simpara>
    <literal>$bar</literal> ha valore <literal>1</literal> perchè l'inclusione
    è stata eseguita con successo. Notare la differenza tra gli esempi sopra. Il primo usa
    <function>return</function> all'interno di un file incluso mentre l'altro no.
    Se il file non può essere incluso la funzione restituisce &false; e genera
    un messaggio di <literal>E_WARNING</literal>
   </simpara>
   <para>
    Se esistono funzioni definite nel file di include, queste possono essere utilizzate
    nel file principale a prescindere se esse siano prima o dopo il <function>return</function>.
    Se un file viene incluso due volte, il PHP 5 genera un errore fatale, poichè le funzioni
    sono già dichiarate, mentre il PHP 4 non considera le funzioni dichiarate
    dopo il <function>return</function>.
    Si raccomanda di utilizzare <function>include_once</function> invece di verificare
    se un file è già stato incluso ed uscire tramite condizione dal
    file incluso.
   </para>
   <simpara>
    Un'altro metodo per "includere" file PHP in una variabile consiste nel catturarne
    l'output tramite <link linkend="ref.outcontrol">le funzioni di controllo 
    dell'output</link> ed <function>include</function>. Ad esempio:
   </simpara>
   <para>
    <example>
     <title>Utilizzo del buffering dell'output per inserire un file PHP in una stringa</title>
      <programlisting role="php">
<![CDATA[
<?php
$string = get_include_contents('somefile.php');
 
function get_include_contents($filename) {
    if (is_file($filename)) {
        ob_start();
        include $filename;
        $contents = ob_get_contents();
        ob_end_clean();
        return $contents;
    }
    return false;
}
 
?>
]]>
      </programlisting>
    </example>
   </para>
   <para>
    Per includere automaticamente dei file negli script vedere i parametri
    <link linkend="ini.auto-prepend-file">auto_prepend_file</link> e
    <link linkend="ini.auto-append-file">auto_append_file</link>
    nel &php.ini;.
   </para>
	 
   &note.language-construct;
   <simpara>
    Vedere anche <function>require</function>, <function>require_once</function>,
    <function>include_once</function>, <function>readfile</function>,
    <function>virtual</function>, e
    <link linkend="ini.include-path">include_path</link>.
   </simpara>
 </sect1>
 <sect1 xml:id="function.require-once">
   <title><function>require_once</function></title>
   <para>
    L'istruzione <function>require_once</function> include e valuta
    il file specificato durante l'esecuzione dello script.
    È un comportamento simile all'istruzione <function>require</function>,
    con la sola differenza che se il codice di un file è stato
    già incluso, esso non sarà incluso nuovamente. Vedere la documentazione di
    <function>require</function> per maggiori informazioni su come funziona
    quest'istruzione.
   </para>
   <para>
    <function>require_once</function> dovrebbe essere usato nei casi dove
    lo stesso file potrebbe essere incluso e valutato più di una volta durante
    una particolare esecuzione di uno script, e volete essere sicuri  che esso sia
    incluso esattamente una volta per evitare problemi con la ridefinizione di funzioni,
    riassegnazione di valori a variabili, etc.
   </para>
   <para>
     Per esempi sull'utilizzo di <function>require_once</function> e
     <function>include_once</function>, consultare il codice
     <link xlink:href="&url.php.pear;">PEAR</link> incluso
     nell'ultima distribuzione del codice sorgente di PHP.
   </para>
   <para>
    Il valore restituito è simile a <function>include</function>. Se il file è
    già stato incluso, la funzione restituisce &true;.
   </para>
   <para>
    <note>
     <para>
      <function>require_once</function> è stato aggiunto in PHP 4.0.1pl2
     </para>
    </note>
   </para>
   <para>
    <note>
     <para>
      Fare attenzione al fatto che il comportamento di <function>require_once</function>
      e <function>include_once</function> può non essere quello atteso in sistemi
      che non distinguono le maiuscole dalle minuscole (tipo Windows).
      <example>
       <title><function>require_once</function> non distingue tra maiuscole e minuscole in Windows</title>
       <programlisting role="php">
<![CDATA[
<?php
require_once("a.php"); // questo include include a.php
require_once("A.php"); // questo include a.php ancora, in Windows! (solo PHP 4)
?>
]]>
        </programlisting>
      </example>
      Questo comportamento è stato modificato in PHP 5 - il percorso viene normalizzato, in modo tale che
      <filename>C:\PROGRA~1\A.php</filename> diventa simile a
      <filename>C:\Program Files\a.php</filename> e quindi il file vine incluso solo una volta.
     </para>
    </note>
   </para>
   &warn.no-win32-fopen-wrapper;
   <para>
    Vedere anche: <function>require</function>,
    <function>include</function>, <function>include_once</function>,
    <function>get_required_files</function>,
    <function>get_included_files</function>, <function>readfile</function>
    e <function>virtual</function>.
   </para>
  </sect1>

 <sect1 xml:id="function.include-once">
   <title><function>include_once</function></title>
   <para>
    L'istruzione <function>include_once</function> include e valuta
    il file specificato durante l'esecuzione dello script.
    È un comportamento simile all'istruzione <function>include</function>,
    con la sola differenza che se il codice di un file è stato
    già incluso, esso non sarà incluso nuovamente. Come suggerisce il nome,
    esso sarà incluso solo una volta.
   </para>
   <para>
    <function>include_once</function> dovrebbe essere usato nei casi dove
    lo stesso file potrebbe essere incluso e valutato più di una volta durante
    una particolare esecuzione di uno script, e volete essere sicuri  che esso sia
    incluso esattamente una volta per evitare problemi con la ridefinizione di funzioni,
    riassegnazione di valori a variabili, etc.
   </para>
   <para>
    Per maggiori esempi sull'utilizzo di <function>require_once</function> e
    <function>include_once</function>, consultare il codice
    <link xlink:href="&url.php.pear;">PEAR</link> incluso
    nell'ultima distribuzione del codice sorgente di PHP.
   </para>
   <para>
    Il valore restituito è il simile a  <function>include</function>. Se il file è già
    stato incluso, la funzione restituisce &true;.
   </para>
   <para>
    <note>
     <para>
     <function>include_once</function> è stato aggiunto in PHP 4.0.1pl2
     </para>
    </note>
   </para>
   <para>
    <note>
     <para>
      Fare attenzione al fatto che il comportamento di <function>include_once</function>
      e <function>require_once</function> può non essere quello atteso in sistemi
      che non distinguono le maiuscole dalle minuscole (tipo Windows).
      <example>
       <title><function>include_once</function> non distingue tra maiuscole e minuscole in Windows</title>
       <programlisting role="php">
<![CDATA[
<?php
include_once("a.php"); // questo include include a.php
include_once("A.php"); // questo include a.php ancora, in Windows! (solo PHP 4)
?>
]]>
        </programlisting>
      </example>
      Questo comportamento è stato modificato in PHP 5 - il percorso viene normalizzato, in modo tale che
      <filename>C:\PROGRA~1\A.php</filename> diventa simile a
      <filename>C:\Program Files\a.php</filename> e quindi il file vine incluso solo una volta.
     </para>
    </note>
   </para>
   &warn.no-win32-fopen-wrapper;
   <para>
    Vedere anche <function>include</function>,
    <function>require</function>, <function>require_once</function>,
    <function>get_required_files</function>,
    <function>get_included_files</function>, <function>readfile</function>
    e <function>virtual</function>.
   </para>
  </sect1>

 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
