<?xml version="1.0" encoding="iso-8859-1"?>
<!-- EN-Revision: n/a Maintainer: spisto  Status: ready -->
 <chapter xml:id="language.operators" xmlns="http://docbook.org/ns/docbook">
  <title>Operatori</title>
  <simpara>
   Un operatore è un qualcosa che si posiziona tra uno o più valori (od espressioni,
   in gergo tecnico) e produce un'altro valore (in modo tale che la costruzione
   stessa diventi a sua volta un'espressione). In questo modo si può considerare operatori le funzioni
   o costruzioni che restituiscono valori (tipo print), e quelle che non restituiscono
   nulla (come echo) possono essere considerate come altro tipo di funzione.
  </simpara>
  <para>
   Esistono tre tipi di operatori. Una tipologia sono gli operatori unari, i quali richiedono
   un solo valore, ad esempio ! (l'operatore di negazione) oppure ++
   (l'operatore di autoincremento). Nel secondo gruppo troviamo gli operatori binari; questi
   costituiscono la maggior parte degli operatori disponibili in PHP, un e elenco di questi
   è presente alla sezione <link linkend="language.operators.precedence">Precednza
   degli operatori</link>.
  </para>
  <para>
   Il terzo gruppo è costituito dal operatore ternario: ?:. Questo si può utilizzare
   per selezionare un espressione tra due possibili, in base ad una terza; piuttosto che dovere scegliere
   tra due righe di istruzioni o diversi percorsi di esecuzione. Racchiudere l'operatore ternario
   tra parentesi tonde è una buona idea.
  </para>
  <sect1 xml:id="language.operators.precedence">
   <title>Precedenza degli operatori</title>
   <para>
    La precedenza di un operatore specifica come esso tenga legate assieme "strettamente" due
    espressioni. Per esempio, nell'espressione <literal>1 +
    5 * 3</literal>, la risposta è <literal>16</literal> e non
    <literal>18</literal> perché l'operatore di moltiplicazione ("*")
    ha una precedenza più alta rispetto all'operatore di addizione ("+").
    Le parentesi possono essere usate per forzare la precedenza, se necessario. Per
    esempio: <literal>(1 + 5) * 3</literal> viene valutata
    <literal>18</literal>. Se la precedenza tra gli operatori è simile, si utilizza l'associazione
    da sinistra a destra.
   </para>
   <para>
    La seguente tabella fornisce una lista della precedenza degli operatori con gli
    operatori a più alta precedenza elencati prima. Gli operatori presenti nella medesima linea
    hanno uguale precedenza, in questi casi la loro associativià
    decide l'ordine con cui sono valutati.
    <table>
     <title>Precedenza degli operatori</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>Associatività</entry>
        <entry>Operatori</entry>
        <entry>Informazioni aggiuntive</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>non associativi</entry>
        <entry>new</entry>
         <entry><link linkend="language.oop5.basic.new">new</link></entry>
       </row>
       <row>
        <entry>destra</entry>
        <entry>[</entry>
        <entry><function>array</function></entry>
       </row>
       <row>
        <entry>destra</entry>
        <entry>! ~ ++ -- (int) (float) (string) (array) (object) @</entry>
        <entry>
         <link linkend="language.operators.increment">incremento/decremento</link>
        </entry>
       </row>
       <row>
        <entry>destra</entry>
        <entry>! ~ + - (int) (float) (string) (array) (object) @</entry>
        <entry>
         <link linkend="language.types">tipi</link>
        </entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry>* / %</entry>
        <entry>
         <link linkend="language.operators.arithmetic">operatori aritmetici</link>
        </entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry>+ - .</entry>
        <entry>
         <link linkend="language.operators.arithmetic">operatori aritmetici</link>&listendand;
         <link linkend="language.operators.string">operatori su stringhe</link></entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry>&lt;&lt; &gt;&gt;</entry>
        <entry>
         <link linkend="language.operators.bitwise">operatori sui bit</link>
        </entry>
       </row>
       <row>
        <entry>non associativi</entry>
        <entry>&lt; &lt;= &gt; &gt;=</entry>
        <entry>
         <link linkend="language.operators.comparison">operatori di confronto</link>
        </entry>
       </row>
       <row>
        <entry>non associativi</entry>
        <entry>== != === !==</entry>
        <entry>
         <link linkend="language.operators.comparison">operatori di confronto</link>
        </entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry>&amp;</entry>
        <entry>
         <link linkend="language.operators.bitwise">operatori sui bit</link>&listendand;
         <link linkend="language.references">riferimenti</link></entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry>^</entry>
        <entry>
         <link linkend="language.operators.bitwise">operatori sui bit</link>
        </entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry>|</entry>
        <entry>
         <link linkend="language.operators.bitwise">operatori sui bit</link>
        </entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry>&amp;&amp;</entry>
        <entry>
         <link linkend="language.operators.logical">operatori logici</link>
        </entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry>||</entry>
        <entry>
         <link linkend="language.operators.logical">operatori logici</link>
        </entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry>? :</entry>
        <entry>
         <link linkend="language.operators.comparison.ternary">Operatore ternario</link>
        </entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry>
         = += -= *= /= .= %= &amp;= |= ^= ~= &lt;&lt;= &gt;&gt;=
        </entry>
        <entry>
         <link linkend="language.operators.assignment">operatori di assegnazione</link>
        </entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry>and</entry>
        <entry>
         <link linkend="language.operators.logical">operatori logici</link>
        </entry>
       </row> 
       <row>
        <entry>sinistra</entry>
        <entry>xor</entry>
        <entry>
         <link linkend="language.operators.logical">operatori logici</link>
        </entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry>or</entry>
        <entry>
         <link linkend="language.operators.logical">operatori logici</link>
        </entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry>,</entry>
        <entry>diversi usi</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </para>
   <para>
    L'associazione a sinistra indica che l'espressione viene valutata da sinistra verso destra,
    l'associazione destra indica il contrario.
    <example>
     <title>Associatività</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = 3 * 3 % 5; // (3 * 3) % 5 = 4
$a = true ? 0 : true ? 1 : 2; // (true ? 0 : true) ? 1 : 2 = 2
 
$a = 1;
$b = 2;
$a = $b += 3; // $a = ($b += 3) -> $a = 5, $b = 5
?>
]]>
     </programlisting>
    </example>
    Utilizzare le parentesi per aumentare la leggibilità del codice.
   </para>
   <note>
    <para>
     Sebbene <literal>!</literal> abbia una maggiore pecedenza rispetto a
     <literal>=</literal>, il PHP cintinua a permetter espressioni
     tipo la seguente: <literal>if (!$a = foo())</literal>,
     in questo caso l'output di <literal>foo()</literal> viene
     inserito in <varname>$a</varname>.
    </para>
   </note>
  </sect1>
  <sect1 xml:id="language.operators.arithmetic">
   <title>Operatori aritmetici</title>
   <simpara>
    Ricordate l'aritmetica di base dalla scuola? Questi funzionano proprio
    come quelli.
   </simpara>
   <table>
    <title>Operatori aritmetici</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Esempio</entry>
       <entry>Nome</entry>
       <entry>Risultato</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>-$a</entry>
       <entry>Negazione</entry>
       <entry>Opposto di $a.</entry>
      </row>
      <row>
       <entry>$a + $b</entry>
       <entry>Addizione</entry>
       <entry>La somma di $a e $b.</entry>
      </row>
      <row>
       <entry>$a - $b</entry>
       <entry>Sottrazione</entry>
       <entry>La differenza di $a e $b.</entry>
      </row>
      <row>
       <entry>$a * $b</entry>
       <entry>Moltiplicazione</entry>
       <entry>il prodotto di $a e $b.</entry>
      </row>
      <row>
       <entry>$a / $b</entry>
       <entry>Divisione</entry>
       <entry>Quoziente di $a e $b.</entry>
      </row>
      <row>
       <entry>$a % $b</entry>
       <entry>Modulo</entry>
       <entry>Il resto di $a diviso da $b.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <simpara>
    L'operatore di divisione ("/") restituisce un valore float in ogni caso,
    anche se i due operandi sono interi (oppure stringhe che
    vengono convertite in interi).
   </simpara>
   <note>
    <simpara>
     Il resto <literal>$a % $b</literal> è negativo per
     <literal>$a</literal> negativo.
    </simpara>
   </note>
   <simpara>
    Vedere anche le pagine del manuale sulle
    <link linkend="ref.math">funzioni matematiche</link>.
   </simpara>
   <!--
   <simpara>
    L'operatore di divisione ("/") restituisce un valore intero (il risultato
    di una divisione intera) se i due operandi sono interi (o
    stringhe che vengono convertite a interi) e il quoziente è un
    intero. Se uno degli operandi (o entrambi) è un valore in virgola mobile, oppure il
    risultato dell'operazione è un valore non intero, viene restituito un valore
    in virgola mobile.
   </simpara>
   -->
  </sect1>

  <sect1 xml:id="language.operators.assignment">
   <title>Operatori di assegnazione</title>
   <simpara>
    L'operatore di base dell'assegnazione è "=". La vostra prima inclinazione potrebbe
    essere di pensare che ciò sia come "uguale a". No. Esso significa realmente che
    l'operando a sinistra assume il valore dell'espressione a
    destra (ciò significa, "assegna il valore a").
   </simpara>
   <para>
    Il valore di un'espressione di assegnazione è il valore assegnato. Cioè
    il valore di "$a = 3" è 3. Questo vi permette di fare qualche
    trucchetto:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$a = ($b = 4) + 5; // $a è uguale a 9 ora, e $b è stato impostato a 4.
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    In aggiunta all'operatore di base dell'assegnazione, ci sono gli "operatori
    combinati" per tutta <link linkend="language.operators">l'aritmetica binaria</link>
    e gli operatori di stringa
    che vi consentono di usare un valore in un'espressione e poi impostare il suo
    valore al risultato di quell'espressione. Per esempio:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$a = 3;
$a += 5; // imposta $a a 8, come se avessimo detto: $a = $a + 5;
$b = "Ciao ";
$b .= "Lì!"; // imposta $b a "Ciao Lì!", proprio come $b = $b . "Lì!";
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Notare che l'assegnazione copia la variabile originale alla nuova
    (assegnazione per valore), così i cambiamenti ad una non si verificheranno nell'
    altra. Ciò può anche avere rilevanza se avete bisogno di copiare qualcosa
    come un grande array in un ciclo molto stretto. Dal PHP 4 viene supportato l'assegnazione
    per riferimento, usando la sintassi <computeroutput>$var =
    &amp;$othervar;</computeroutput>, ma ciò non è possibile
    in PHP 3. 'L'assegnazione per riferimento' vuol dire che entrambe le variabili
    finiscono con il puntare agli stessi dati, e nulla è copiato in nessun posto.
    Per ulteriori approfondimenti sui riferimenti, consultare <link
    linkend="language.references">References explained</link>.
   </para>
  </sect1>

  <sect1 xml:id="language.operators.bitwise">
   <title>Operatori bitwise</title>
   <simpara>
    Gli operatori bitwise vi permettono di alterare bit specifici
    in posizione on oppure off. Se entrambi i parametri di sinistra e destra sono
    stringhe, l'operatore bitwise opererà sui caratteri ASCII
    della stringa.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
echo 12 ^ 9; // L'output è '5'
echo "12" ^ "9"; // L'output è il carattere Backspace (ascii 8)
                     // ('1' (ascii 49)) ^ ('9' (ascii 57)) = #8
echo "hallo" ^ "hello"; // L'output è il valore ascii #0 #4 #0 #0 #0
                            // 'a' ^ 'e' = #4
?>
]]>
     </programlisting>
    </informalexample>
   </para>

   <table>
    <title>Operatori bitwise</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Esempio</entry>
       <entry>Nome</entry>
       <entry>Risultato</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a &amp; $b</entry>
       <entry>And</entry>
       <entry>Sono impostati ad ON i bit che sono ON sia in $a che in $b.</entry>
      </row>
      <row>
       <entry>$a | $b</entry>
       <entry>Or</entry>
       <entry>Sono impostati ad ON i bit che sono ON in $a oppure in $b.</entry>
      </row>
      <row>
       <entry>$a ^ $b</entry>
       <entry>Xor</entry>
       <entry>
	Sono impostati ad ON i bit che sono ON in $a oppure in $b na non quelli che sono entrambi ON.
       </entry>
      </row>
      <row>
       <entry>~ $a</entry>
       <entry>Not</entry>
       <entry>
	Sono impostati ad ON i bit che sono OFF in $a, e viceversa.
       </entry>
      </row>
      <row>
       <entry>$a &lt;&lt; $b</entry>
       <entry>Shift left</entry>
       <entry>
	Sposta i bit di $a a sinistra di $b passi (ogni passo significa
	"moltiplica per due")
       </entry>
      </row>
      <row>
       <entry>$a &gt;&gt; $b</entry>
       <entry>Shift right</entry>
       <entry>
	Sposta i bit di $a a destra di $b passi (ogni passo significa
	"dividi per due")
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <warning>
    <para>
     Non spostare a destra per più di 32 bit sui sistemi a 32 bit. Non spostare
     a sinistra nei casi in cui il risultato è un numero più lungo di 32 bit.
    </para>
   </warning>
  </sect1>

  <sect1 xml:id="language.operators.comparison">
   <title>Operatori di confronto</title>
   <simpara>
    Gli operatori di confronto, come suggerisce il loro nome, permettono di confrontare
    due valori. Può essere interessante vedere la 
    <link linkend="types.comparisons">tabella di raffronto dei tipi</link>,
    dato che mostra esempi di vari confronti tra i tipi di variabili.
   </simpara>
   <table>
    <title>Operatori di confronto</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Esempio</entry>
       <entry>Nome</entry>
       <entry>Risultato</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a == $b</entry>
       <entry>Uguale</entry>
       <entry>&true; se $a è uguale a $b.</entry>
      </row>
      <row>
       <entry>$a === $b</entry>
       <entry>Identico</entry>
       <entry>
	&true; se $a è uguale a $b, ed essi sono dello stesso
	tipo. (Dal PHP 4)
       </entry>
      </row>
      <row>
       <entry>$a != $b</entry>
       <entry>Diversi</entry>
       <entry>&true; se $a è diverso da $b.</entry>
      </row>
      <row>
       <entry>$a &lt;&gt; $b</entry>
       <entry>Diversi</entry>
       <entry>&true; se $a è diverso da $b.</entry>
      </row>
      <row>
       <entry>$a !== $b</entry>
       <entry>Non identici</entry>
       <entry>
	&true; se $a è diverso da $b, o se essi non sono dello stesso
	tipo. (Dal PHP 4)
       </entry>
      </row>
      <row>
       <entry>$a &lt; $b</entry>
       <entry>Minore</entry>
       <entry>&true; se $a è strettamente minore di $b.</entry>
      </row>
      <row>
       <entry>$a &gt; $b</entry>
       <entry>Maggiore</entry>
       <entry>&true; se $a è strettamente maggiore di $b.</entry>
      </row>
      <row>
       <entry>$a &lt;= $b</entry>
       <entry>Minore o uguale</entry>
       <entry>&true; se $a è minore o uguale a $b.</entry>
      </row>
      <row>
       <entry>$a &gt;= $b</entry>
       <entry>Maggiore o uguale</entry>
       <entry>&true; se $a è maggiore o uguale a $b.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    Se si confronta interi con stringhe, la stringa viene
    <link linkend="language.types.string.conversion">convertita in numero</link>.
    Se si confronta due stringhe numeriche, queste vengono confrontate come interi. Queste 
    regole valgono anche per l'istruzione
    <link linkend="control-structures.switch">switch</link>.    
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
var_dump(0 == "a"); // 0 == 0 -> true
var_dump("1" == "01"); // 1 == 1 -> true

switch ("a") {
case 0:
    echo "0";
    break;
case "a": // mai raggiunta perchè "a" è già riconosciuta come 0
    echo "a";
    break;
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Se i tipi di operarandi utilizzati differiscono, il confronto viene svolto
    nell'ordine indicato della seguente tabella.
   </para>
   <table>
    <title>Confronti con differenti tipi</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Tipo dell'operando 1</entry>
       <entry>Tipo dell'operando 2</entry>
       <entry>Risultato</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><type>null</type> oppure <type>string</type></entry>
       <entry><type>string</type></entry>
       <entry>Si converte &null; in "", confronto numerico o lessicale</entry>
      </row>
      <row>
       <entry><type>bool</type> oppure <type>null</type></entry>
       <entry>qualsiasi</entry>
       <entry>Convertito in <type>bool</type>, &false; &lt; &true;</entry>
      </row>
      <row>
       <entry><type>object</type></entry>
       <entry><type>object</type></entry>
       <entry>Le classi predefinite possono avere la propria funzione di confronto, differenti classi
        non sono confrontabili, classi uguali - hanno le medesime proprietà di confronto delle
        matrici (PHP 4), pre il PHP 5 vedere <link
        linkend="language.oop5.object-comparison">qui</link> per maggiori spiegazioni.
       </entry>
      </row>
      <row>
       <entry><type>string</type>, <type>resource</type> oppure <type>number</type></entry>
       <entry><type>string</type>, <type>resource</type> oppure <type>number</type></entry>
       <entry>Stringhe e risorse sono converti in numeri, confronto matematico</entry>
      </row>
      <row>
       <entry><type>array</type></entry>
       <entry><type>array</type></entry>
       <entry>La matrice con meno membri è più piccola, se la chiave dell'operando 1 non si
        trova nell'operando 2 allora le matrici non si possono confrontare, in altri casi
        il confronto avviene valore per valore (vedere l'esempio seguente)</entry>
      </row>
      <row>
       <entry><type>array</type></entry>
       <entry>qualsiasi</entry>
       <entry><type>array</type> è sempre più grande</entry>
      </row>
      <row>
       <entry><type>object</type></entry>
       <entry>qualsiasi</entry>
       <entry><type>object</type> è sempre più grande</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    <example>
     <title>Trascrizione del confronto standard tra matrici</title>
     <programlisting role="php">
<![CDATA[
<?php
// Le matrici vengono confrontate come illustrato in questa funzione
function standard_array_compare($op1, $op2)
{
    if (count($op1) < count($op2)) {
        return -1; // $op1 < $op2
    } elseif (count($op1) > count($op2)) {
        return 1; // $op1 > $op2
    }
    foreach ($op1 as $key => $val) {
        if (!array_key_exists($key, $op2)) {
            return null; // uncomparable
        } elseif ($val < $op2[$key]) {
            return -1;
        } elseif ($val > $op2[$key]) {
            return 1;
        }
    }
    return 0; // $op1 == $op2
}
?>
]]>
     </programlisting>
    </example>
   </para>
 
   <para>
    Vedere anche <function>strcasecmp</function>,
    <function>strcmp</function>,
    <link linkend="language.operators.array">Array operators</link>,
    e la sezione del manuale su
    <link linkend="language.types">Types</link>.
   </para>
 
   <sect2 xml:id="language.operators.comparison.ternary">
    <title>Operatore ternario</title>
    <para>
     Un'altro operatore condizionale è l'operatore ternario "?:".
     <example>
      <title>Assegnazione di un valore di default</title>
      <programlisting role="php">
<![CDATA[
<?php
// Esempio di utilizzo dell'operatore ternario
$action = (empty($_POST['action'])) ? 'default' : $_POST['action'];

// La riga precedente è simile a
if (empty($_POST['action'])) {
    $action = 'default';
} else {
    $action = $_POST['action'];
}

?>
]]>
      </programlisting>
     </example>
     L'espressione <literal>(espressione1) ? (espressione2) : (espressione3)</literal>
     vale <replaceable>espressione2</replaceable> se
     <replaceable>espressione1</replaceable> è &true;, e
     <replaceable>espressione3</replaceable> se
     <replaceable>espressione1</replaceable> è &false;.     
    </para>
    <note>
     <simpara>
      Si noti che l'operatore ternario è un'istruzione, e non viene valutato
      come variabile, ma come risultato di un'istruzione. Questo
      è importante da sapere nel caso si desideri restituire una variabile per riferimento.
      La riga <literal>return $var == 42 ? $a : $b;</literal> in una funzione
      che restituisce per riferimento non funzionerà e, nelle ultime versioni di PHP,
      genererà un warning.
     </simpara>
    </note>
   </sect2>
  </sect1>

  <sect1 xml:id="language.operators.errorcontrol">
   <title>Operatori di controllo errori</title>
   <simpara>
    PHP supporta un operatore di controllo dell'errore: il carattere at (@). Quando
    prefisso ad una espressione in PHP, qualunque messaggio di errore che potesse
    essere generato da quella espressione sarà ignorato.
   </simpara>
   <simpara>
    Se la caratteristica <link linkend="ini.track-errors"><option>track_errors</option></link>
    è abilitata, qualsiasi messaggio di errore generato dall'espressione
    sarà salvato nella variabile globale 
    <link linkend="reserved.variables.phperrormsg">$php_errormsg</link>. Questa variabile
    sarà sovrascritta ad ogni errore, così controllatela subito se volete
    usarla.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
/* Errore di file intenzionale */
$my_file = @file ('file_inesistente') or
    die ("Apertura del file fallita: l'errore è '$php_errormsg'");

// questo funziona per qualsiasi espressione, non solo funzioni:
$value = @$cache[$key];
// non verrà generata una notifica se l'indice $key non esiste.

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <note>
    <simpara>
     L'operatore @ funziona solo sulle 
     <link linkend="language.expressions">espressioni</link>. Una semplice regola 
     è: se potete prendere il valore di qualcosa, potete anteporre ad esso
     l'operatore @. Per esempio, potete anteporre esso a variabili,
     funzioni e chiamate ad <function>include</function>, costanti, e
     così via. non potete anteporre esso a definizioni di funzioni o classi,
     o strutture condizionali come <literal>if</literal> e
     <literal>foreach</literal>, e così via.
    </simpara>
   </note>
   <simpara>
    Vedere anche <function>error_reporting</function> e la sezione del manuale
    <link linkend="ref.errorfunc">Gestione degli errori e funzioni di log</link>.
   </simpara>
   <warning>
    <para>
     Attualmente il prefisso operatore di controllo dell'errore "@" disabiliterà
     la restituzione di errori per errori critici che interromperanno l'esecuzione
     dello script. Tra le altre cose, questo significa che se state usando "@"
     per sopprimere errori da una certa funzione ed essa non è disponibile
     oppure è stata scritta male, lo script terminerà
     senza dare indicazioni sul perché.
    </para>
   </warning>
  </sect1>

  <sect1 xml:id="language.operators.execution">
   <title>Operatori di esecuzione</title>
   <para>
    PHP supporta un operatore di esecuzione: backticks (``). Notare che
    quelli non sono apostrofi! PHP cercherà di eseguire
    il contenuto dei backticks come comando di shell; sarà restituito l'output
    (i.e., non sarà semplicemente esportato come output; può
    essere assegnato ad una variabile). L'uso dell'operatore backtick è identico
    alla funzione <function>shell_exec</function>.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$output = `ls -al`;
echo "<pre>$output</pre>";
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <note>
    <para>
     L'operatore backtick è disabilitato quando è abilitata &safemode;
     oppure quando è disabilitata <function>shell_exec</function>.
    </para>
   </note>
   <para>
    Vedere anche la sezione del manuale  <link linkend="ref.exec">Funzioni 
    per l'esecuzione di programmi</link>, <function>popen</function>,
    <function>proc_open</function> e 
    <link linkend="features.commandline">Utilizzo del PHP da
    linea di comando</link>.
   </para>
  </sect1>

  <sect1 xml:id="language.operators.increment">
   <title>Operatori di incremento/decremento</title>
   <para>
    PHP supporta lo stile C degli operatori di pre- e post-incremento
    e decremento.
   </para>
   <note>
    <simpara>
     Gli operatori di incremento e decremento non agiscono sui valori boolean.
     Anche decrementare il valore &null; non ha effetti, ma incrementarlo
     darà come risultato <literal>1</literal>.
    </simpara>
   </note>
   <table>
    <title>Operatori di incremento/decremento</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Esempio</entry>
       <entry>Nome</entry>
       <entry>Effetto</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>++$a</entry>
       <entry>Pre-incremento</entry>
       <entry>Incrementa $a di una unità, inoltre restituisce $a.</entry>
      </row>
      <row>
       <entry>$a++</entry>
       <entry>Post-incremento</entry>
       <entry>Restituisce $a, inoltre incrementa $a di una unità.</entry>
      </row>
      <row>
       <entry>--$a</entry>
       <entry>Pre-decremento</entry>
       <entry>Decrementa $a di una unità, inoltre restituisce $a.</entry>
      </row>
      <row>
       <entry>$a--</entry>
       <entry>Post-decremento</entry>
       <entry>Restituisce $a, inoltre decrementa $a di una unità.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    Qui c'è un semplice script di esempio:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
echo "<h3>Postincrement</h3>";
$a = 5;
echo "Dovrebbe essere 5: " . $a++ . "<br />\n";
echo "Dovrebbe essere 6: " . $a . "<br />\n";

echo "<h3>Pre-incremento</h3>";
$a = 5;
echo "Dovrebbe essere 6: " . ++$a . "<br />\n";
echo "Dovrebbe essere 6: " . $a . "<br />\n";

echo "<h3>Post-decremento</h3>";
$a = 5;
echo "Dovrebbe essere 5: " . $a-- . "<br />\n";
echo "Dovrebbe essere 4: " . $a . "<br />\n";

echo "<h3>Pre-decremento</h3>";
$a = 5;
echo "Dovrebbe essere 4: " . --$a . "<br />\n";
echo "Dovrebbe essere 4: " . $a . "<br />\n";
?>
]]>
     </programlisting>
    </informalexample>
   </para> 
   <para>
    Il PHP segue le convenzioni di Perl e non del C quando tratta le operazioni matematiche
    sui caratteri. Ad esempio, in Perl 'Z'+1 restituisce
    'AA', mentre in C 'Z'+1 restituisce '[' ( ord('Z') == 90, ord('[') == 91 ).
    Attenzione che le variabili con caratteri possono essere sommate e non sottratte.
    <example>
     <title>Operazioni aritmetiche su variabili stringa</title>
     <programlisting role="php">
<![CDATA[
<?php
$i = 'W';
for ($n=0; $n<6; $n++)
    echo ++$i . "\n";
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
X
Y
Z
AA
AB
AC
]]>
     </screen>
    </example>
   </para>
   <para>
    Incrementare o decrementare valori booleani non ha effetto.
   </para>
  </sect1>
  <sect1 xml:id="language.operators.logical">
   <title>Operatori logici</title>

   <table>
    <title>Operatori logici</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Esempio</entry>
       <entry>Nome</entry>
       <entry>Risultato</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a and $b</entry>
       <entry>And</entry>
       <entry>&true; se entrambi $a e $b sono &true;.</entry>
      </row>
      <row>
       <entry>$a or $b</entry>
       <entry>Or</entry>
       <entry>&true; se uno tra $a o $b è &true;.</entry>
      </row>
      <row>
       <entry>$a xor $b</entry>
       <entry>Xor</entry>
       <entry>&true; se uno tra $a o $b è &true;, ma non entrambi.</entry>
      </row>
      <row>
       <entry>! $a</entry>
       <entry>Not</entry>
       <entry>&true; se $a non è &true;.</entry>
      </row>
      <row>
       <entry>$a &amp;&amp; $b</entry>
       <entry>And</entry>
       <entry>&true; se entrambi $a e $b sono &true;.</entry>
      </row>
      <row>
       <entry>$a || $b</entry>
       <entry>Or</entry>
       <entry>&true; se uno tra $a o $b è &true;.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <simpara>
    La ragione per le due differenti variazioni degli operatori "and" e "or"
    è che essi operano con differenti precedenze. (Vedere
    <link linkend="language.operators.precedence">Precedenza degli
    operatori</link>.)
   </simpara>
  </sect1>

  <sect1 xml:id="language.operators.string">
   <title>Operatori di stringa</title>
   <simpara>
    Ci sono due operatori di <type>stringa</type>. Il primo è l'operatore di
    concatenazione ('.'), che restituisce la concatenazione dei suoi argomenti di destra e
    di sinistra. Il secondo è l'operatore di
    assegnazione concatenata ('.='), che accoda l'argomento sul lato destro all'argomento sul lato
    sinistro. Per favore consultare <link
    linkend="language.operators.assignment">Operatori di
    assegnazione</link> per maggiori informazioni.
   </simpara>

   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$a = "Ciao ";
$b = $a . "Mondo!"; // ora $b contiene "Ciao Mondo!"

$a = "Ciao ";
$a .= "Mondo!";     // ora $a contiene "Ciao Mondo!"
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Vedere anche le sezioni 
    <link linkend="language.types.string">Stringhe</link> e
    <link linkend="ref.strings">Funzioni per le stringhe</link> nel manuale.
   </para>
  </sect1>
  	 
  <sect1 xml:id="language.operators.array">
   <title>Operatori per matrici</title>
   <table>
    <title>Operatori per matrici</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Esempio</entry>
       <entry>Nome</entry>
       <entry>Risultato</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a + $b</entry>
       <entry>Unione</entry>
       <entry>Unione di $a e $b.</entry>
      </row>
      <row>
       <entry>$a == $b</entry>
       <entry>Uguaglianza</entry>
       <entry>&true; se $a e $b hanno le stesse coppie di chiavi/valori.</entry>
      </row>
      <row>
       <entry>$a === $b</entry>
       <entry>Identità</entry>
       <entry>&true; se $a e $b hanno le stesse coppie di chiavi/valori nel
        medesimo ordine e dl medesimo tipo.</entry>
      </row>
      <row>
       <entry>$a != $b</entry>
       <entry>Disuguaglianza</entry>
       <entry>&true; se $a non è uguale a $b.</entry>
      </row>
      <row>
       <entry>$a &lt;&gt; $b</entry>
       <entry>Disuguaglianza</entry>
       <entry>&true; se $a non è uguale a $b.</entry>
      </row>
      <row>
       <entry>$a !== $b</entry>
       <entry>Non-identità</entry>
       <entry>&true; se $a non è identico a $b.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    L'operatore <literal>+</literal> 
    aggiunge la matrice di destra a quella di sinistra, mentre le
    chiavi duplicate NON sono sovrascritte.
   </para>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$a = array("a" => "apple", "b" => "banana");
$b = array("a" => "pear", "b" => "strawberry", "c" => "cherry");
 
$c = $a + $b; // Unione di $a e $b
echo "Union of \$a and \$b: \n";
var_dump($c);
 
$c = $b + $a; // Unione di $b e $a
echo "Union of \$b and \$a: \n";
var_dump($c);
?>
]]>
     </programlisting>
    </informalexample>
    Una volta eseguito, lo script visualizzerà:
    <screen role="php">
<![CDATA[
Union of $a and $b:
array(3) {
  ["a"]=>
  string(5) "apple"
  ["b"]=>
  string(6) "banana"
  ["c"]=>
  string(6) "cherry"
}
Union of $b and $a:
array(3) {
  ["a"]=>
  string(4) "pear"
  ["b"]=>
  string(10) "strawberry"
  ["c"]=>
  string(6) "cherry"
}
]]>
    </screen>
   </para>
   <para>
    Gli elementi di una matrice sono uguali nel confronto se hanno le
    stesse chiavi e gli stessi valori.
   </para>
   <para>
    <example>
     <title>Confrontare le matrici</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = array("apple", "banana");
$b = array(1 => "banana", "0" => "apple");
 
var_dump($a == $b); // bool(true)
var_dump($a === $b); // bool(false)
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Vedere anche la sezione del manuale sulle
    <link linkend="language.types.array">Matrici</link> e
    <link linkend="ref.array">Funzioni per le matrici</link>.
   </para>
  </sect1>
  <sect1 xml:id="language.operators.type">
   <title>Operatori di tipi</title>
   <para>
    PHP ha un unico operatore di tipo: <literal>instanceof</literal>.
    <literal>instanceof</literal> è utilizzato per determinare se un dato 
    oggetto appartiene ad una data <link linkend="language.oop">classe di oggetti</link>.
   </para>
   <simpara>
    L'operatore <literal>instanceof</literal> è stato introdotto in PHP 5.
    Prima di questo si utilizzava <function>is_a</function>, ma ora
    <function>is_a</function> viene sconsigliato in favore di
    <literal>instanceof</literal>.
   </simpara>
   <informalexample>
    <programlisting>
<![CDATA[
<?php
class A { }
class B { }
 
$thing = new A;
if ($thing instanceof A) {
    echo 'A';
}
if ($thing instanceof B) {
    echo 'B';
}
?>
]]>
    </programlisting>
    <simpara>
     Poichè <varname>$thing</varname> è un <type>oggetto</type> di tipo A, ma
     non di tipo B, sarà eseguito soltanto il blocco dipendente dal tipo A:
    </simpara>
    <screen>A</screen>
   </informalexample>
   <para>
    Vedere anche <function>get_class</function> e
    <function>is_a</function>.
   </para>
  </sect1>
 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
