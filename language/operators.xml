<?xml version="1.0" encoding="iso-8859-1"?>
<!-- EN-Revision: 1.31 Maintainer: spisto  Status: working -->
 <chapter id="language.operators">
  <title>Operatori</title>
  <simpara>
  </simpara>

  <sect1 id="language.operators.arithmetic">
   <title>Operatori aritmetici</title>
   <simpara>
    Ricordate l'aritmetica di base dalla scuola? Questi funzionano proprio
    come quelli.
   </simpara>
   <table>
    <title>Operatori aritmetici</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Esempio</entry>
       <entry>Nome</entry>
       <entry>Risultato</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a + $b</entry>
       <entry>Addizione</entry>
       <entry>La somma di $a e $b.</entry>
      </row>
      <row>
       <entry>$a - $b</entry>
       <entry>Sottrazione</entry>
       <entry>La differenza di $a e $b.</entry>
      </row>
      <row>
       <entry>$a * $b</entry>
       <entry>Moltiplicazione</entry>
       <entry>il prodotto di $a e $b.</entry>
      </row>
      <row>
       <entry>$a / $b</entry>
       <entry>Divisione</entry>
       <entry>Quoziente di $a e $b.</entry>
      </row>
      <row>
       <entry>$a % $b</entry>
       <entry>Modulo</entry>
       <entry>Il resto di $a diviso da $b.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <simpara>
    L'operatore di divisione ("/") restituisce un valore intero (il risultato
    di una divisione intera) se i due operandi sono interi (o
    stringhe che vengono convertite a interi) e il quoziente è un
    intero. Se uno degli operandi (o entrambi) è un valore in virgola mobile, oppure il
    risultato dell'operazione è un valore non intero, viene restituito un valore
    in virgola mobile.
   </simpara>
  </sect1>

  <sect1 id="language.operators.assignment">
   <title>Operatori di assegnazione</title>
   <simpara>
    L'operatore di base dell'assegnazione è "=". La vostra prima inclinazione potrebbe
    essere di pensare che ciò sia come "uguale a". No. Esso significa realmente che
    l'operando a sinistra assume il valore dell'espressione a
    destra (ciò significa, "assegna il valore a").
   </simpara>
   <para>
    Il valore di un'espressione di assegnazione è il valore assegnato. Cioè
    il valore di "$a = 3" è 3. Questo vi permette di fare qualche
    trucchetto:
    <informalexample>
     <programlisting role="php">
<![CDATA[
$a = ($b = 4) + 5; // $a è uguale a 9 ora, e $b è stato impostato a 4.
]]>
     </programlisting>
    </informalexample>
   </para>
   <para> 
    In aggiunta all'operatore di base dell'assegnazione, ci sono gli "operatori
    combinati" per tutta l'aritmetica binaria e gli operatori di stringa
    che vi consentono di usare un valore in un'espressione e poi impostare il suo
    valore al risultato di quell'espressione. Per esempio:
    <informalexample>
     <programlisting role="php">
<![CDATA[
$a = 3;
$a += 5; // imposta $a a 8, come se avessimo detto: $a = $a + 5;
$b = "Ciao ";
$b .= "Lì!"; // imposta $b a "Ciao Lì!", proprio come $b = $b . "Lì!";
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Notare che l'assegnazione copia la variabile originale alla nuova
    (assegnazione per valore), così i cambiamenti ad una non si verificheranno nell'
    altra. Ciò può anche avere rilevanza se avete bisogno di copiare qualcosa
    come un grande array in un ciclo molto stretto. PHP 4 supporta l'assegnazione
    per riferimento, usando la sintassi <computeroutput>$var =
    &amp;$othervar;</computeroutput>, ma ciò non è possibile
    in PHP 3. 'L'assegnazione per riferimento' vuol dire che entrambe le variabili
    finiscono con il puntare agli stessi dati, e nulla è copiato in nessun posto.
    Per ulteriori approfondimenti sui riferimenti, consultare <link
    linkend="language.references">References explained</link>.
   </para>
  </sect1>

  <sect1 id="language.operators.bitwise">
   <title>Operatori bitwise</title>
   <simpara>
    Gli operatori bitwise vi permettono di alterare bit specifici
    in posizione on oppure off.
   </simpara>
   <table>
    <title>Operatori bitwise</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Esempio</entry>
       <entry>Nome</entry>
       <entry>Risultato</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a &amp; $b</entry>
       <entry>And</entry>
       <entry>Sono impostati ad ON i bit che sono ON sia in $a che in $b.</entry>
      </row>
      <row>
       <entry>$a | $b</entry>
       <entry>Or</entry>
       <entry>Sono impostati ad ON i bit che sono ON in $a oppure in $b.</entry>
      </row>
      <row>
       <entry>$a ^ $b</entry>
       <entry>Xor</entry>
       <entry>
	Sono impostati ad ON i bit che sono ON in $a oppure in $b na non quelli che sono entrambi ON.
       </entry>
      </row>
      <row>
       <entry>~ $a</entry>
       <entry>Not</entry>
       <entry>
	Sono impostati ad ON i bit che sono OFF in $a, e viceversa.
       </entry>
      </row>
      <row>
       <entry>$a &lt;&lt; $b</entry>
       <entry>Shift left</entry>
       <entry>
	Sposta i bit di $a a sinistra di $b passi (ogni passo significa
	"moltiplica per due")
       </entry>
      </row>
      <row>
       <entry>$a &gt;&gt; $b</entry>
       <entry>Shift right</entry>
       <entry>
	Sposta i bit di $a a destra di $b passi (ogni passo significa
	"dividi per due")
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </sect1>

  <sect1 id="language.operators.comparison">
   <title>Operatori di confronto</title>
   <simpara>
    Gli operatori di confronto, come suggerisce il loro nome, permettono di confrontare
    due valori.
   </simpara>
   <table>
    <title>Operatori di confronto</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Esempio</entry>
       <entry>Nome</entry>
       <entry>Risultato</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a == $b</entry>
       <entry>Uguale</entry>
       <entry>&true; se $a è uguale a $b.</entry>
      </row>
      <row>
       <entry>$a === $b</entry>
       <entry>Identico</entry>
       <entry>
	&true; se $a è uguale a $b, ed essi sono dello stesso
	tipo. (Solo PHP 4)
       </entry>
      </row>
      <row>
       <entry>$a != $b</entry>
       <entry>Diversi</entry>
       <entry>&true; se $a è diverso da $b.</entry>
      </row>
      <row>
       <entry>$a &lt;> $b</entry>
       <entry>Diversi</entry>
       <entry>&true; se $a è diverso da $b.</entry>
      </row>
      <row>
       <entry>$a !== $b</entry>
       <entry>Non identici</entry>
       <entry>
	&true; se $a è diverso da $b, o se essi non sono dello stesso
	tipo. (Solo PHP 4)
       </entry>
      </row>
      <row>
       <entry>$a &lt; $b</entry>
       <entry>Minore</entry>
       <entry>&true; se $a è strettamente minore di $b.</entry>
      </row>
      <row>
       <entry>$a &gt; $b</entry>
       <entry>Maggiore</entry>
       <entry>&true; se $a è strettamente maggiore di $b.</entry>
      </row>
      <row>
       <entry>$a &lt;= $b</entry>
       <entry>Minore o uguale</entry>
       <entry>&true; se $a è minore o uguale a $b.</entry>
      </row>
      <row>
       <entry>$a &gt;= $b</entry>
       <entry>Maggiore o uguale</entry>
       <entry>&true; se $a è maggiore o uguale a $b.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    Un altro operatore condizionale è l'operatore "?:" (o trinario),
    che opera come in C e molti altri linguaggi.
    <informalexample>
     <programlisting>
<![CDATA[
(espressione1) ? (espressione2) : (espressione3);
]]>
     </programlisting>
    </informalexample>
    Questa espressione vale <replaceable>espressione2</replaceable> se
    <replaceable>espressione1</replaceable> è &true;, e
    <replaceable>espressione3</replaceable> se
    <replaceable>espressione1</replaceable> è &false;.
   </para>
  </sect1>

  <sect1 id="language.operators.errorcontrol">
   <title>Operatori di controllo errori</title>
   <simpara>
    PHP supporta un operatore di controllo dell'errore: il carattere at (@). Quando
    prefisso ad una espressione in PHP, qualunque messaggio di errore che potesse
    essere generato da quella espressione sarà ignorato.
   </simpara>
   <simpara>
    Se la caratteristica <link linkend="ini.track-errors">track_errors</link>
    è abilitata, qualsiasi messaggio di errore generato dall'espressione
    sarà salvato nella variabile globale $php_errormsg. Questa variabile
    sarà sovrascritta ad ogni errore, così controllatela subito se volete
    usarla.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
/* Errore di file intenzionale */
$my_file = @file ('file_inesistente') or
    die ("Apertura del file fallita: l'errore è '$php_errormsg'");

// questo funziona per qualsiasi espressione, non solo funzioni:
$value = @$cache[$key];
// non verrà generata una notifica se l'indice $key non esiste.

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <note>
    <simpara>
     L'operatore @ funziona solo sulle espressioni. Una semplice regola di thumb
     è: se potete prendere il valore di qualcosa, potete anteporre ad esso
     l'operatore @. Per esempio, potete anteporre esso a variabili,
     funzioni e chiamate ad <function>include</function>, costanti, e
     così via. non potete anteporre esso a definizioni di funzioni o classi,
     o strutture condizionali come <literal>if</literal> e
     <literal>foreach</literal>, e così via.
    </simpara>
   </note>
   <simpara>
    Vedere anche <function>error_reporting</function>.
   </simpara>
   <warning>
    <para>
     Attualmente il prefisso operatore di controllo dell'errore "@" disabiliterà
     la restituzione di errori per errori critici che interromperanno l'esecuzione
     dello script. Tra le altre cose, questo significa che se state usando "@"
     per sopprimere errori da una certa funzione ed essa non è disponibile
     oppure è stata scritta male, lo script terminerà
     senza dare indicazioni sul perché.
    </para>
   </warning>
  </sect1>

  <sect1 id="language.operators.execution">
   <title>Operatori di esecuzione</title>
   <para>
    PHP supporta un operatore di esecuzione: backticks (``). Notare che
    quelli non sono apostrofi! PHP cercherà di eseguire
    il contenuto dei backticks come comando di shell; sarà restituito l'output
    (i.e., non sarà semplicemente esportato come output; può
    essere assegnato ad una variabile).
    <informalexample>
     <programlisting role="php">
<![CDATA[
$output = `ls -al`;
echo "<pre>$output</pre>";
]]>
     </programlisting>
    </informalexample>
   </para>
   <note>
    <para>
     L'operatore backtick è disabilitato quando è abilitata <link
     linkend="ini.safe-mode">safe mode</link>
     oppure quando è disabilitata <function>shell_exec</function>.
    </para>
   </note>
   <para>
    Vedere anche <function>escapeshellcmd</function>, <function>exec</function>,
    <function>passthru</function>, <function>popen</function>,
    <function>shell_exec</function> e <function>system</function>.
   </para>
  </sect1>

  <sect1 id="language.operators.increment">
   <title>Operatori di incremento/decremento</title>
   <para>
    PHP supporta lo stile C degli operatori di pre- e post-incremento
    e decremento.
   </para>
   <table>
    <title>Operatori di incremento/decremento</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Esempio</entry>
       <entry>Nome</entry>
       <entry>Effetto</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>++$a</entry>
       <entry>Pre-incremento</entry>
       <entry>Incrementa $a di una unità, inoltre restituisce $a.</entry>
      </row>
      <row>
       <entry>$a++</entry>
       <entry>Post-incremento</entry>
       <entry>Restituisce $a, inoltre incrementa $a di una unità.</entry>
      </row>
      <row>
       <entry>--$a</entry>
       <entry>Pre-decremento</entry>
       <entry>Decrementa $a di una unità, inoltre restituisce $a.</entry>
      </row>
      <row>
       <entry>$a--</entry>
       <entry>Post-decremento</entry>
       <entry>Restituisce $a, inoltre decrementa $a di una unità.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    Qui c'è un semplice script di esempio:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
echo "<h3&gt;Post-incremento</h3&gt;";
$a = 5;
echo "Dovrebbe essere 5: " . $a++ . "<br>\n";
echo "Dovrebbe essere 6: " . $a . "<br>\n";

echo "<h3>Pre-incremento</h3>";
$a = 5;
echo "Dovrebbe essere 6: " . ++$a . "<br>\n";
echo "Dovrebbe essere 6: " . $a . "<br>\n";

echo "<h3>Post-decremento</h3>";
$a = 5;
echo "Dovrebbe essere 5: " . $a-- . "<br>\n";
echo "Dovrebbe essere 4: " . $a . "<br>\n";

echo "<h3>Pre-decremento</h3>";
$a = 5;
echo "Dovrebbe essere 4: " . --$a . "<br>\n";
echo "Dovrebbe essere 4: " . $a . "<br>\n";
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 id="language.operators.logical">
   <title>Operatori logici</title>

   <table>
    <title>Operatori logici</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Esempio</entry>
       <entry>Nome</entry>
       <entry>Risultato</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a and $b</entry>
       <entry>And</entry>
       <entry>&true; se entrambi $a e $b sono &true;.</entry>
      </row>
      <row>
       <entry>$a or $b</entry>
       <entry>Or</entry>
       <entry>&true; se uno tra $a o $b è &true;.</entry>
      </row>
      <row>
       <entry>$a xor $b</entry>
       <entry>Xor</entry>
       <entry>&true; se uno tra $a o $b è &true;, ma non entrambi.</entry>
      </row>
      <row>
       <entry>! $a</entry>
       <entry>Not</entry>
       <entry>&true; se $a non è &true;.</entry>
      </row>
      <row>
       <entry>$a &amp;&amp; $b</entry>
       <entry>And</entry>
       <entry>&true; se entrambi $a e $b sono &true;.</entry>
      </row>
      <row>
       <entry>$a || $b</entry>
       <entry>Or</entry>
       <entry>&true; se uno tra $a o $b è &true;.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <simpara>
    La ragione per le due differenti variazioni degli operatori "and" e "or"
    è che essi operano con differenti precedenze. (Vedere
    <link linkend="language.operators.precedence">Precedenza degli
    operatori</link>.)
   </simpara>
  </sect1>

  <sect1 id="language.operators.precedence">
   <title>Precedenza degli operatori</title>
   <para>
    La precedenza di un operatore specifica come esso tenga legate assieme "strettamente" due
    espressioni. Per esempio, nell'espressione <literal>1 +
    5 * 3</literal>, la risposta è <literal>16</literal> e non
    <literal>18</literal> perché l'operatore di moltiplicazione ("*")
    ha una precedenza più alta rispetto all'operatore di addizione ("+").
    Le parentesi possono essere usate per forzare la precedenza, se necessario. Per 
    esempio: <literal>(1 + 5) * 3</literal> viene valutata
    <literal>18</literal>.
   </para>
   <para>
    La seguente tabella fornisce una lista della precedenza degli operatori con gli
    operatori a più bassa precedenza listati prima.
    <table>
     <title>Precedenza degli operatori</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>Associatività</entry>
        <entry>Operatori</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>sinistra</entry>
        <entry>,</entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry>or</entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry>xor</entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry>and</entry>
       </row>
       <row>
        <entry>destra</entry>
        <entry>print</entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry>
         = += -= *= /= .= %= &amp;= |= ^= ~= &lt;&lt;= &gt;&gt;=
        </entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry>? :</entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry>||</entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry>&amp;&amp;</entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry>|</entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry>^</entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry>&amp;</entry>
       </row>
       <row>
        <entry>non associativi</entry>
        <entry>== != === !==</entry>
       </row>
       <row>
        <entry>non associativi</entry>
        <entry>&lt; &lt;= &gt; &gt;=</entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry>&lt;&lt; &gt;&gt;</entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry>+ - .</entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry>* / %</entry>
       </row>
       <row>
        <entry>destra</entry>
        <entry>! ~ ++ -- (int) (double) (string) (array) (object) @</entry>
       </row>
       <row>
        <entry>destra</entry>
        <entry>[</entry>
       </row>
       <row>
        <entry>non associativi</entry>
        <entry>new</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </para>
  </sect1>

  <sect1 id="language.operators.string">
   <title>Operatori di stringa</title>
   <simpara>
    Ci sono due operatori di stringa. Il primo è l'operatore di
    concatenazione ('.'), che restituisce la concatenazione dei suoi argomenti a destra e
    a sinistra. Il secondo è l'operatore di
    assegnazione concatenata ('.='), che aggiunge alla fine dell'argomento sul lato destro
    l'argomento sul lato sinistro. Per favore consultare <link
    linkend="language.operators.assignment">Operatori di
    assegnamento</link> per maggiori informazioni.
   </simpara>

   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
$a = "Ciao ";
$b = $a . "Mondo!"; // ora $b contiene "Ciao Mondo!"

$a = "Ciao ";
$a .= "Mondo!";     // ora $a contiene "Ciao Mondo!"
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>

 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
