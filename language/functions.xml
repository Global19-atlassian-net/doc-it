<?xml version="1.0" encoding="iso-8859-1"?>
<!-- EN-Revision: 1.27 Maintainer: spisto  Status: ready -->
 <chapter id="functions">
  <title>Funzioni</title>

  <sect1 id="functions.user-defined">
   <title>Funzioni definite dall'utente</title>

   <para>
    Una funzione può essere definita usando la seguente sintassi:

    <informalexample>
     <programlisting role="php">
<![CDATA[
function foo ($arg_1, $arg_2, ..., $arg_n)
{
    echo "Funzione di esempio.\n";
    return $retval;
}
]]>
     </programlisting>
    </informalexample>
   </para>

   <!--

    status of func(const $param) ?
    zend doesn't care at all whether or not you specify it.
    I've never seen it before... what's its use? (or was...)

    -->

   <simpara>
    All'interno di una funzione può apparire qualunque codice PHP valido, persino altre
    funzioni e definizioni di 
    <link linkend="keyword.class">classe</link>.
   </simpara>
   <simpara>
    In PHP 3, le funzioni devono essere definite prima di essere referenziate.
    Non esiste nessun requisito in PHP 4.
   </simpara>
   <simpara>
    PHP non supporta l'overloading di funzioni, non è possibile
    indefinire o ridefinire funzioni precedentemente dichiarate.
   </simpara>
   <simpara>
    PHP 3 non supporta un numero variabile di argomenti per le funzioni,
    sebbene siano supportati gli argomenti di default (vedere <link
    linkend="functions.arguments.default">Argomenti con valori
    di default</link> per maggiori informazioni). PHP 4 li supporta entrambi: vedere <link
    linkend="functions.variable-arg-list">Liste di argomenti
    a lunghezza variabile</link> e i riferimenti alle funzioni
    <function>func_num_args</function>,
    <function>func_get_arg</function> e
    <function>func_get_args</function> per maggiori informazioni.
   </simpara>

  </sect1>

  <sect1 id="functions.arguments">
   <title>Argomenti delle funzioni</title>

   <simpara>
    L'informazione può essere passata alle funzioni tramite la lista degli argomenti,
    che sono liste di variabili e/o costanti delimitati dalla virgola.
   </simpara>
   <para>
     PHP supporta il passaggio di argomenti per valore (comportamento di default), <link
     linkend="functions.arguments.by-reference">il passaggio
     per riferimento</link>, e <link
     linkend="functions.arguments.default">i valori di default
     degli argomenti</link>. Le liste di argomenti di lunghezza varabile sono supportate solo
     in PHP 4 e successivi; vedere <link
     linkend="functions.variable-arg-list">Liste di argomenti
     a lunghezza variabile</link> e i riferimenti alle funzioni
     <function>func_num_args</function>,
     <function>func_get_arg</function>, e
     <function>func_get_args</function> per maggiori informazioni. Un
     effetto simile può essere ottenuto in PHP 3 passando una array
     di argomenti alla funzione.

    <informalexample>
     <programlisting role="php">
<![CDATA[
function prende_array($input)
{
    echo "$input[0] + $input[1] = ", $input[0]+$input[1];
}
]]>
     </programlisting>
    </informalexample>
   </para>

   <sect2 id="functions.arguments.by-reference">
    <title>Costruire argomenti passati per riferimento</title>

    <simpara>
     Di default, gli argomenti della funzione sono passati per valore (così se
     cambiate il valore dell'argomento all'interno della funzione , esso non
     cambierà fuori della funzione). Se volete permettere ad una
     funzione di modificare i suoi argomenti, dovete passarli
     per riferimento.
    </simpara>
    <para>
     Se volete che una argomento sia passato sempre per riferimento ad una funzione,
     dovete anteporre un ampersand (&amp;) al nome
     dell'argomento nella definizione della funzione:

     <informalexample>
      <programlisting role="php">
<![CDATA[
function aggiungi_qualcosa(&$string)
{
    $string .= 'e qualche altra cosa.';
}
$str = 'Questa è una stringa, ';
aggiungi_qualcosa($str);
echo $str;    // l'output sarà 'Questa è una stringa, e qualche altra cosa.'
]]>
      </programlisting>
     </informalexample>
    </para>

   </sect2>

   <sect2 id="functions.arguments.default">
    <title>Valori predefiniti degli argomenti</title>

    <para>
     Una funzione può definire valori predefiniti in stile C++ per
     argomenti scalari come segue:

     <informalexample>
      <programlisting role="php">
<![CDATA[
function fare_il_caffe ($tipo = "cappuccino")
{
    return "Sto facendo una tazza di $tipo.\n";
}
echo fare_il_caffe ();
echo fare_il_caffe ("espresso");
]]>
      </programlisting>
     </informalexample>
    </para>

    <para>
     L'output dal frammento di sopra è:

     <screen>
Sto facendo una tazza di cappuccino.
Sto facendo una tazza di espresso.
     </screen>
    </para>

    <simpara>
     Il valore predefinito deve essere un'espressione costante, non (per
     esempio) una variabile o un membro di classe.
    </simpara>
    <para>
     Da notare che quando vengono usati argomenti predefiniti, qualunque argomento predefinito dovrebbe essere
     a destra degli argomenti non-predefiniti; diversamente, le cose
     non funzioneranno come ci si aspetti. Si consideri il seguente frammento di codice:

     <informalexample>
      <programlisting role="php">
<![CDATA[
function fare_lo_yogurt ($tipo = "yogurt", $gusto)
{
    return "Fare una vaschetta di $tipo a $gusto.\n";
}

echo fare_lo_yogurt ("fragola");   // non funziona come si aspetta
]]>
      </programlisting>
     </informalexample>
    </para>

    <para>
     L'output dell'esempio di sopra è:

     <screen>
Warning: Missing argument 2 in call to fare_lo_yogurt() in
/usr/local/etc/httpd/htdocs/php3test/functest.html on line 41
Fare una vaschetta di fragola a.
     </screen>
    </para>

    <para>
     Ora, si confronti il codice di sopra con questo:

     <informalexample>
      <programlisting role="php">
<![CDATA[
function fare_lo_yogurt ($gusto, $tipo = "yogurt")
{
    return "Fare una vaschetta di $tipo a $gusto.\n";
}

echo fare_lo_yogurt ("fragola");   // funziona come si aspetta
]]>
      </programlisting>
     </informalexample>
    </para>

    <para>
     L'output di questo esempio è:

     <screen>
Fare una vaschetta di yogurt a fragola.
     </screen>
    </para>

   </sect2>

   <sect2 id="functions.variable-arg-list">
    <title>Liste di argomenti a lunghezza variabile</title>

    <simpara>
     PHP 4 ha il supporto per le liste di argomenti a lunghezza variabile nelle
     funzioni definite dall'utente. Ciò è realmente abbastanza semplice, usando le funzioni
     <function>func_num_args</function>,
     <function>func_get_arg</function>, e
     <function>func_get_args</function>.
    </simpara>

    <simpara>
     Non è richiesta una speciale sintassi, e le liste di argomenti possono ancora essere
     provviste esplicitamente con le definizioni di funzioni e si comporteranno
     normalmente.
    </simpara>

   </sect2>

  </sect1>

  <sect1 id="functions.returning-values">
   <title>Valori restituiti</title>

   <para>
    I valori vengono restituiti usando l'istruzione opzionale return. Può
    essere restituito qualsiasi tipo, incluse liste ed oggetti. Ciò provoca
    l'interruzione dell'esecuzione della funzione immediatamente e la restituzione del controllo
    alla linea da cui è stata chiamata. Vedere <function>return</function>
    per maggiori informazioni.
    <informalexample>
     <programlisting role="php">
<![CDATA[
function quadrato ($num)
{
    return $num * $num;
}
echo quadrato (4);   // L'output è '16'.
]]>
     </programlisting>
    </informalexample>
   </para>

   <para>
    Non possono essere restituiti valori multipli da una funzione, ma
    risultati simili possono essere ottenuti restituendo una lista.

    <informalexample>
     <programlisting role="php">
<![CDATA[
function numeri_piccoli()
{
    return array (0, 1, 2);
}
list ($zero, $uno, $due) = numeri_piccoli();
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Per restituire un riferimento da una funzione, è necessario usare
    l'operatore di passaggio per riferimento &amp; in entrambe le dichiarazioni di funzioni e
    quando viene assegnato il valore restituito ad una variabile:
    <informalexample>
     <programlisting role="php">
<![CDATA[
function &restituisce_riferimento()
{
    return $un_riferimento;
}

$nuovo_riferimento =& restituisce_riferimento();
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Per maggiori informazioni sui riferimenti, consultare <link
    linkend="language.references">References Explained</link>.
   </simpara>
  </sect1>

  <sect1 id="functions.old-syntax">
   <title><literal>old_function</literal></title>

   <simpara>
    L'istruzione <literal>old_function</literal> permette di
    dichiarare una funzione usando una sintassi identica a PHP/FI2 (eccetto il
    dover sostituire 'function' con 'old_function'.
   </simpara>
   <simpara>
    Questa è una caratteristica deprecata, e dovrebbe essere usata solo da
    convertitori PHP/FI2->PHP 3.
   </simpara>
   <warning>
    <para>
     Le funzioni dichiarate come <literal>old_function</literal> non possono essere
     chiamate da codice interno di PHP. Tra le altre cose, questo significa
     che non possono essere usate in funzioni come
     <function>usort</function>, <function>array_walk</function>, e
     <function>register_shutdown_function</function>. Si può
     aggirare questa limitazione scrivendo una funzione contenitore (nel normale
     stile di PHP 3) per chiamare la <literal>old_function</literal>.
    </para>
   </warning>

  </sect1>

  <sect1 id="functions.variable-functions">
   <title>Funzioni variabili</title>

   <para>
    PHP supporta il concetto di funzioni variabili. Ciò significa che se
    un nome di variabile ha le parentesi accodate ad esso, PHP cercherà
    una funzione con lo stesso nome del valore della
    variabile, e cercherà di eseguirla. Tra le altre cose, ciò puo essere
    usato per implementare delle callbacks, tabelle di funzioni e così via.
   </para>
   <para>
    Le funzioni variabili non funzionano con costrutti di linguaggio come
    <function>echo</function>, <function>unset</function>,
    <function>isset</function>, <function>empty</function> e
    <function>include</function>. Ad ogni modo, il costrutto
    <function>print</function> è un'eccezione e funzionerà.
    Questa è una delle maggiori differenze tra le funzioni PHP e
    i costrutti di linguaggio.
   </para>
   <para>
    <example>
     <title>Esempio di funzioni variabili</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo()
{
    echo "In foo()<br>\n";
}

function bar($arg = '')
{
    echo "In bar(); l'argomento era '$arg'.<br>\n";
}

$func = 'foo';
$func();
$func = 'bar';
$func('test');
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Vedere anche <link linkend="language.variables.variable">
    variabili variabili</link> e <function>function_exists</function>.
   </para>

  </sect1>

 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
