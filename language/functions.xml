<?xml version="1.0" encoding="iso-8859-1"?>
<!-- EN-Revision: 1.59 Maintainer: spisto  Status: ready -->
 <chapter id="language.functions">
  <title>Funzioni</title>

  <sect1 id="functions.user-defined">
   <title>Funzioni definite dall'utente</title>

   <para>
    Una funzione può essere definita usando la seguente sintassi:
   </para>
   <para>
    <example>
     <title>Psuedo codice per dimostrare l'uso delle funzioni</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo($arg_1, $arg_2, /* ..., */ $arg_n)
{
    echo "Funzione di esempio.\n";
    return $retval;
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    All'interno di una funzione può apparire qualunque codice PHP valido, persino altre
    funzioni e definizioni di 
    <link linkend="keyword.class">classe</link>.
   </simpara>
   <simpara>
    In PHP 3, le funzioni devono essere definite prima di essere referenziate.
    Non esiste nessun requisito in PHP 4. <emphasis>Tranne</emphasis> quando
    una funzione è definita condizionalmente come illustrato nei due esempi
    seguenti.
   </simpara>
   <para>
    Quando una funzione è definita in modo condizionale, come illustrato
    nei seguenti esempi, occorre che ne venga processata <emphasis>prima</emphasis> la definizione
    poi venga chiamata la funzione stessa.
   </para>
   <para>
    <example>
     <title>Funzioni condizionali</title>
     <programlisting role="php">
<![CDATA[
<?php
 
$makefoo = true;
 
/* Qui non possiamo chiamare foo()
   poichè non esiste ancora,
   ma possiamo chiamare bar() */
 
bar();
 
if ($makefoo) {
  function foo()
  {
    echo "Io non esisto sino a quando il programma non ri raggiunge.\n";
  }
}
 
/* Ora possiamo chiarame foo()
   poichè $makefoo vale true */
 
if ($makefoo) foo();
 
function bar()
{
  echo "Io esco immediatamente dop l'avvio del programma.\n";
}
 
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    <example>
     <title>Funzioni dentro a funzioni</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo()
{
  function bar()
  {
    echo "Io non esiste fino a quando non si esegue foo().\n";
  }
}
 
/* Non possiamo chiamare bar()
   poicheè non esiste ancora. */
 
foo();
 
/* Ora si può eseguire bar(),
   l'elaborazione di foo()
   l'ha resa accessibile. */
 
bar();
 
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Tutte le funzioni e le classi, in PHP, hanno visibilità globale - possono
    essere chiamate dall'esterno di una funzione anche se sono definite all'interno di questa e vice-versa.
   </para>
   <simpara>
    PHP non supporta l'overloading di funzioni, non è possibile
    indefinire o ridefinire funzioni precedentemente dichiarate.
   </simpara>
   <note>
    <simpara>
     I nomi delle funzioni non distinguono tra maiuscolo e minuscolo, ma, solitamente, è
     buona norma richiamare le funzioni nel modo con cui sono state definite.
    </simpara>
   </note>
   <simpara>
    PHP 3 non supporta un numero variabile di argomenti per le funzioni,
    sebbene siano supportati gli argomenti di default (vedere <link
    linkend="functions.arguments.default">Argomenti con valori
    di default</link> per maggiori informazioni). PHP 4 li supporta entrambi: vedere <link
    linkend="functions.variable-arg-list">Liste di argomenti
    a lunghezza variabile</link> e i riferimenti alle funzioni
    <function>func_num_args</function>,
    <function>func_get_arg</function> e
    <function>func_get_args</function> per maggiori informazioni.
   </simpara>
   <para>
    In PHP è possibile utilizzare le chiamate ricorsive. Tuttavia si consiglia di
    evitare funzioni/metodi ricorsivi profondi oltre 100-200 livelli, potrebbero
    riempire lo stack e bloccare l'esecuzione dello script.
    <example>
     <title>Funzioni ricorsive</title>
     <programlisting role="php">
<![CDATA[
<?php
function recursion($a)
{
    if ($a < 20) {
        echo "$a\n";
        recursion($a + 1);
    }
}
?>
]]>
     </programlisting>
    </example>
   </para>
  </sect1>

  <sect1 id="functions.arguments">
   <title>Argomenti delle funzioni</title>

   <simpara>
    L'informazione può essere passata alle funzioni tramite la lista degli argomenti,
    che sono liste di espressioni delimitati dalla virgola.
   </simpara>
   <para>
    PHP supporta il passaggio di argomenti per valore (comportamento di default), <link
    linkend="functions.arguments.by-reference">il passaggio
    per riferimento</link>, e <link
    linkend="functions.arguments.default">i valori di default
    degli argomenti</link>. Le liste di argomenti di lunghezza varabile sono supportate solo
    in PHP 4 e successivi; vedere <link
    linkend="functions.variable-arg-list">Liste di argomenti
    a lunghezza variabile</link> e i riferimenti alle funzioni
    <function>func_num_args</function>,
    <function>func_get_arg</function>, e
    <function>func_get_args</function> per maggiori informazioni. Un
    effetto simile può essere ottenuto in PHP 3 passando una array
    di argomenti alla funzione.
   </para>
   <para>
    <example>
     <title>Passaggio di array a funzioni</title>   
     <programlisting role="php">
<![CDATA[
<?php
function prende_array($input)
{
    echo "$input[0] + $input[1] = ", $input[0]+$input[1];
}
?>
]]>
     </programlisting>
    </example>
   </para>

   <sect2 id="functions.arguments.by-reference">
    <title>Costruire argomenti passati per riferimento</title>

    <simpara>
     Di default, gli argomenti della funzione sono passati per valore (così se
     cambiate il valore dell'argomento all'interno della funzione , esso non
     cambierà fuori della funzione). Se volete permettere ad una
     funzione di modificare i suoi argomenti, dovete passarli
     per riferimento.
    </simpara>
    <para>
     Se volete che una argomento sia passato sempre per riferimento ad una funzione,
     dovete anteporre un ampersand (&amp;) al nome
     dell'argomento nella definizione della funzione:
    </para>
    <para>
     <example>
      <title>Passaggio di parametri per riferimento</title>
      <programlisting role="php">
<![CDATA[
<?php
function aggiungi_qualcosa(&$string)
{
    $string .= 'e qualche altra cosa.';
}
$str = 'Questa è una stringa, ';
aggiungi_qualcosa($str);
echo $str;    // l'output sarà 'Questa è una stringa, e qualche altra cosa.'
?>
]]>
      </programlisting>
     </example>
    </para>

   </sect2>

   <sect2 id="functions.arguments.default">
    <title>Valori predefiniti degli argomenti</title>

    <para>
     Una funzione può definire valori predefiniti in stile C++ per
     argomenti scalari come segue:
    </para>
    <para>
     <example>
      <title>Utilizzo dei parametri default in una funzione</title>
      <programlisting role="php">
<![CDATA[
<?php
function fare_il_caffe($tipo = "cappuccino")
{
    return "Sto facendo una tazza di $tipo.\n";
}
echo fare_il_caffe();
echo fare_il_caffe("espresso");
]]>
      </programlisting>
     </example>
    </para>

    <para>
     L'output dal frammento di sopra è:
    </para>
    <para>
     <screen>
Sto facendo una tazza di cappuccino.
Sto facendo una tazza di espresso.
     </screen>
    </para>
    <para>
     Anche il PHP permette di utilizzare matrici ed il tipo speciale NULL
     come valore di default, ad esempio:
    </para>
    <para>
     <example>
      <title>Utilizzo di tipi non scalari come valori di default</title>
      <programlisting role="php">
<![CDATA[
<?php
function makecoffee($types = array("cappuccino"), $coffeeMaker = NULL)
{
    $device = is_null($coffeeMaker) ? "hands" : $coffeeMaker;
    return "Making a cup of ".join(", ", $types)." with $device.\n";
}
echo makecoffee();
echo makecoffee(array("cappuccino", "lavazza"), "teapot");
?>
]]>
      </programlisting>
     </example>
 
    </para>
    <simpara>
     Il valore predefinito deve essere un'espressione costante, non (per
     esempio) una variabile, un membro di classe o una chiamata ad una funzione.
    </simpara>
    <para>
     Da notare che quando vengono usati argomenti predefiniti, qualunque argomento predefinito dovrebbe essere
     a destra degli argomenti non-predefiniti; diversamente, le cose
     non funzioneranno come ci si aspetti. Si consideri il seguente frammento di codice:
    </para>
    <para>
     <example>
      <title>Utilizzo incorretto degli argomenti di default</title>
      <programlisting role="php">
<![CDATA[
<?php
function fare_lo_yogurt($tipo = "yogurt", $gusto)
{
    return "Fare una vaschetta di $tipo a $gusto.\n";
}

echo fare_lo_yogurt("fragola");   // non funziona come si aspetta
?>
]]>
      </programlisting>
     </example>
    </para>

    <para>
     L'output dell'esempio di sopra è:
    </para>
    <para>
     <screen>
Warning: Missing argument 2 in call to fare_lo_yogurt() in
/usr/local/etc/httpd/htdocs/php3test/functest.html on line 41
Fare una vaschetta di fragola a.
     </screen>
    </para>
    <para>
     Ora, si confronti il codice di sopra con questo:
    </para>
    <para>
     <example>
      <title>Utilizzo corretto degli argomenti di default</title>
      <programlisting role="php">
<![CDATA[
<?php
function fare_lo_yogurt($gusto, $tipo = "yogurt")
{
    return "Fare una vaschetta di $tipo a $gusto.\n";
}

echo fare_lo_yogurt("fragola");   // funziona come si aspetta
]]>
      </programlisting>
     </example>
    </para>

    <para>
     L'output di questo esempio è:
    </para>
    <para>
     <screen>
Fare una vaschetta di yogurt a fragola.
     </screen>
    </para>

    <note>
     <simpara>
      Dal PHP 5 i valori di default possono essere passati per riferimento.
     </simpara>
    </note>
   </sect2>

   <sect2 id="functions.variable-arg-list">
    <title>Liste di argomenti a lunghezza variabile</title>

    <simpara>
     PHP 4 ha il supporto per le liste di argomenti a lunghezza variabile nelle
     funzioni definite dall'utente. Ciò è realmente abbastanza semplice, usando le funzioni
     <function>func_num_args</function>,
     <function>func_get_arg</function>, e
     <function>func_get_args</function>.
    </simpara>

    <simpara>
     Non è richiesta una speciale sintassi, e le liste di argomenti possono ancora essere
     provviste esplicitamente con le definizioni di funzioni e si comporteranno
     normalmente.
    </simpara>

   </sect2>

  </sect1>

  <sect1 id="functions.returning-values">
   <title>Valori restituiti</title>

   <para>
    I valori vengono restituiti usando l'istruzione opzionale return. Può
    essere restituito qualsiasi tipo, incluse liste ed oggetti. Ciò provoca
    l'interruzione dell'esecuzione della funzione immediatamente e la restituzione del controllo
    alla linea da cui è stata chiamata. Vedere <function>return</function>
    per maggiori informazioni.
   </para>
   <para>
    <example>
     <title>Esempio di uso di <function>return</function></title>
     <programlisting role="php">
<![CDATA[
<?php
function quadrato ($num)
{
    return $num * $num;
}
echo quadrato(4);   // L'output è '16'.
?>
]]>
     </programlisting>
    </example>
   </para>

   <para>
    Non possono essere restituiti valori multipli da una funzione, ma
    risultati simili possono essere ottenuti restituendo una lista.
   </para>
   <para>
    <example>
     <title>Restituzione di una matrice per ottenere più valori</title>
     <programlisting role="php">
<![CDATA[
<?php
function numeri_piccoli()
{
    return array (0, 1, 2);
}
list ($zero, $uno, $due) = numeri_piccoli();
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Per restituire un riferimento da una funzione, è necessario usare
    l'operatore di passaggio per riferimento &amp; in entrambe le dichiarazioni di funzioni e
    quando viene assegnato il valore restituito ad una variabile:
   </para>
   <para>
    <example>
     <title>Restituzione di un riferimento ad una funzione</title>
     <programlisting role="php">
<![CDATA[
<?php
function &restituisce_riferimento()
{
    return $un_riferimento;
}

$nuovo_riferimento =& restituisce_riferimento();
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Per maggiori informazioni sui riferimenti, consultare <link
    linkend="language.references">References Explained</link>.
   </simpara>
  </sect1>

  <sect1 id="functions.variable-functions">
   <title>Funzioni variabili</title>

   <para>
    PHP supporta il concetto di funzioni variabili. Ciò significa che se
    un nome di variabile ha le parentesi accodate ad esso, PHP cercherà
    una funzione con lo stesso nome del valore della
    variabile, e cercherà di eseguirla. Tra le altre cose, ciò puo essere
    usato per implementare delle callbacks, tabelle di funzioni e così via.
   </para>
   <para>
    Le funzioni variabili non funzionano con costrutti di linguaggio come
    <function>echo</function>, <function>print</function>,
    <function>unset</function>, <function>isset</function>, 
    <function>empty</function>, <function>include</function>,
    <function>require</function> e like. Occorre costruire
    una propria funzione per utilizzare questi costrutti
    come variabili per funzioni.
   </para>
   <para>
    <example>
     <title>Esempio di funzioni variabili</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo() {
    echo "In foo()<br />\n";
}

function bar($arg = '')
{
    echo "In bar(); l'argomento era '$arg'.<br />\n";
}

// Questa è la funzione per usare echo
function echoit($string)
{
    echo $string;
}

$func = 'foo';
$func();        // questa chiama foo()
$func = 'bar';
$func('test');  // questa chiama bar()

$func = 'echoit';
$func('test');  // questa chiama echoit()
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Tramite le funzioni variabili si può eseguire anche metodi
    di oggetti.
    <example>
     <title>Esempio di un metodo variabile</title>
     <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    function Variable()
    {
        $name = 'Bar';
        $this->$name(); // Questo esegue il metodo Bar()
    }
 
    function Bar()
    {
        echo "This is Bar";
    }
}
 
$foo = new Foo();
$funcname = "Variable";
$foo->$funcname();  // Questo esegue $foo->Variable()
 
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Vedere anche <function>call_user_func</function>,
    <link linkend="language.variables.variable">
    variabili variabili</link> e <function>function_exists</function>.
   </para>
  </sect1>
  	 
  <sect1 id="functions.internal">
   <title>Funzioni interne (built-in)</title>
 
   <para>
    Il PHP possiede diverse funzioni e costrutti standard. Esistono, inoltre,
    funzioni che richiedono la compila di specifici moduli del PHP, altrimenti
    si ottiene l'errore "undefined function" errors.  Ad esempio, per utilizzare
    le funzioni <link linkend="ref.image">image</link>, tipo
    <function>imagecreatetruecolor</function>, occorre che il PHP sia compilato 
    con il supporto <productname>GD</productname>. Oppure, per utilizzare <function>mysql_connect</function> occorre
    che il PHP sia compilato con il supporto per <link linkend="ref.mysql">MySQL</link>
    Esistono anche diversi funzioni di base incluse in ogni versione 
    del PHP tipo le funzioni <link linkend="ref.strings">stringa</link> e
    <link linkend="ref.var">per variabili</link>. L'esecuzione di
    <function>phpinfo</function> o di
    <function>get_loaded_extensions</function> visualizzerà quali
    moduli sono caricati nel PHP. Inoltre si noti che diverse estensioni sono
    abilitate per default e che il manule PHP è suddiviso per estensione.
    Vedere i capitoli <link linkend="configuration">configurazione</link>,
    <link linkend="install">installazione</link>, ed i capitoli
    dei singoli moduli per avere maggiori dettagli su come configurare il PHP.
   </para>
   <para>
    Come leggere e comprendere il prototipo di una funzione è spiegato
    nella sezione del manuale intitolata
    <link linkend="about.prototypes">come leggere la definizione di una funzione</link>.
    E' importante comprendere che cosa restituisce una funzione o se una funzione
    lavora direttamente sui dati passati. Ad esempio
    <function>str_replace</function> restituisce la stringa modificata, mentre
    <function>usort</function> lavora sulla variabile
    passata. Ciascuna pagina del manuale fornisce informazioni specifiche per ogni
    funzione tipo notizie sui parametri, modifiche di funzinamento,
    valori restituiti in caso di successo o di errore, ed altre informazioni disponibili.
    La conoscenza di queste differenze importanti è cruciale per la
    scrittura di codice PHP corretto.
   </para>
   <para>
    Vedere anche <function>function_exists</function>,
    <link linkend="funcref">the function reference</link>,
    <function>get_extension_funcs</function>, e
    <function>dl</function>.
   </para>
  </sect1>
 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
