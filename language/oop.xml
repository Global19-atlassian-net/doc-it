<?xml version="1.0" encoding="iso-8859-1"?>
<!-- EN-Revision: n/a Maintainer: alan_dangelo  Status: ready -->
 <chapter xml:id="language.oop" xmlns="http://docbook.org/ns/docbook">
  <title>Classi e Oggetti (PHP 4)</title>

  <sect1 xml:id="keyword.class">
   <title><literal>Classi</literal></title>
   <para>
    Una classe è una collezione di variabili e funzioni che utilizzano
    queste variabili. Una classe si definisce usando la seguente sintassi:
   </para>
   <para> 
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
class Cart {
    var $items;  // Articoli nel carrello
   
    // Aggiunge $num articoli di $artnr nel carrello
 
    function add_item ($artnr, $num)  {
        $this->items[$artnr] += $num;
    }
   
    // Prende $num articoli di $artnr e li rimuove dal carrello
 
    function remove_item ($artnr, $num) {
        if ($this->items[$artnr] > $num) {
            $this->items[$artnr] -= $num;
            return true;
        } elseif ($this->items[$artnr] == $num) {
            unset($this->items[$artnr]);
            return true;
        } else {
            return false;
        }   
    }
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
 
   <para>
    Il codice definisce una classe chiamata Cart composta da un array
    associativo che archivia gli articoli nel carrello e due funzioni
    per aggiungere e rimuovere gli articoli dal carrello stesso.
   </para>

   <warning>
    <simpara>
     <emphasis>NON</emphasis> spezzate una definizione di classe in
     più file o in più blocchi PHP. Si può anche <emphasis>EVITARE</emphasis> di spezzare
     la definizione di una classe in più blocchi PHP, a meno che la suddivisione non
     sia all'interno della dichiarazione di un metodo. Il seguente codice non funziona:
    </simpara>
    <para>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
class test {
?>
<?php
    function test() {
        print 'OK';
    }
}
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <simpara>
     Tuttavia è permessa la seguente struttura:
    </simpara>
    <para>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
class test {
    function test() {
        ?>
        <?php
        print 'OK';
    }
}
?>
]]>
      </programlisting>
     </informalexample>
    </para>
   </warning>

   <simpara>
    Le seguenti note cautelative sono valide per PHP 4.
   </simpara>
    
   <caution>
    <simpara>
     Il nome <literal>stdClass</literal> è usato esclusivamente da
     Zend ed è riservato. Non è quindi possibile creare una classe chiamata
     <literal>stdClass</literal> in PHP.
    </simpara>
   </caution>
    
   <caution>
    <simpara>
      I nomi di funzione <literal>__sleep</literal> e
      <literal>__wakeup</literal> sono riservati e magici nelle classi PHP.
      Non è possibile creare funzioni con questi nomi nelle classi definite
      dall'utente, a meno che non sia desiderata la funzionalità magica connessa
      a questi nomi. Si veda sotto per avere più informazioni.
    </simpara>
   </caution>
    
   <caution>
    <simpara>
      PHP riserva tutti i nomi di funzione che iniziano con __ a
      funzioni magiche. Si suggerisce di non usare nomi di funzioni che utilizzano
      con i caratteri __ in PHP a meno che non si desideri implementare una funzionalità magica.
    </simpara>
   </caution>

    <simpara>
     In PHP 4, sono permesse inizializzazioni di variabili con valori costanti solamente 
     grazie all'uso di <literal>var</literal>. Per inizializzare variabili con valori 
     non-costanti, bisogna creare una funzione d'inizializzazione che è chiamata 
     automaticamente all'istanziazione di un oggetto da una classe. Questo tipo di 
     funzione si chiama costruttore (vedi sotto).
    </simpara>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
class Cart {
/* questo non funziona in PHP 4. */
    var $todays_date = date("Y-m-d");
    var $name = $firstname;
    var $owner = 'Fred ' . 'Jones';
    /* E' permesso l'uso di matrici contenenti costanti */
    var $items = array("VCR", "TV");
}

/* Questo è corretto. */
class Cart {
    var $todays_date;
    var $name;
    var $owner;
    var $items;
    var $items = array("VCR", "TV");
    function Cart() {
        $this->todays_date = date("Y-m-d");
        $this->name = $GLOBALS['firstname'];
        /* etc ... */
    }
}
?>
]]>
     </programlisting>
    </informalexample>

   <para>
    Le classi sono tipi del linguaggio, e sono modelli per
    variabili reali. Per creare una variabile oggetto si usa
    l'operatore <literal>new</literal>.
   </para>
 
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$cart = new Cart;
$cart->add_item("10", 1);

$another_cart = new Cart;
$another_cart->add_item("0815", 3);
?>
]]>
    </programlisting>
   </informalexample>
 
   <para>
    Il codice sopra, genera gli oggetti $cart e $another_cart, dalla classe
    Cart. La funzione add_item() dell'oggetto $cart è chiamata per
    aggiungere una ricorrenza dell'articolo numero 10 a $cart.
    Ad $another_cart sono aggiunte 3 ricorrenze dell'articolo numero
    0815.
   </para>
   
   <para>
    Sia $cart che $another_cart dispongono delle funzioni add_item(),
    remove_item() e della variabile $items, ma per ogni oggetto queste
    sono funzioni e variabili sono distinte. Potete pensare agli oggetti come
    a qualcosa di simile alle directories di un filesystem. In un
    filesystem si possono avere due diversi files <filename>README.TXT</filename>, purchè
    siano in directories differenti. Così come in un filesystem dovete
    digitare il nome (percorso) completo per raggiungere un determinato
    file partendo da una directory toplevel, così dovete specificare il
    nome completo di una funzione o variabile che desiderate richiamare
    da un oggetto. Per PHP, la directory toplevel è il namespace globale
    dell'oggetto ed il separatore del pathname (/) è -&gt;. Così $cart-&gt;items
    e $another_cart-&gt;items sono due diverse variabili che differiscono per il nome.
    Si noti che la variabile si chiama $cart-&gt;items, e non $cart-&gt;$items,
    questo perchè le variabili il PHP si scrivono con un unico simbolo di dollaro.

   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
// corretto con un singolo $
$cart->items = array("10" => 1); 

// non valido, perchè $cart->$items diventa $cart->""
$cart->$items = array("10" => 1);

// corretto, ma non sempre può funzionare:
// $cart->$myvar diventa $cart->items
$myvar = 'items';
$cart->$myvar = array("10" => 1);  
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    Quando si definisce una classe, non è possibile prevedere quale nome avrà
    l'oggetto istanziato nel programma. Quando la classe Cart è stata scritta,
    non si poteva prevedere che l'oggetto istanziato da essa si sarebbe potuto
    chiamare $cart o $another_cart. Quindi non è possibile scrivere $cart-&gt;items
    all'interno della classe Cart in fase di progettazione. Per poter accedere alle
    funzioni e alle variabili interne di una classe perciò si usa la pseudo-variabile
    $this che può essere letta come 'la mia\il mio' o 'di questo oggetto'. Quindi,
    '$this-&gt;items[$artnr] += $num' può essere letto come 'aggiungi $num al contatore
    $artnr al del mio array degli articoli' o 'aggiungi $num al contatore $artnr dell'array
    degli articoli di questo oggetto'.

   </para>

   <note>
    <para>
     La pseudo variabile <varname>$this</varname> di norma non è definita se
     il metodo in cui è utilizzata è richiamato staticamente. Tuttavia questa
     non è la regola: <varname>$this</varname> è definita se il metodo è chiamato staticamente
     da un'altro oggetto. In questo caso il valore di 
     <varname>$this</varname> è l'oggetto chiamante. Tutto ciò viene 
     illustrato dal seguente esempio:
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
class A
{
    function foo()
    {
        if (isset($this)) {
            echo '$this is defined (';
            echo get_class($this);
            echo ")\n";
        } else {
            echo "\$this is not defined.\n";
        }
    }
}
 
class B
{
    function bar()
    {
        A::foo();
    }
}
 
$a = new A();
$a->foo();
A::foo();
$b = new B();
$b->bar();
B::bar();
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
$this is defined (a)
$this is not defined.
$this is defined (b)
$this is not defined.
]]>
      </screen>
     </informalexample>
    </para>
   </note>
 
   <note>
    <para>
    Ci sono molte utili funzioni per manipolare classi ed oggetti. Se 
    desiderate conoscerle potete dare un'occhiata alle 
    <link linkend="ref.classobj">Class/Object Functions</link>.
    </para>
   </note>
  </sect1>
  
  <sect1 xml:id="keyword.extends">
   <title><literal>extends</literal></title>

   <para>
    Spesso si ha bisogno di avere classi con variabili e funzioni
    simili ad altre classi. É buona norma definire una classe in modo 
    generico, sia per poterla riutilizzare spesso, sia per poterla 
    adattare a scopi specifici.Per facilitare questa operazione, è possibile
    generare classi per estensione di altre classi. Una classe estesa o derivata
    ha tutte le variabili e le funzioni della classe di base (questo fenomeno 
    è chiamato 'eredità', anche se non muore nessuno) più tutto ciò che viene
    aggiunto dall'estensione. Non è possibile che una sottoclasse, ridefinisca
    variabili e funzioni di una classe madre. Una classe estesa dipende sempre
    da una singola classe di base: l'eredità multipla non è supportata. Le classi
    si estendono usando la parola chiave 'extends'.


   </para>
 
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class Named_Cart extends Cart {
    var $owner;
  
    function set_owner ($name)  {
        $this->owner = $name;
    }
}
?>
]]>
    </programlisting>
   </informalexample>
 
   <para>
    Qui viene definita una classe Named_Cart che ha tutte le funzioni 
    e variabili di Cart più la variabile $owner e la funzione set_owner(). 
    Viene creato un carrello con nome con il metodo usato in precedenza, 
    in più la classe estesa permette di settare o leggere il nome del carrello. 
    Si possono usare variabili e funzioni sia di Cart che della sua estensione:
   </para>
 
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$ncart = new Named_Cart;    // Crea un carrello con nome
$ncart->set_owner("kris");  // Assegna il nome al carrello
print $ncart->owner;        // stampa il nome del proprietario
$ncart->add_item("10", 1);  // (funzionalità ereditata da Cart)
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    La relazione mostrata è chiamata relazione "genitore-figlio". Si crea una classe
    di base, poi utilizzando <literal>extends</literal> si crea una nuova classe
    <emphasis>basata</emphasis> sulla classe genitore: la classe figlia. Successivamente
    si può usare la classe figlia come classe base per un'altra
    classe.
   </para>
   <note>
    <para>
     Una classe deve essere definita prima di essere utilizzata! Se si vuole la classe
     <literal>Named_Cart</literal> che estende la classe
     <literal>Cart</literal>, bisogna definire una classe
     <literal>Cart</literal> prima. Se si vuole creare un'altra classe chiamata
     <literal>Yellow_named_cart</literal> basata sulla classe
     <literal>Named_Cart</literal> bisogna definire la classe
     <literal>Named_Cart</literal> prima. Per farla breve: l'ordine di
     definizione delle classi è importante.
    </para>
   </note>
  </sect1>

  <sect1 xml:id="language.oop.constructor">
   <title><literal>Costruttori</literal></title>
   <para>
    I costruttori sono funzioni che esistono in una classe e che 
    sono chiamate automaticamente quando si crea una nuova istanza 
    di una classe con <literal>new</literal>.  In PHP 4, una funzione diventa un costruttore, 
    quando ha lo stesso nome della classe. Se una classe non ha
    costruttore, allora si richiama il costruttore della
    classe base, se esiste.
   </para>
 
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class Auto_Cart extends Cart {
    function Auto_Cart() {
        $this->add_item ("10", 1);
    }
}
?>
]]>
    </programlisting>
   </informalexample>
 
   <para>
    Questo codice definisce una classe Auto_Cart, che non è altro che 
    Cart più un costruttore che inizializza il carrello con una occorrenza 
    dell'articolo numero "10" ogni volta che un nuovo Auto_Cart è creato con
    "new". I costruttori possono avere degli argomenti, e gli argomenti possono 
    essere facoltativi, questo li rende molto versatili. Per poter usare una classe 
    senza specificare parametri, tutti i parametri del costruttore devono essere resi
    facoltativi con valori di default.
   </para>
 
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class Constructor_Cart extends Cart {
    function Constructor_Cart($item = "10", $num = 1) {
        $this->add_item ($item, $num);
    }
}
 
// Istanzia il vecchio e noioso carrello.
$default_cart = new Constructor_Cart;
 
// Un carrello nuovo ...
$different_cart = new Constructor_Cart("20", 17);
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    E possibile utilizzare l'operatore <literal>@</literal> per
    <emphasis>inibire</emphasis> gli errori provocati dal costruttore, es:
    <literal>@new</literal>.
   </para>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class A
{
    function A()
    {
      echo "Sono il costtruttore di A.<br />\n";
    }
    function B()
    {
        echo "Sono una normale funzione di nome B della classe A.<br>\n";
        echo "Non sono il costruttore di A.<br>\n";
    }
}

class B extends A
{
   
}

// This will call B() as a constructor.
$b = new B;
?>
]]>
    </programlisting>
   </informalexample>
   
   <para>
    La funzione B() della classe A si transformerà 
    improvvisamente in un costruttore per la classe B, anche se 
    questo non era previsto. PHP 4 non 
    si preoccupa se la funzione è stata definita nella classe B o se è stata ereditata.
   </para>   
   <caution>
    <simpara>
     Il PHP 4 non richiama i costruttori di una classe base 
     automaticamente da un costruttore di una classe derivata. 
     È responsabilità del programmatore propagare la chiamata ai 
     costruttori dove è necessario.
    </simpara>
   </caution>
   
   <para>
    I distruttori sono funzioni che sono chiamate automaticamente 
    quando una variabile è distrutta con <function>unset</function>
    o semplicemente uscendo dal suo ambito. Non ci sono distruttori
    in PHP. Si può utilizzare <function>register_shutdown_function</function>
    per simulare gli effetti del distruttore.
   </para>
  </sect1>

 <sect1 xml:id="keyword.paamayim-nekudotayim"><!-- :-) -->
   <title>Operatore Scope Resolution (<literal>::</literal>)</title>

   <caution>
    <simpara>
     Ciò che segue è valido soltanto per PHP 4.
    </simpara>
   </caution>

   <para>
    A volte è utile riferirsi alle funzioni ed alle variabili 
    di classi base o riferirsi alle funzioni di classi senza 
    istanziarle. L'operatore :: è usato per questi scopi.

   </para>   
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class A {
    function example() {
        echo "Sono la funzione originale A::example().<br />\n";
    }
}

class B extends A {
    function example() {
        echo "Sono la funzione ridefinita B::example().<br />\n";
        A::example();
    }
}

// non viene istanziato nessun oggetto dalla classe A.
// ma il codice stampa
//   Sono la funzione originale A::example().<br />
A::example();

// crea un oggetto dalla classe B.
$b = new B;

// questo codice stampa
//   Sono la funzione ridefinita B::example().<br />
//   Sono la funzione originale A::example().<br />
$b->example();
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    L'esempio chiama la funzione example() della classe A, ma 
    senza creare un'istanza di A, di modo che la funzione non 
    si possa richiamare con $a->example(). example() è chiamata 
    come 'funzione della classe', e non come funzione di un 
    oggetto della classe.

   </para>
   
   <para>
    Si possono usare funzioni della classe, ma non le variabili 
    della classe. Infatti, non esiste nessun oggetto nel momento 
    della chiamata della funzione. Quindi, la funzione della classe 
    non può usare le variabili dell'oggetto (ma può usare le variabili 
    locali e globali) e $this non può essere usato.
   </para>

   <para>
    Nel suddetto esempio, la classe B ridefinisce la funzione 
    example(). La funzione originale definita nella classe A è 
    adombrata e non più disponibile, a meno che voi non chiamiate 
    esplicitamente con l'operatore :: scrivendo A::example() per 
    richiamare la funzione (è possibile anche scrivere parent::example(), 
    come mostra la sezione seguente).

   </para>
   
   <para>
    In questo contesto, c'è un oggetto corrente che può avere 
    determinate variabili. Una volta usate da parte di una 
    funzione dell'oggetto, potete usare $this per le variabili dell'oggetto.
   </para>

 </sect1>

 <sect1 xml:id="keyword.parent">
   <title><literal>parent</literal></title>

  <para>
   E possibile ritrovarsi a scrivere classi con codice 
   che si riferisce a variabili e funzioni di classi base. 
   Ciò è particolarmente VERO se una classe derivata è un 
   perfezionamento o una specializzazione di una classe base.
  </para>
  
  <para>
   Invece di usare il nome letterale della classe, bisognerebbe 
   usare il nome speciale <literal>parent</literal>, che si riferisce 
   al nome della classe base definita nella dichiarazione di <literal>extends</literal>. 
   Usando questo metodo, si evita di usare il nome della classe base nel 
   codice scritto. Se l'albero di eredità cambiasse durante lo sviluppo 
   della classe, il cambiamento si ridurrebbe semplicemente alla modifica 
   della dichiarazione <literal>extends</literal> della classe.


  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
class A {
    function example() {
        echo "Sono A::example() e fornisco una funzionalità di base.<br />\n";
    }
}

class B extends A {
    function example() {
        echo "Sono B::example() e fornisco una funzionalità aggiuntiva.<br />\n";
        parent::example();
    }
}

$b = new B;

// Il codice chiama B::example(), che a sua volta chiama A::example().
$b->example();
?>
]]>
   </programlisting>
  </informalexample>
 </sect1>

 <sect1 xml:id="language.oop.serialization">
  <title>Serializzare oggetti - oggetti nelle sessioni</title>

  <note>
   <simpara>
    In PHP 3, gli oggetti perdono la loro associazione di classe 
    durante il processo di serializzazione e di deserializzazione. 
    La variabile risultante è di tipo oggetto, ma non ha classe e
    metodi, e diventa inutile (come un buffo array).

   </simpara>
  </note>

  <caution>
   <simpara>
    Le seguenti informazioni sono valide soltanto per PHP 4.
   </simpara>
  </caution>

  <para>
   <function>serialize</function> restituisce una stringa che 
   contiene una rappresentazione byte-stream di tutti i valori 
   che possono essere memorizzati in PHP. <function>unserialize</function>
   può usare questa stringa per ricreare i valori variabili utilizzabili. 
   Usando <function>serialize</function> per salvare un oggetto si salveranno 
   tutte le variabili dell'oggetto. Le funzioni dell'oggetto non sono 
   salvate, viene salvato solo il nome della classe.
  </para>
  
  <para>
   Per potere usare <function>unserialize</function> su un oggetto, 
   la classe dell'oggetto deve essere definita. Cioè se avete un 
   oggetto $a della classe A su una pagina di nome page1.php e 
   usate <function>serialize</function>, otterrete una stringa che 
   si riferisce alla classe A e contiene tutti i valori delle variabili 
   contenute in $a. Se desiderate potere deserializzare l'oggetto in 
   un'altra pagina chiamata page2.php, dovete ricreare $a dalla classe A,
   la definizione della classe A perciò deve essere presente nella pagina
   page2.php. Questo può essere fatto per esempio memorizzando la definizione
   della classe A in un file che viene incluso sia in page1.php che in page2.php.
  </para>
  
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
// classa.inc:
  
  class A   {
      var $one = 1;
    
      function show_one() {
          echo $this->one;
      }
  }
  
// page1.php:
  include("classa.inc");
  
  $a = new A;
  $s = serialize($a);
  // memorizzare $s in qualche posto della page2.
  $fp = fopen("store", "w");
  fwrite($fp, $s);
  fclose($fp);

// page2.php:

  // questo è necessario perchè unserialize() funzioni correttamente.
  include("classa.inc");

  $s = implode("", @file("store"));
  $a = unserialize($s);

  // ora usiamo la function show_one() dell'oggetto $a.  
  $a->show_one();
?>
]]>
   </programlisting>
  </informalexample>
  
  <para>
   Se state usando le sessioni ed usate <function>session_register</function>
   per registrare oggetti, questi oggetti vengono serializzati 
   automaticamente alla fine di ogni pagina PHP e sono deserializzate 
   automaticamente su ogni pagina della sessione. Ciò significa che 
   gli oggetti possono mostrarsi in ogni pagina e che sono parte 
   integrante della sessione.
  </para>
  
  <para>
   Si suggerisce vivamente di includere le definizioni delle 
   classi degli oggetti registrati su tutte le pagine, anche 
   se le classi non sono usate su tutte le pagine. Se un 
   oggetto viene deserializzato senza la relativa definizione 
   della classe, perderà l'associazione ad essa e si transformerà 
   in in un oggetto della classe <literal>stdClass</literal> senza 
   nessuna funzione disponibile, diventando inutile.

  </para>
  
  <para>
   Così se nell'esempio qui sopra $a diventasse parte di una
   sessione e fosse registrato con <literal>session_register("a")</literal>, 
   dovreste includere un file <literal>classa.inc</literal> su tutte le pagine 
   in cui è valida la sessione, non soltanto nella page1.php  e nella page2.php.
  </para>
 </sect1>

 <sect1 xml:id="language.oop.magic-functions">
  <title>Le funzioni magiche <literal>__sleep</literal> e <literal>__wakeup</literal></title>

  <para>
   <function>serialize</function> controlla se la vostra classe ha una 
   funzione dal nome magico <literal>__sleep</literal>. In caso affermativo, 
   quella funzione viene eseguita prima di qualsiasi serializzazione. 
   La funzione può pulire l'oggetto e restituire un array con i nomi di 
   tutte le variabili di quell' oggetto che dovrebbero essere serializzate.
  </para>
  
  <para>
   Si intende usare <literal>__sleep</literal> quando chiudendo un 
   collegamento ad un database l'oggetto può avere dati pendenti e 
   l'oggetto ha bisogno di essere ripulito. Inoltre, la funzione è 
   utile se avete oggetti molto grandi che non devono essere salvati 
   completamente.
  </para>
  
  <para>
   Per contro, <function>unserialize</function> controlla per vedere 
   se c'è nella classe una funzione dal nome magico <literal>__wakeup</literal>.
   Se è presente questa funzione può ricostruire qualunque risorsa che 
   l'oggetto aveva.
  </para>
  
  <para>
    L'intento di <literal>__wakeup</literal> è quello di ristabilire
    le connessioni ai database che possono esser state persi 
    durante la serializzazione ed effettuare altre mansioni 
    reinizializzazione.
  </para>
 </sect1>
  
 <sect1 xml:id="language.oop.newref">
   <title>Riferimenti all'interno del costruttore</title>
   <para>
    La creazione di riferimenti con costruttori può condurre a risultati 
    confusi. Questa sezione in stile Tutorial vi aiuterà ad evitare problemi.
 
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
class Foo {
    function Foo($name) {
        // crea un riferimento all'interno della variabile $globalref
        global $globalref;
        $globalref[] = &$this;
        // setta Name con il valore passato
        $this->setName($name);
        // e lo manda all'output
        $this->echoName();
    }

    function echoName() {
        echo "<br>",$this->name;
    }
	
    function setName($name) {
        $this->name = $name;
    }
}
?>
]]>
    </programlisting>
   </informalexample>
  </para>
    
   <para>
    Verifichiamo se c'è una differenza fra <varname>$bar1</varname>
    che è stato creato usando l'operatore <literal>=</literal>
    e <varname>$bar2</varname> che è stato creato usando 
    l'operatore di riferimento
    <literal>=&amp;</literal> ... 

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$bar1 = new Foo('set in constructor');
$bar1->echoName();
$globalref[0]->echoName();

/* output:
imposta nel costruttore
imposta nel costruttore
imposta nel costruttore */

$bar2 =& new Foo('set in constructor');
$bar2->echoName();
$globalref[1]->echoName();

/* output:
imposta nel costruttore
imposta nel costruttore
imposta nel costruttore */
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Apparentemente non c'è differenza, ed in effetti questo
    è molto significativo: <varname>$bar1</varname> e 
    <varname>$globalref[0]</varname> _ NON _ sono riferimenti, 
    ma sono due variabili diverse. Questo succede perché "new" 
    non restituisce per default un riferimento, ma restituisce una copia.
    <note>
     <simpara>
      Non c'è perdita di prestazioni (da php 4 in su si usa il riferimento) 
      ad istanziare copie per riferimento. Al contrario spesso è meglio 
      lavorare con copie istanziate per riferimento, perché creare copie 
      reali richiede un certo tempo, mentre creare riferimenti virtuali 
      è immediato, (a meno che non si parli di un grande array o un 
      oggetto che viene modificato in modo successivo, allora sarebbe 
      saggio usare i riferimenti per cambiargli tutti i valori 
      simultaneamente).
     </simpara>
    </note>
    Per dimostrare quello che è scritto sopra guardate il codice qui sotto. 

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
// ora cambieremo il nome che cosa vi aspettate?
// potreste prevedere che $bar e $globalref[0] cambino i loro nomi ...
$bar1->setName('set from outside');

// come accennato prima ecco il risultato.
$bar1->echoName();
$globalref[0]->echoName();

/* output:
set from outside
set in constructor */

// vediamo le differenze tra $bar2 e $globalref[1] 
$bar2->setName('set from outside');

// fortunatamen sono solo uguali, ma sono la stessa variabile
// $bar2->name e $globalref[1]->name sono la stessa cosa
$bar2->echoName();
$globalref[1]->echoName();

/* output:
set from outside
set from outside */
?>
]]>
     </programlisting>
    </informalexample>   
   </para>   
   <para>
   Un esempio finale, prova a farvi capire.
   
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
class A {
    function A($i) {
        $this->value = $i;
        // provare a capire perchè qui non abbiamo bisogno d'un riferimento 
        $this->b = new B($this);
    }

    function createRef() {
        $this->c = new B($this);
    }

    function echoValue() {
        echo "<br />","class ",get_class($this),': ',$this->value;
    }
}


class B {
    function B(&$a) {
        $this->a = &$a;
    }

    function echoValue() {
        echo "<br />","class ",get_class($this),': ',$this->a->value;
    }
}

// prova a capire perchè usando una semplice copia si avrebbe
// in un risultato indesiderato nella riga segnata con *
$a =& new A(10);
$a->createRef();

$a->echoValue();
$a->b->echoValue();
$a->c->echoValue();

$a->value = 11;

$a->echoValue();
$a->b->echoValue(); // *
$a->c->echoValue();
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
class A: 10
class B: 10
class B: 10
class A: 11
class B: 11
class B: 11
]]>
     </screen>
    </informalexample>
   </para>
  </sect1>

  <sect1 xml:id="language.oop.object-comparison">
   <title>Confronto di oggetti</title>
  <para>
   In PHP 4, gli oggetti sono confrontati semplicemente, cioè: due istanze
   di oggetto sono uguali se hanno gli stessi attributi e valori, e sono
   istanze della stessa classe. Questa regola regola è applicata anche nel confronto
   di due oggetti utilizzando l'operatore di identità (<literal>===</literal>).
  </para>
  <para>
   Eseguendo il codice seguente:
   <example>
    <title>Esempio di confronto di oggetti in PHP 4</title>
    <programlisting role='php'>
<![CDATA[
<?php
function bool2str($bool) {
    if ($bool === false) {
            return 'FALSE';
    } else {
            return 'TRUE';
    }
}

function compareObjects(&$o1, &$o2) {
    echo 'o1 == o2 : '.bool2str($o1 == $o2)."\n";
    echo 'o1 != o2 : '.bool2str($o1 != $o2)."\n";
    echo 'o1 === o2 : '.bool2str($o1 === $o2)."\n";
    echo 'o1 !== o2 : '.bool2str($o1 !== $o2)."\n";
}

class Flag {
    var $flag;

    function Flag($flag=true) {
            $this->flag = $flag;
    }
}

class SwitchableFlag extends Flag {

    function turnOn() {
        $this->flag = true;
    }

    function turnOff() {
        $this->flag = false;
    }
}

$o = new Flag();
$p = new Flag(false);
$q = new Flag();

$r = new SwitchableFlag();

echo "Confronto di istanze create con gli stessi parametri\n";
compareObjects($o, $q);

echo "\nConfronto di istanze create con parametri diversi\n";
compareObjects($o, $p);

echo "\nConfronto di un'istanza della classe genitore con una sottoclasse\n";
compareObjects($o, $r);
?>
]]>
    </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Confronto di istanze create con gli stessi parametri
o1 == o2 : TRUE
o1 != o2 : FALSE
o1 === o2 : TRUE
o1 !== o2 : FALSE

Confronto di istanze create con parametri diversi
o1 == o2 : FALSE
o1 != o2 : TRUE
o1 === o2 : FALSE
o1 !== o2 : TRUE

Confronto di un'istanza della classe genitore con una sottoclasse
o1 == o2 : FALSE
o1 != o2 : TRUE
o1 === o2 : FALSE
o1 !== o2 : TRUE
]]>
    </screen>
   </example>
   Questo è l'output che si ottiene secondo le regole di confronto
   descritte sopra. Solo le istanze con gli stessi valori per gli attributi e derivanti dalla stessa
   classe sono considerate uguali ed identiche.
  </para>
  <para>
   Anche nei casi in cui l'oggetto è composto si applicano le stesse regole
   di confronto. Nell'esempio seguente creiamo una classe contenitore che archivia
   nell'array associativo <classname>Flag</classname> altri oggetti.
   <example>
    <title>Confronto di oggetti composti in PHP 4</title>
    <programlisting role='php'>
<![CDATA[
<?php
class FlagSet {
    var $set;

    function FlagSet($flagArr = array()) {
        $this->set = $flagArr;
    }

    function addFlag($name, $flag) {
        $this->set[$name] = $flag;
    }

    function removeFlag($name) {
        if (array_key_exists($name, $this->set)) {
            unset($this->set[$name]);
        }
    }
}


$u = new FlagSet();
$u->addFlag('flag1', $o);
$u->addFlag('flag2', $p);
$v = new FlagSet(array('flag1'=>$q, 'flag2'=>$p));
$w = new FlagSet(array('flag1'=>$q));

echo "\nOggetti composti u(o,p) e v(q,p)\n";
compareObjects($u, $v);

echo "\nu(o,p) and w(q)\n";
compareObjects($u, $w);
?>     
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Oggetti composti u(o,p) e v(q,p)
o1 == o2 : TRUE
o1 != o2 : FALSE
o1 === o2 : TRUE
o1 !== o2 : FALSE

u(o,p) and w(q)
o1 == o2 : FALSE
o1 != o2 : TRUE
o1 === o2 : FALSE
o1 !== o2 : TRUE
]]>   
    </screen>
   </example>
  </para>
 </sect1>
 </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
