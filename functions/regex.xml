<?xml version="1.0" encoding="iso-8859-1"?>
<!-- EN-Revision: 1.37 Maintainer: darvin  Status: ready -->
 <reference id="ref.regex">
  <title>Funzioni per le espressioni regolari (POSIX estesa)</title>
  <titleabbrev>Regexp</titleabbrev>

  <partintro>
   <note>
    <para>
     Il PHP, utilizzando le <link linkend="ref.pcre">funzioni PCRE</link>,
     supporta anche le espressioni regolari con una sintassi compatibile con Perl.
     Queste funzioni supportano riconoscimenti "pigliatutto", asserzioni, criteri condizionali,
     e diverse altre caratteristiche che non sono supportate dalla sintassi POSIX estesa. 
    </para>
   </note>
   <warning>
    <para>
     Queste funzioni per l'espressioni regolari non sono binary-safe. Le <link
      linkend="ref.pcre">funzioni PCRE</link> lo sono.
    </para>
   </warning>
   <para>
    In PHP, le espressioni regolari sono utilizzate per complesse 
    manipolazioni di stringhe. Le funzioni che supportano le espressioni 
    regolari sono:
    <itemizedlist>
     <listitem>
      <simpara><function>ereg</function></simpara>
     </listitem>
     <listitem>
      <simpara><function>ereg_replace</function></simpara>
     </listitem>
     <listitem>
      <simpara><function>eregi</function></simpara>
     </listitem>
     <listitem>
      <simpara><function>eregi_replace</function></simpara>
     </listitem>
     <listitem>
      <simpara><function>split</function></simpara>
     </listitem>
     <listitem>
      <simpara><function>spliti</function></simpara>
     </listitem>
    </itemizedlist>
    Tutte queste funzioni usano una espressione regolare come loro
    primo argomento. Le espressioni regolari utilizzate da PHP sono di tipo
    POSIX esteso così come definito in POSIX 1003.2. Per una descrizione
    completa delle espressione regolari POSIX, vedere la pagina del
    manuale di regex inclusa nella directory di regex nella distribuzione 
    di PHP. Questa è in formato man, pertanto per poterle leggere occorre
    eseguire <command>man /usr/local/src/regex/regex.7</command>.
   </para>
   <para>
    <example>
     <title>Esempi di espressione regolare</title>
     <programlisting role="php">
<![CDATA[
ereg ("abc", $string);            
/* Restituisce vero se "abc"
   viene trovata ovunque in $string. */

ereg ("^abc", $string);
/* Restituisce vero se "abc"
   viene trovata all'inizio di $string. */

ereg ("abc$", $string);
/* Restituisce vero se "abc"
   viene trovata alla fine di $string. */

eregi ("(ozilla.[23]|MSIE.3)", $HTTP_USER_AGENT);  
/* Restituisce vero se il browser
   è Netscape 2, 3 oppure MSIE 3. */

ereg ("([[:alnum:]]+) ([[:alnum:]]+) ([[:alnum:]]+)", $string,$regs); 
/* Posizione tre parole separate da spazio
   in $regs[1], $regs[2] e $regs[3]. */

$string = ereg_replace ("^", "<br />", $string); 
/* Posiziona il tag <br /> all'inizio di $string. */
 
$string = ereg_replace ("$", "<br />", $string);
/* Posiziona il tag <br /> alla fine di $string. */ 

$string = ereg_replace ("\n", "", $string);
/* Toglie ogni carattere di invio
   da $string. */
]]>
     </programlisting>
    </example>
   </para>
  </partintro>

  <refentry id="function.ereg">
   <refnamediv>
    <refname>ereg</refname>
    <refpurpose>Riconoscimento di espressione regolare</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descrizione</title>
     <methodsynopsis>
      <type>int</type><methodname>ereg</methodname>
      <methodparam><type>string</type><parameter>epressione_regolare</parameter></methodparam>
      <methodparam><type>string</type><parameter>stringa</parameter></methodparam>
      <methodparam choice="opt"><type>array</type><parameter>regs</parameter></methodparam>
     </methodsynopsis>
    <note>
     <para>
      Poichè utilizza espressioni regolari con sintassi compatibile 
      con PERL, <function>preg_match</function>, è spesso una alternativa
      più veloce a <function>ereg</function>.
     </para>
    </note>
    <simpara>
     Ricerca in <parameter>stringa</parameter> testi che possano incrociarsi
     con l'espressione regolare indicata in <parameter>espressione_regolare</parameter>.
    </simpara>
    <simpara>
     Se le parti di testo poste tra parentesi nel campo 
     <parameter>espressione_regolare</parameter> sono incontrate nella 
     <parameter>stringa</parameter> e la funzione viene chiamata utilizzando
     il terzo parametro <parameter>regs</parameter>, il testo riconosciuto
     sarà memorizzato nella matrice <parameter>regs</parameter>.
     L'indice 1, $regs[1], conterrà la sottostringa che parte dalla prima
     parentesi sinistra; $regs[2] conterrà la sottostringa a partire dalla
     seconda e così via. L'indice 0, $regs[0], conterrà la copia completa
     della stringa riconosciuta.
    </simpara>	
		<note>
		 <simpara>
                        Fino alla versione di PHP 4.1.0 compresa, <literal>$regs</literal>
                        conterrà esattamente 10 elementi, anche se il numero delle stringhe
                        riconosciute sia maggiore o minore di 10. Ciò non limita
                        <function>ereg</function> nella ricerca di più sottostringhe.
                        Se non si riconoscono testi, <literal>$regs</literal> non
                        sarà modificato da <function>ereg</function>. 
		 </simpara>
		</note>    
		<simpara>
     La ricerca è sensibile alle lettere maiuscole e minuscole.
    </simpara>
    <simpara>
     La funzione ritorna &true; se le ricerche previste da 
     <parameter>espressione_regolare</parameter> sono riscontrate in 
     <parameter>stringa</parameter>. Viene restituito &false; se non
     si hanno riscontri, oppure si verificano degli errori.
    </simpara>
    <para>
     Nel seguente frammento di codice, una data in formato
     ISO (YYYY-MM-DD) verrà visualizzata nel formato DD.MM.YYYY:
     <example>
      <title><function>ereg</function> Esempio</title>
      <programlisting role="php">
<![CDATA[
if (ereg ("([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})", $data, $regs)) {
    echo "$regs[3].$regs[2].$regs[1]";
} else {
    echo "Formato di data non valido: $data";
}
]]>
      </programlisting>
     </example>
    </para>
    <simpara>
     Vedere anche <function>eregi</function>,
     <function>ereg_replace</function>,
     <function>eregi_replace</function> e
     <function>preg_match</function>.
    </simpara>
   </refsect1>
  </refentry>

  <refentry id="function.ereg-replace">
   <refnamediv>
    <refname>ereg_replace</refname>
    <refpurpose>Sostituzioni con espressioni regolari</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descrizione</title>
     <methodsynopsis>
      <type>string</type><methodname>ereg_replace</methodname>
      <methodparam><type>string</type><parameter>espressione_regolare</parameter></methodparam>
      <methodparam><type>string</type><parameter>testo_sostitutivo</parameter></methodparam>
      <methodparam><type>string</type><parameter>stringa</parameter></methodparam>
     </methodsynopsis>
    <note>
     <para>
      Poichè utilizza espressioni regolari con sintassi compatibile 
      con Perl, <function>preg_replace</function>, è spesso una alternativa
      più veloce a <function>ereg_replace</function>.
     </para>
    </note>
    <simpara>
     La funzione ricerca all'interno del parametro <parameter>stringa</parameter>
     sottostringhe che incrocino con le condizioni specificate in <parameter>
     espressione_regolare</parameter>. Quando sono trovate, queste vengono sostituite
     con il testo specificato in <parameter>testo_sostitutivo</parameter>.
    </simpara>
    <simpara>
     La funzione restituisce la stringa modificata. (Ciò implica
     che se non ci sono sottostringhe che soddisfino l' espressione
     regolare, la funzione restituisce la stringa originaria).
    </simpara>
    <simpara>
     Se in <parameter>espressione_regolare</parameter> si specificano
     delle sottostringhe utilizzando le parentesi, anche nel campo
     <parameter>testo_sostitutivo</parameter> si possono specificare delle
     sottostringhe di formato <literal>\\<replaceable>digit</replaceable>
     </literal>, che saranno sostituite dalle stringhe soddisfacenti
     la digit'esima condizione posta tra parentesi; <literal>\\0</literal>
     indica l'intera stringa. La funzione prevede che si possano utlizzare
     fino a nove sottostringhe. E' previsto che le parentesi siano 
     nidificate, in questo caso il conteggio si basa sulle parentesi aperte.
    </simpara>  
    <simpara>
     Se nessuna parte di <parameter>stringa</parameter> viene riconosciuta,
     il parametro viene restituito invariato.
    </simpara>
    <para>
     Come esempio il seguente frammento di codice visualizzerà la frase
     "Questo fu un test" tre volte:
     <example>
      <title><function>ereg_replace</function> Esempio</title>
      <programlisting>
<![CDATA[
$stringa = "Questo è un test";
echo ereg_replace (" è", " fu", $string);
echo ereg_replace ("( )è", "\\1fu", $string);
echo ereg_replace ("(( )è)", "\\2fu", $string);
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Un aspetto a cui occorre prestare attenzione riguarda l'uso di 
     numero intero per il parametro <parameter>testo_sostitutivo</parameter>,
     si potrebbero ottenere risultati diversi da quanto atteso.
     Questo accade perchè la funzione <function>ereg_replace</function> 
     interpreta il numero come posizione ordinale di un carattere 
     comportandosi di conseguenza. Ad esempio:
     <example>
      <title><function>ereg_replace</function> Esempio</title>
      <programlisting>
<![CDATA[
<?php
/* Questo non si comporta come atteso. */
$num = 4;
$stringa = "Questa stringa ha quattro parole.";
$stringa = ereg_replace('quattro', $num, $stringa);
echo $stringa;   /* Risultato: 'Questa stringa ha   parole.' */

/* Questo funziona. */
$num = '4';
$stringa = "Questa stringa ha quattro parole.";
$stringa = ereg_replace('quattro', $num, $stringa);
echo $stringa;   /* Risultato: 'Questa stringa ha 4 parole' */
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     <example>
      <title>Sostituzione di URLs</title>
      <programlisting role="php">
<![CDATA[
$testo = ereg_replace("[[:alpha:]]+://[^<>[:space:]]+[[:alnum:]/]",
                     "<a href=\"\\0\">\\0</a>", $testo);
]]>
      </programlisting>
     </example>
    </para>
    <simpara>
     Vedere anche <function>ereg</function>, <function>eregi</function>,
     <function>eregi_replace</function>, <function>str_replace</function>, e <function>preg_match</function>.
    </simpara>
   </refsect1>
  </refentry>

  <refentry id="function.eregi">
   <refnamediv>
    <refname>eregi</refname>
    <refpurpose>Riconoscimento di espressioni regolari senza distinzione tra maiuscole e minuscole</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descrizione</title>
     <methodsynopsis>
      <type>int</type><methodname>eregi</methodname>
      <methodparam><type>string</type><parameter>espressione_regolare</parameter></methodparam>
      <methodparam><type>string</type><parameter>stringa</parameter></methodparam>
      <methodparam choice="opt"><type>array</type><parameter>regs</parameter></methodparam>
     </methodsynopsis>
    <para>
     Questa funzione è identica a <function>ereg</function>, tranne 
     che per il fatto che non distingue tra lettere maiuscole e lettere
     minuscole.
     <example>
      <title><function>eregi</function> esempio</title>
      <programlisting role="php">
<![CDATA[
if (eregi("z", $stringa)) {
    echo "'$stringa' contiene una 'z' oppure una 'Z'!";
}
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Vedere anche <function>ereg</function>,
     <function>ereg_replace</function>, e
     <function>eregi_replace</function>.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.eregi-replace">
   <refnamediv>
    <refname>eregi_replace</refname>
    <refpurpose>Sostituzioni con espressioni regolari senza distinzione tra maiuscole e minuscole</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descrizione</title>
     <methodsynopsis>
      <type>string</type><methodname>eregi_replace</methodname>
      <methodparam><type>string</type><parameter>espressione_regolare</parameter></methodparam>
      <methodparam><type>string</type><parameter>testo_sostitutivo</parameter></methodparam>
      <methodparam><type>string</type><parameter>stringa</parameter></methodparam>
     </methodsynopsis>
    <para>
     Questa funzione è identica a <function>ereg_replace</function>, tranne 
     che per il fatto che non distingue tra lettere maiuscole e lettere
     minuscole.
    </para>
    <para>
     Vedere anche <function>ereg</function>, <function>eregi</function>
     e <function>ereg_replace</function>.
    </para>
   </refsect1>
  </refentry>


  <refentry id="function.split">
   <refnamediv>
    <refname>split</refname>
    <refpurpose>Suddivide una stringa in una matrice utilizzando le espressioni regolari</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descrizione</title>
     <methodsynopsis>
      <type>array</type><methodname>split</methodname>
      <methodparam><type>string</type><parameter>espressione_regolare</parameter></methodparam>
      <methodparam><type>string</type><parameter>stringa</parameter></methodparam>
      <methodparam choice="opt"><type>int</type><parameter>limite</parameter></methodparam>
     </methodsynopsis>
    <note>
     <para>
      Poichè utilizza espressioni regolari con sintassi compatibile 
      con Perl, <function>preg_split</function>, è spesso una alternativa
      più veloce a <function>split</function>.
     </para>
    </note>
    <para>
     La funzione restituisce una matrice di stringhe che sono delle
     sottostringhe del parametro <parameter>stringa</parameter>. Queste
     sono ottenute suddividendo il parametro secondo i limiti indicati
     dal parametro <parameter>espressione_regolare</parameter>. Se viene
     specificato il parametro <parameter>limite</parameter>, la funzione 
     restituisce una matrice con un numero di elementi al massimo pari 
     a <parameter>limite</parameter>. L'ultimo elemento della matrice contiene
     la parte restante del parametro <parameter>stringa</parameter> fornito.
     Se si verificano errori la funzione <function>split</function> 
     restituisce &false;.
    </para>
    <para>
     Esempio di come estrapolare i primi 4 campi da una linea del file
     <filename>/etc/passwd</filename>:
     <example>
      <title><function>split</function> Esempio</title>
      <programlisting role="php">
<![CDATA[
list($user,$pass,$uid,$gid,$extra)= split (":", $passwd_line, 5);
]]>
      </programlisting>
     </example>
    </para>
    <tip>
     <simpara>
      Se nella stringa passata vi sono <replaceable>n</replaceable> occorrenze
      del parametro <parameter>espressione_regolare</parameter>, la matrice restituita
      conterrà <literal><replaceable>n</replaceable>+1</literal> elementi.
      Invece, nel caso in cui non vi siano occorrenze della 
      <parameter>espressione_regolare</parameter>, la matrice restituita conterrà
      un solo elemento. Ovviamente questo è valido anche nel caso in cui il 
      parametro <parameter>stringa</parameter> è vuoto.
     </simpara>
    </tip>
    <para>
     Nell'esempio che segue, si vedrà come analizzare una data il cui testo 
     può contenere barre, punti o trattini:
     <example>
      <title><function>split</function> Esempio</title>
      <programlisting role="php">
<![CDATA[
$data = "04/30/1973";  // Delimitatori di testo: barre, punti, trattini
list ($mese, $giorno, $anno) = split ('[/.-]', $data);
echo "Mese: $mese; Giorno: $giorno; Anno: $anno<br>\n";
]]>
      </programlisting>
     </example>
    </para>

    <para>
     Fare attenzione al fatto che <parameter>espressione_regolare</parameter> è distingue
     tra lettere maiuscole e minuscole.
    </para>

    <para>
     Nota: se non è richiesta la potenza delle espressioni regolari,
     è più veloce la funzione <function>explode</function>, la quale
     non richiede l'uso del motore delle espressioni regolari.
    </para>

    <para>
     Gli utenti che cercano un modo di emulare il comportamento di
     Perl <command>$chars = split('', $str)</command>, sono rimandati 
     agli esempi di  <function>preg_split</function>.
    </para>

    <para>
     Occorre fare attenzione al fatto che il parametro <parameter>
     espressione_regolare</parameter> è una espressione regolare e,
     pertanto, se si devono riconoscere caratteri che sono considerati 
     speciali per le espressioni regolari, occorre codificarli con i
     caratteri di escape. Se si ritiene che la funzione <function>split
     </function> ( o anche le altre funzioni derivate da regex ) si
     comportino in modo anomalo, è opportuno leggere il file
     <filename>regex.7</filename>, incluso nella cartella <filename>
     regex/</filename> della distribuzione di PHP. Questo file è
     nel formato del manuale di unix (man), pertanto per visualizzarlo
     occorre eseguire il comando <command>man 
      /usr/local/src/regex/regex.7</command>.
    </para>

    <para>
     Vedere anche: 
     <function>preg_split</function>,
      <function>spliti</function>,
     <function>explode</function>, 
     <function>implode</function>,
     <function>chunk_split</function> e 
     <function>wordwrap</function>.
    </para>

   </refsect1>
  </refentry>
  
  <refentry id="function.spliti">
   <refnamediv>
    <refname>spliti</refname>
    <refpurpose>
     Suddivide una stringa in una matrice usando le espressioni regolari senza distinguere tra
     maiuscole e minuscole
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descrizione</title>
     <methodsynopsis>
      <type>array</type><methodname>spliti</methodname>
      <methodparam><type>string</type><parameter>espressione_regolare</parameter></methodparam>
      <methodparam><type>string</type><parameter>stringa</parameter></methodparam>
      <methodparam choice="opt"><type>int</type><parameter>limite</parameter></methodparam>
     </methodsynopsis>
    <para>
     Questa funzione ha un comportamento identico a <function>split</function>
     tranne che per il fatto di non distinguere tra lettere maiuscole e minuscole.
    </para>
    <para>
     Vedere anche
     <function>preg_spliti</function>,
      <function>split</function>,
     <function>explode</function> 
     e <function>implode</function>.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.sql-regcase">
   <refnamediv>
    <refname>sql_regcase</refname>
    <refpurpose>
     Genera una espressione regolare per riconoscimenti senza distinguere tra maiuscole e minuscole
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descrizione</title>
     <methodsynopsis>
      <type>string</type><methodname>sql_regcase</methodname>
      <methodparam><type>string</type><parameter>stringa</parameter></methodparam>
     </methodsynopsis>
    <para>
     La funzione restituisce una espressione regolare che
     sia in grado di riconoscere il parametro <parameter>
     stringa</parameter>, a prescindere dalle lettere maiuscole 
     minuscole. L'espressione regolare restituita corrisponde
     a <parameter>string</parameter> con ciascun carattere riportato
     tra parentesi. Ogni parentesi contiene il singolo carattere
     in maiuscolo ed in minuscolo. Se il carattere non esiste in forma
     minuscola o maiuscola, il carattere originale vie riportato due volte.
     <example>
      <title><function>sql_regcase</function> Esempio</title>
      <programlisting role="php">
<![CDATA[
echo sql_regcase ("Foo bar");
]]>
      </programlisting>
     </example>
     visualizza <screen>[Ff][Oo][Oo] [Bb][Aa][Rr]</screen>.
    </para>
    <para>
     Questa funzione torna utile quando si devono ottenere espressioni regolari
     non distinguono tra lettere maiuscole e minuscole da passare a prodotti che
     supportano espressioni regolari che distinguono il tipo di lettera.
    </para>
   </refsect1>
  </refentry>


 </reference>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->

