<?xml version="1.0" encoding="iso-8859-1"?>
<!-- EN-Revision: 1.83 Maintainer: penzo Status: ready -->
 <reference id="ref.session">
  <title>Funzioni di gestione della sessione</title>
  <titleabbrev>Sessioni</titleabbrev>
	
  <partintro>
   <para>
    Il supporto delle sessioni in PHP consiste nel mantenere certi dati
    attraverso accessi successivi.Questo vi dà la capacità di costruire 
    applicazioni più consone alle vostre esigenze e di accrescere le qualità 
    del vostro sito web.
   </para>
   <para>
    Se avete dimestichezza con la gestione delle sessioni di PHPLIB, noterete
    che alcuni concetti sono simili al supporto dele sessioni in PHP.
   </para>
   <para>
    Al visitatore che accede al vostro sito web viene assegnato un id unico,
    il cosidetto id di sessione.Questo viene registrato in un cookie sul 
    lato utente o è propagato tramite l'URL.
   </para>
   <para>
    Il supporto delle sessioni vi permette di registrare numeri arbitrari di 
    variabili che vengono preservate secondo richiesta.Quando un visitatore 
    accede al vostro sito, PHP controllerà automaticamente (se session.auto_start è
    settato a 1) o su vostra richiesta (esplicitamente tramite 
    <function>session_start</function> o implicitamente tramite
    <function>session_register</function>) se uno specifico id di 
    sessione sia stato inviato con la richiesta.In questo caso , il 
    precedente ambiente salvato viene ricreato.
   </para>
   <para>
    Tutte le variabili registrate vengono serializzate dopo che la richiesta
    è finita.Le variabili registrate che non sono definite vengono marcate
    come indefinite. All'accesso successivo, queste non vengono definite 
    dal modulo di sessione fino a quando l'utente non le definisce più tardi.
   </para>
   <para>
    La configurazione di <link
    linkend="ini.track-vars"><literal>track_vars</literal></link> e
    <link
    linkend="ini.register-globals"><literal>register_globals</literal></link>
    influenza come le variabili di sessione vengono memorizzate una e più volte.
   </para>

   <note>
    <para>
     In PHP 4.0.3, <link
     linkend="ini.track-vars"><literal>track_vars</literal></link> è sempre
     attiva.
    </para>
   </note>
   <note>
    <para>
     In PHP 4.1.0, <varname>$_SESSION</varname> è disponibile come variabile
     globale proprio come <varname>$_POST</varname>,
     <varname>$_GET</varname>, <varname>$_REQUEST</varname> e così via.
     <varname>$_SESSION</varname> non è sempre globale come
     <varname>$HTTP_SESSION_VARS</varname>. Per questo motivo, il termine
     <literal>global</literal> non dovrebbe essere usato per
     <varname>$_SESSION</varname>.
    </para>
   </note>

   <para>
    Se <link
    linkend="ini.track-vars"><literal>track_vars</literal></link> è 
    attiva e <link
    linkend="ini.register-globals"><literal>register_globals</literal></link>
    non è attiva, solo i membri dell'array associativo globale
    <varname>$HTTP_SESSION_VARS</varname> possono essere registrati come 
    variabili di sessione.
    Le variabili di sessione ripristinate saranno disponibili
    nell'array <varname>$HTTP_SESSION_VARS</varname>.
  <example>
     <title>
      Registrare una variabile con <link
      linkend="ini.track-vars"><literal>track_vars</literal></link>
      attiva
     </title>
     <programlisting role="php">
<![CDATA[
<?php
if (isset($HTTP_SESSION_VARS['count'])) {
   $HTTP_SESSION_VARS['count']++;
}
else {
   $HTTP_SESSION_VARS['count'] = 0;
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    L'uso di <varname>$_SESSION</varname> (o
    <varname>$HTTP_SESSION_VARS</varname> con PHP 4.0.6 o precedente) è
    raccomandato per sicurezza e leegibilità del codice.Con
    <varname>$_SESSION</varname> o
    <varname>$HTTP_SESSION_VARS</varname>, non c'è bisogno di usare le funzioni
    session_register()/session_unregister()/session_is_registered().
    Gli utenti possono accedere alla variabile di sessione come a una 
    variabile normale.
    <example>
     <title>
      Registrare una variabile con $_SESSION.
     </title>
     <programlisting role="php">
<![CDATA[
<?php
// Use $HTTP_SESSION_VARS with PHP 4.0.6 or less
if (!isset($_SESSION['count'])) {
    $_SESSION['count'] = 0;
} else {
    $_SESSION['count']++;
}
?>
]]>
     </programlisting>
    </example>
    <example>
     <title>
      Resettare una variabile con $_SESSION.
     </title>
     <programlisting role="php">
<![CDATA[
<?php
// Use $HTTP_SESSION_VARS with PHP 4.0.6 or less
unset($_SESSION['count']);

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Se <link
    linkend="ini.register-globals"><literal>register_globals</literal></link>
    è attiva, allora tutte le variabili globali possono essere registrate
    come variabili di sessione e le variabili di sessione saranno ripristinate
    in corrispondenza delle variabili globali. 
    Dal momento che PHP ha bisogno di sapere quali variabili globali sono
    registrate come variabili di sessione , gli utenti devono registrare le
    variabili con la funzione session_register() mentre
    <varname>$HTTP_SESSION_VARS</varname>/<varname>$_SESSION</varname>
    non ha bisogno di usare session_register().
    <caution>
     <para>
      Se state usando
      <varname>$HTTP_SESSION_VARS</varname>/<varname>$_SESSION</varname>
      e <link
      linkend="ini.register-globals"><literal>register_globals</literal></link> non
      è attiva, non usate <function>session_register</function>,
      <function>session_is_registered</function> e
      <function>session_unregister</function>.
     </para>
     <para>
      Se attivate <link
       linkend="ini.register-globals"><literal>register_globals</literal></link>,
       <function>session_unregister</function> dovrebbe essere usata dal momento in 
       cui le variabili di sessione vengono registrate come variabili globali
       quando i dati di sessione vengono deserializzati.
       Disattivare <link
       linkend="ini.register-globals"><literal>register_globals</literal></link>
       è raccomandato sia per motivi di sicurezza che di prestazione.
     </para>
    </caution>
    <example>
     <title>
      Registrare una variabile con <link
      linkend="ini.register-globals"><literal>register_globals</literal></link>
      attiva
     </title>
     <programlisting role="php">
<![CDATA[
<?php
if (!session_is_registered('count')) {
    session_register("count");
    $count = 0;
}
else {
    $count++;
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Se entrambe <link
    linkend="ini.track-vars"><literal>track_vars</literal></link> e
    <link
    linkend="ini.register-globals"><literal>register_globals</literal></link>
    sono attivate, allora le variabili globali e le entrate di
    <varname>$HTTP_SESSION_VARS</varname>/<varname>$_SESSION</varname>
    riporteranno lo stesso valore per variabili già registrate.
   </para>
   <para>
    Se l'utente usa session_register() pre registrare una variabile di sessione,
    <varname>$HTTP_SESSION_VARS</varname>/<varname>$_SESSION</varname>
    non avranno questa variabile nell'array fino a che non sarà caricata
    dall'archivio di sessione.(i.e. fino alla prossima richiesta)
   </para>
   <para>
    Ci sono due metodi per propagare l'id di sessione:
    <itemizedlist>
     <listitem>
      <simpara>
       I Cookies
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Un parametro dell'URL
      </simpara>
     </listitem>
    </itemizedlist>
   </para>
   <para>
    Il modulo di sessione supporta entrambi i metodi. I cookies sono ottimi,
    ma dal momento che possono non essere a disposizione (i clients non sono 
    costretti ad accettarli ), non possiamo dipendere da questi.
    Il secondo metodo incorpora l'id di sessione direttamente negli URL.
   </para>
   <para>
    PHP ha la capacità di farlo in modo trasparente quando compilato con
    <link linkend="install.configure.enable-trans-sid">
    <literal>--enable-trans-sid</literal></link>. Se attivate questa opzione,
    gli URL relativi saranno modificati per contenere l'id di sessione
    automaticamente. In alternativa, potete usare la costante
    Alternatively, you can use the constant
    <literal>SID</literal> che è definita, se il client non ha mandato
    il cookie appropriato.  <literal>SID</literal> può avere la forma di
     <literal>session_name=session_id</literal> o può essere una stringa vuota.
   </para>
   <para>
    L'esempio seguente dimostra come registrare una variabile e come collegare
    una pagina all'altra correttamente usando SID.
    <example>
     <title>Contare il numero di accessi di un singolo utente</title>
     <programlisting role="php">
<![CDATA[
<?php
if (!session_is_registered('count')) {
    session_register('count');
    $count = 1;
}
else {
    $count++;
}
?>

Salve visitatore , hai visitato questa pagina <?php echo $count; ?> times.<p>;

<?php
# il <?php echo SID?> (<?=SID?> può essere usato se short tag è attivo) 
# è necessario per preservare l'id di sessione
# nel caso incui l'utente abbia disattivato i cookies
?>

Per continuare, <A HREF="nextpage.php?<?php echo SID?>">clicca qui</A>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Il <literal>&lt;?=SID?&gt;</literal> non è necessario, se
    <link linkend="install.configure.enable-trans-sid">
    <literal>--enable-trans-sid</literal></link> è stato usato per compilare PHP.
   </para>
   <note>
    <para>
     Gli URL non relativi si presume che puntino a siti esterni e quindi
     non hanno il SID , perchè sarebbe rischioso per la sicurezza propagare
     il SID a un altro server.
    </para>
   </note>
   <para>
    Per implementare l'archiviazione in database , o qualsiasi altro metodo di archiviazione,
    avete bisogno di usare <function>session_set_save_handler</function> per
    creare un set di funzioni di archiviazione a livello utente.
   </para>
   <para>
    Il sistema di gestione delle sessioni supporta un numero di opzioni di configurazione
    che potete posizionare nel vostro file php.ini. Ne daremo una breve
    spiegazione.
    <itemizedlist>
     <listitem>
      <simpara>
       <literal>session.save_handler</literal> definisce il nome dell'handler
       che è usato per archiviare e rilasciare i dati associati a una sessione.
       Di default è
       <literal>files</literal>.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       <literal>session.save_path</literal> definisce l'argomento che
       è passato all'handler di sessione. Se scegliete handler files di default ,
       questo è il percorso dove i files vengono creati.
       Di default è <literal>/tmp</literal>. Se la profondità del percorso
       <literal>session.save_path</literal> è più di 2,
       l'accumulo (gc) non sarà effettuato.
      </simpara>
      <warning>
       <para>
        Se lasciate questo settato a directory leggibile da tutti , come
        If you leave this set to a world-readable directory, such as
        <filename>/tmp</filename> (il default), altri utenti sul
        potrebbero essere in grado di dirottare le sessioni prendendo la
        lista dei files in quella directory.
       </para>
      </warning>
     </listitem>
     <listitem>
      <simpara>
       <literal>session.name</literal> specifica il nome della sessione
       che è usata come nome del cookie. Dovrebbe contenere solo caratteri
       alfanumerici. Di default è
       <literal>PHPSESSID</literal>.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       <literal>session.auto_start</literal> specifica se il modulo di sessione
       inizia una sessione automaticamente su richiesta iniziale.
       Di default è <literal>0</literal> (disattivata).
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       <literal>session.cookie_lifetime</literal> specifica il tempo di vita insecondi
       del cookie che viene mandato al browser. Il valore 0 significa
       "fino a che il browser viene chiuso". Di default è
       <literal>0</literal>.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       <literal>session.serialize_handler</literal> definisce il nome
       dell'handler che è usato per serializzare/deserializzare
       i dati. Al momento, un formato interno di PHP(nome
       <literal>php</literal>) e WDDX è supportato (nome
       <literal>wddx</literal>). WDDX è solo disponibile, se PHP è
       compilato con <link linkend="ref.wddx">WDDX
       support</link>. Il defailt è <literal>php</literal>.
       </simpara>
     </listitem>
     <listitem>
      <simpara>
       <literal>session.gc_probability</literal> specifica la
       probabilità , in percentuale ,che la routine gc (garbage collection) 
       sia cominciata ad ogni richiesta in percentuale. Di default è <literal>1</literal>.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       <literal>session.gc_maxlifetime</literal> specifica il numero
       di secondi dopo i quali i dati saranno considerati 'spazzatura' e 
       cancellati. 
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       <literal>session.referer_check</literal> contiene la sottostringa 
       con cui volete controllare ogni HTTP referer. Se il referer è stato mandato dal client
       e la sottostringa non è stata trovata, l'id incorporato nella sessione verrà 
       marcato come non valido. Il default è una stringa vuota.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       <literal>session.entropy_file</literal> dà un percorso a
       una risorsa esterna (file) che sarà usata come una addizionale 
       sorgente entropica nella crazione dell'id di sessione. Esempi sono
       <literal>/dev/random</literal> o
       <literal>/dev/urandom</literal> che sono disponibili sulla maggior parte dei
       sistemi Unix.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       <literal>session.entropy_length</literal> specifica il numero
       di bytes che saranno letti dal file specificato
       sopra. Di default è <literal>0</literal> (disattivato).
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       <literal>session.use_cookies</literal> specifica se il
       modulo userà i cookies per archiviare l'id di sessione sul lato
       client. Di default è <literal>1</literal> (attivo).
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       <literal>session.cookie_path</literal> specifica il percorso da stabilire
       in session_cookie. Di default è <literal>/</literal>.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       <literal>session.cookie_domain</literal> specifica il dominio 
       settato in session_cookie. Di default è niente. 
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       <literal>session.cache_limiter</literal> specifica il metodo di controllo
       della cache da usare per le pagine di sessione
       (none/nocache/private/private_no_expire/public). Di default è
       <literal>nocache</literal>.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       <literal>session.cache_expire</literal> specifica il tempo-di-vita ,
        in minuti , delle pagine nella cache, questo non ha effetto sul
        limitatore nocache. Di default è <literal>180</literal>.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       <literal>session.use_trans_sid</literal> specifica se il supporto sid trasparente
        è attivato o no se attivato compilandolo con 
        <link linkend="install.configure.enable-trans-sid">
       <literal>--enable-trans-sid</literal></link>.
       Di default è <literal>1</literal> (attivo).
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       <literal>url_rewriter.tags</literal> specifica quali html tags sono
       riscritti per includere l'id di sessione se il supporto sid trasparente è attivato.
       Di default è <literal>a=href,area=href,frame=src,input=src,form=fakeentry</literal>
      </simpara>
     </listitem>
    </itemizedlist>
    <note>
     <para>
      L'handling di sessione è stato aggiunto in PHP 4.0. 
     </para>
    </note>
   </para>
  </partintro>

  <refentry id="function.session-start">
   <refnamediv>
    <refname>session_start</refname>
    <refpurpose>Inizializza i dati di sessione</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descrizione</title>
     <methodsynopsis>
      <type>bool</type><methodname>session_start</methodname>
      <void/>
     </methodsynopsis>
    <simpara>
     <function>session_start</function> creauna sessione (o riprende
     quella corrente basata sull'id di sessione che viene passato attraverso
     una variabile GET o un cookie.
    </simpara>
    <simpara>
     Se volete usare usare una sessione con un nome, dovete chiamare
     <function>session_name</function> prima di
     <function>session_start</function>.
    </simpara>
    <simpara>
     Questa funzione ritorna sempre &true;.
    </simpara>
    <note>
     <para>
      Se state usando una sessione basata sui cookie, dovete chiamare
      <function>session_start</function> prima di qualsiasi altro output al
      browser.
     </para>
    </note>
    <simpara>
     <function>session_start</function> registrerà un handler interno di output
     per riscrivere l'URL quando <literal>trans-sid</literal> è attivato.
     Se l'utente usa <literal>ob_gzhandler</literal> o come 
     con <function>ob_start</function>, l'ordine dell'handler di output
     è importante per un giusto output. Per esempio, l'utente deve registrare
     <literal>ob_gzhandler</literal> prima che la sessione cominci.
    </simpara>
    <note>
     <simpara>
      L'uso di <literal>zlib.output_compression</literal> è raccomandato
      più che di <literal>ob_gzhandler</literal>
     </simpara>
    </note>
   </refsect1>
  </refentry>

  <refentry id="function.session-destroy">
   <refnamediv>
    <refname>session_destroy</refname>
    <refpurpose>Distrugge tutti i dati registrati in una sessione</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descrizione</title>
     <methodsynopsis>
      <type>bool</type><methodname>session_destroy</methodname>
      <void/>
     </methodsynopsis>
    <simpara>
     <function>session_destroy</function> distrugge tutti i dati
     associati alla sessione corrente. Non desetta nessuna delle
     variabili globali associate alla sessione o desetta il cookie di
     sessione.
    </simpara>
    <simpara>
     Questa funzione ritorna &true; in caso di successo e 
     &false; in caso di fallimento nel distruggere
     i dati di sessione.
    </simpara>
    <para>
     <example>
      <title>Distruggere una sessione</title>
      <programlisting role="php">
<![CDATA[
<?php

// Inizializza la sessione.
// Se state usando session_name("qualcosa"), non dimenticatevelo adesso!
session_start();
// Desetta tutte le variabili di sessione.
session_unset();
// Infine , distrugge la sessione.
session_destroy();

?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     <example>
      <title>Distruggere una sessione con $_SESSION</title>
      <programlisting role="php">
<![CDATA[
<?php

// Inizializza la sessione.
// Se state usando session_name("qualcosa"), non dimenticatevelo adesso!
session_start();
// Desetta tutte le variabili di sessione.
$_SESSION = array();
// Infine distrugge la sessione.
session_destroy();

?>
]]>
      </programlisting>
     </example>
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.session-name">
   <refnamediv>
    <refname>session_name</refname>
    <refpurpose>Dà e/o stabilisce il nome della sessione corrente</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descrizione</title>
     <methodsynopsis>
      <type>string</type><methodname>session_name</methodname>
      <methodparam choice="opt"><type>string</type><parameter>name</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>session_name</function> ritorna il nome della sessione 
     corrente. Se <parameter>name</parameter> è specificato, il nome della
     sessione corrente viene cambiato al suo valore.
    </para>
    <para>
     Il nome della sessione riporta l'id nei coookies e negli URl.
     Dovrebbe contenere solo caratteri alfanumerici; dovrebbe
     essere corto e descrittivo (i.e. per utenti con l'avviso di cookie
     attivo). Il nome di sessione è resettato al valore di default
     archiviato in <literal>session.name</literal> quando avviene la richiesta iniziale.
     Tuttavia, avete bisogno di chiamare <function>session_name</function>
     per ogni richiesta (e prima vengono chiamate <function>session_start</function>
     o <function>session_register</function>).
    </para>
    <example>
     <title><function>session_name</function> esempi</title>
     <programlisting role="php">
<![CDATA[
<?php

// imposta il nome di sessione a WebsiteID

$previous_name = session_name("WebsiteID");

echo "Il precedente nome di sessione è $previous_name<p>";
?>
]]>
     </programlisting>
    </example>
   </refsect1>
  </refentry>

  <refentry id="function.session-module-name">
   <refnamediv>
    <refname>session_module_name</refname>
    <refpurpose>Assume o imposta il corrente modulo di sessione</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descrizione</title>
     <methodsynopsis>
      <type>string</type><methodname>session_module_name</methodname>
      <methodparam choice="opt"><type>string</type><parameter>module</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>session_module_name</function> restituisce il nome del corrente 
     modulo di sessione. Se <parameter>module</parameter> è
     specificato, sarà invece usato quel modulo.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.session-save-path">
   <refnamediv>
    <refname>session_save_path</refname>
    <refpurpose>Assume o stabilisce il percorso di salvataggio sessione corrente</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descrizione</title>
     <methodsynopsis>
      <type>string</type><methodname>session_save_path</methodname>
      <methodparam choice="opt"><type>string</type><parameter>path</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>session_save_path</function> restituisce il percorso della directory
     corrente usata per salvare i dati di sessione. Se <parameter>path</parameter>
     è specificato, il percorso in quale i dati vengono salvati verrà cambiata.
     <note>
      <para>
       Su alcuni sistemi operativi, potreste voler specificare un percorso su un
       filesystem che gestisce molti piccoli files in modo efficiente. Per
       esempio, su Linux, reiserfs potrebbe garantire una migliore prestazione
       di ext2fs.
      </para>
     </note>
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.session-id">
   <refnamediv>
    <refname>session_id</refname>
    <refpurpose>Assume o imposta l'id di sessione corrente</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descrizione</title>
     <methodsynopsis>
      <type>string</type><methodname>session_id</methodname>
      <methodparam choice="opt"><type>string</type><parameter>id</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>session_id</function> restituisce l'id di sessione per
     la sessione corrente. Se <parameter>id</parameter> è specificato, sostituirà
     l'id di sessione corrente.
    </para>
    <para>
     La costante <systemitem>SID</systemitem> può essere usata anche per
     fornire nome e id correnti di sessione come una stringa fatta in modo che 
     si possa aggiungere agli Url.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.session-register">
   <refnamediv>
    <refname>session_register</refname>
    <refpurpose>
     Registra una o più variabili con la sessione corrente
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descrizione</title>
     <methodsynopsis>
      <type>bool</type><methodname>session_register</methodname>
      <methodparam><type>mixed</type><parameter>name</parameter></methodparam>
      <methodparam choice="opt"><type>mixed</type><parameter>...</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>session_register</function> accetta un numero di argomenti 
     variabile, ognuno dei quali può sia essere una stringa contenente il nome di
     una variabile o un array che contiene i nomi delle variabili o altri arrays.
     Per ogni nome, <function>session_register</function> registra la variabile 
     globale con quel nome nella sessione corrente.
    </para>
    <caution>
     <para>
      Questo registra un variabile <emphasis>global</emphasis>. Se volete
      registrare una variabile di sessione interna a una funzione, avete bisogno di assicurarvi
      di farla globale usando <function>global</function> o usate gli arrays di sessione
      come scritto sotto.
     </para>
    </caution>
    <caution>
     <para>
      Se state usando
      <varname>$HTTP_SESSION_VARS</varname>/<varname>$_SESSION</varname>,
      non usate <function>session_register</function>,
      <function>session_is_registered</function> e
      <function>session_unregister</function>.
     </para>
    </caution>
    <para>
     Questa funzione restituisce &true; quando tutte le variabili sono registrate
     con successo nella sessione.
    </para>
    <para>
     Se <function>session_start</function> non è stata chiamata prima che questa funzione
     venga chiamata, avverrà una chiamata imlicita senza parametri 
     a <function>session_start</function>.
    </para>
    <para>
     Potete anche creare una variabile di sessione semplicemente impostando
     l'appropriato membro di <varname>$HTTP_SESSION_VARS</varname>
     o <varname>$_SESSION</varname> (PHP >= 4.1.0) array.
     <informalexample>
      <programlisting role="php">
<![CDATA[
$barney = "Una grande torta fiammeggiante.";
session_register("barney");

$HTTP_SESSION_VARS["zim"] = "Mars attack.";

# the auto-global $_SESSION array was introduced in PHP 4.1.0
$_SESSION["spongebob"] = "Ha i pantaloni a quadri.";
]]>
      </programlisting>
     </informalexample>
    </para>
    <note>
     <para>
      Non è possibile registrare risorse variabili in una sessione.
      Per esempio, non potete creare una connessione a un database e 
      archiviare l'id della connessione come una variabile di sessione
      e aspettarvi che la connessione sia ancora valida la prossima volta
      che la sessione viene riastabilita. Le funzioni PHP che restituiscono
      una risorsa sono identificate avendo un tipo di restituzione <literal>resource</literal>
      nelle loro definizioni di funzione.  Una lista di funzioni che restituisce
      risorse è disponibile nell'appendice <link linkend="resource">resource types</link>.
     </para>
     <para>
      Se viene usata <varname>$_SESSION</varname> (o
      <varname>$HTTP_SESSION_VARS</varname> per PHP 4.0.6 or inferiore),
      assegna la variabile a
      <varname>$_SESSION</varname>. i.e. $_SESSION['var'] = 'ABC';
     </para>
    </note>
    <para>
     Vedere anche <function>session_is_registered</function> e
     <function>session_unregister</function>.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.session-unregister">
   <refnamediv>
    <refname>session_unregister</refname>
    <refpurpose>
     Deregistra una variabile dalla sessione corrente
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descrizione</title>
     <methodsynopsis>
      <type>bool</type><methodname>session_unregister</methodname>
      <methodparam><type>string</type><parameter>name</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>session_unregister</function> deregistra (dimentica)
     la variabile globale con nome <parameter>name</parameter> dalla 
     sessione corrente.
    </para>
    <para>
     Questa funzione restituisce &true; quando la variabile viene deregistrata
     con successo dalla sessione.
    </para>
    <note>
     <para>
      Se viene usata <varname>$_SESSION</varname> (o
      <varname>$HTTP_SESSION_VARS</varname> per PHP 4.0.6 o inferiore),
      usate <function>unset</function> per deregistrare una variabile 
      di sessione.
     </para>
    </note>
    <caution>
     <para>
      Questa funzione non deimposta la corrispondente variabile globale per
      <parameter>name</parameter>, impedisce solo che la variabile venga
      salvata come parte della sessione. Dovete chiamare <function>unset</function>
      per rimuovere la variabile globale corrispondente.
     </para>
    </caution>
    <caution>
     <para>
      Se state usando
      <varname>$HTTP_SESSION_VARS</varname>/<varname>$_SESSION</varname>,
      non usate <function>session_register</function>,
      <function>session_is_registered</function> e
      <function>session_unregister</function>.
     </para>
    </caution>
   </refsect1>
  </refentry>
  
  <refentry id="function.session-unset">
   <refnamediv>
    <refname>session_unset</refname>
    <refpurpose>
     Libera tutte le variabili di sessione
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descrizione</title>
     <methodsynopsis>
      <type>void</type><methodname>session_unset</methodname>
      <void/>
     </methodsynopsis>
    <para>
     La funzione <function>session_unset</function> libera tutte le variabili di sessione
     correntemente registrate.
    </para>
    <note>
     <para>
      Se è usata <varname>$_SESSION</varname> (o
      <varname>$HTTP_SESSION_VARS</varname> per PHP 4.0.6 o inferiore) è, 
      usate <function>unset</function> per deregistrare una variabile di
      sessione. i.e. $_SESSION = array();
     </para>
    </note>
   </refsect1>
  </refentry>

  <refentry id="function.session-is-registered">
   <refnamediv>
    <refname>session_is_registered</refname>
    <refpurpose>
     Scopre se una variabile è registrata nella sessione
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descrizione</title>
     <methodsynopsis>
      <type>bool</type><methodname>session_is_registered</methodname>
      <methodparam><type>string</type><parameter>name</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>session_is_registered</function> restituisce &true; se c'è
     una variabile con il nome <parameter>name</parameter>
     registrato nella sessione corrente.
    </para>
    <note>
     <para>
      Se è usata <varname>$_SESSION</varname> (o
      <varname>$HTTP_SESSION_VARS</varname> per PHP 4.0.6 o inferiore), 
      usate <function>isset</function> per controllare che una variabile
      sia registrata in <varname>$_SESSION</varname>.
     </para>
    </note>
    <caution>
     <para>
      Se state usando
      <varname>$HTTP_SESSION_VARS</varname>/<varname>$_SESSION</varname>,
      non usate <function>session_register</function>,
      <function>session_is_registered</function> e
      <function>session_unregister</function>.
     </para>
    </caution>
   </refsect1>
  </refentry>
  
  <refentry id="function.session-get-cookie-params">
   <refnamediv>
    <refname>session_get_cookie_params</refname>
    <refpurpose>
     Restituisce i parametri del cookie di sessione
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descrizione</title>
     <methodsynopsis>
      <type>array</type><methodname>session_get_cookie_params</methodname>
      <void/>
     </methodsynopsis>
    <para>
     La funzione <function>session_get_cookie_params</function> restituisce un
     con le informazioni sul cookie di sessione corrente, l'array contiene
     i seguenti elementi:
     <itemizedlist>
      <listitem>
       <simpara>
        "lifetime" -  La durata del cookie.
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        "path" -  Il percorso dove l'informazione è archiviata.
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        "domain" -  Il dominio di validità del cookie.
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        "secure" -  Il cookie dovrebbe essere spedito solo attraverso connessioni sicure.
        (Questo elemento è stato aggiunto in PHP 4.0.4.)
       </simpara>
      </listitem>
     </itemizedlist>
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.session-set-cookie-params">
   <refnamediv>
    <refname>session_set_cookie_params</refname>
    <refpurpose>
     Imposta i parametri del cookie di sessione
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descrizione</title>
     <methodsynopsis>
      <type>void</type><methodname>session_set_cookie_params</methodname>
      <methodparam><type>int</type><parameter>lifetime</parameter></methodparam>
      <methodparam choice="opt"><type>string</type><parameter>path</parameter></methodparam>
      <methodparam choice="opt"><type>string</type><parameter>domain</parameter></methodparam>
     </methodsynopsis>
    <para>
     Imposta i parametri del cookie definiti nel file php.ini. L'effetto di questa
     funzione dura solo per la durata dello script.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.session-decode">
   <refnamediv>
    <refname>session_decode</refname>
    <refpurpose>Decodifica i dati di sessione da una stringa</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descrizione</title>
     <methodsynopsis>
      <type>bool</type><methodname>session_decode</methodname>
      <methodparam><type>string</type><parameter>data</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>session_decode</function> decodifica i dati di sessione in
     <parameter>data</parameter>, impostando le varibili archiviate nella
     sessione.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.session-encode">
   <refnamediv>
    <refname>session_encode</refname>
    <refpurpose>
     Codifica i dati della sessione corrente in una stringa
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descrizione</title>
     <methodsynopsis>
      <type>string</type><methodname>session_encode</methodname>
      <void/>
     </methodsynopsis>
    <para>
     <function>session_encode</function> restituisce una stringa con i contenuti
     della sessione corrente codificati.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.session-set-save-handler">
   <refnamediv>
    <refname>session_set_save_handler</refname>
    <refpurpose>
     Imposta le funzioni di archiviazione sessioni a livello utente
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descrizione</title>
     <methodsynopsis>
      <type>void</type><methodname>session_set_save_handler</methodname>
      <methodparam><type>string</type><parameter>open</parameter></methodparam><methodparam><type>string</type><parameter>close</parameter></methodparam><methodparam><type>string</type><parameter>read</parameter></methodparam><methodparam><type>string</type><parameter>write</parameter></methodparam><methodparam><type>string</type><parameter>destroy</parameter></methodparam><methodparam><type>string</type><parameter>gc</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>session_set_save_handler</function> imposta le funzioni di 
     archiviazione sessioni che sono usate per archiviare e riutilizzare
     i dati associati a una sessione. Ciò non è molto utile
     quando un altro metodo di archiviazione è preferito a quelli forniti
     dalle sessioni PHP.  i.e. L'archiviazione dei dati di sessione in un database locale.
    </para>
    <note>
     <para>
      Dovete impostare l'opzione di configurazione
      <parameter>session.save_handler</parameter> per 
      <parameter>user</parameter> nel vostro file php.ini perchè
      <function>session_set_save_handler</function> abbia effetto.
     </para>
    </note>
    <note>
     <para>
      L'handler "write" non viene eseguito fino a che l'output stream
      non viene chiuso. In questo modo, l'output di espressioni di debugging
      nell'hanlder "write" non si vedrà mai nel browser. Se l'output di debugging 
      è necessario, è consigliabile che l'output del debug venga scritto 
      in un file.
     </para>
    </note>
    <para>
     Il seguente esempio fornisce l'archiviazione di sessione 
     basata su file simile al solito gestore di salvataggio di sessioni PHP
     <parameter>files</parameter>.  Questo esempio potrebbe essere facilmente 
     esteso per coprire l'archiviazione in database usando il vostro sistema
     database favorito con supporto PHP.
    </para>
    <para>
     La funzione di lettura deve restituire sempre un valore stringa
     perchè il save handler funzioni a dovere. Restituisce una stringa vuota
     se non ci sono dati da leggere. I valori restituiti da altri handlers sono convertiti in
     espressioni booleane. TRUE per successo, FALSE in caso di fallimento.
    </para>
    <para>
     <example>
      <title>
       <function>session_set_save_handler</function> esempio
      </title>
      <programlisting role="php">
<![CDATA[
<?php
function open ($save_path, $session_name) {
  global $sess_save_path, $sess_session_name;
       
  $sess_save_path = $save_path;
  $sess_session_name = $session_name;
  return(true);
}

function close() {
  return(true);
}

function read ($id) {
  global $sess_save_path, $sess_session_name;

  $sess_file = "$sess_save_path/sess_$id";
  if ($fp = @fopen($sess_file, "r")) {
    $sess_data = fread($fp, filesize($sess_file));
    return($sess_data);
  } else {
    return(""); // Deve restituire "" qui.
  }

}

function write ($id, $sess_data) {
  global $sess_save_path, $sess_session_name;

  $sess_file = "$sess_save_path/sess_$id";
  if ($fp = @fopen($sess_file, "w")) {
    return(fwrite($fp, $sess_data));
  } else {
    return(false);
  }

}

function destroy ($id) {
  global $sess_save_path, $sess_session_name;
       
  $sess_file = "$sess_save_path/sess_$id";
  return(@unlink($sess_file));
}

/*********************************************
 * ATTENZIONE - Qui avete bisogno di implementare qualche *
 * sorta di routine per il cestinaggio.  *
 *********************************************/
function gc ($maxlifetime) {
  return true;
}

session_set_save_handler ("open", "close", "read", "write", "destroy", "gc");

session_start();

// proceed to use sessions normally

?>
]]>
      </programlisting>
     </example>
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.session-cache-limiter">
   <refnamediv>
    <refname>session_cache_limiter</refname>
    <refpurpose>Assume o imposta il limitatore di cache corrente</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descrizione</title>
     <methodsynopsis>
      <type>string</type><methodname>session_cache_limiter</methodname>
      <methodparam choice="opt"><type>string</type><parameter>cache_limiter</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>session_cache_limiter</function> restituisce il nome del limitatore
     di cache corrente. Se <parameter>cache_limiter</parameter> è
     specificato, il nome del limitatore di cache corrente viene cambiato
     nel nuovo valore.
    </para>
    <para>
     Il limitatore di cache controlla la cache degli headers HTTP mandati
     al client. Questi headers determinano i modi in cui il contenuto della 
     pagina possono essere depositati. Impostando il limitatore di cache a
     <literal>nocache</literal>, per esempio, non permetterebbe nessun caching
     lato client. Un valore di <literal>public</literal>, invece, permetterebbe il caching.  
     Può anche essere impostato a <literal>private</literal>, che è leggermente più restrittivo di
     <literal>public</literal>.
    </para>
    <para>
     Nella modalità <literal>private</literal> , l'header Expire mandato al 
     client, potrebbe causare confusione per alcuni browser incluso Mozilla.
     Potete evitare questo problema con la modalità
     <literal>private_no_expire</literal> . In questo modo l'header Expire non
     viene mai spedito al client.
    </para>
    <note>
     <para>
      <literal>private_no_expire</literal> è stato aggiunto in PHP 4.2.0dev.
     </para>
    </note>
    <para>
     Il limitatore di cache è resettato al valore di default archiviato in
     <literal>session.cache_limiter</literal> alla richiesta iniziale. Per questo motivo,
     avete bisogno di chiamare <function>session_cache_limiter</function> per ogni
     richiesta (e prima che <function>session_start</function> sia chiamata).
    </para>
    <example>
     <title><function>session_cache_limiter</function> esempi</title>
     <programlisting role="php">
<![CDATA[
<?php

# set the cache limiter to 'private'

session_cache_limiter('private');
$cache_limiter = session_cache_limiter();

echo "Il limitatore di cache è adesso impostato a $cache_limiter<p>";
?>
]]>
     </programlisting>
    </example>
   </refsect1>
  </refentry>

  <refentry id='function.session-cache-expire'>
   <refnamediv>
    <refname>session_cache_expire</refname>
    <refpurpose>Restituisce l'espirazione della cache corrente</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descrizione</title>
     <methodsynopsis>
      <type>int</type><methodname>session_cache_expire</methodname>
      <methodparam choice="opt"><type>int</type><parameter>new_cache_expire</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>session_cache_expire</function> restituisce l'espirazione della cache corrente.
     Se è data <parameter>new_cache_expire</parameter> , l'espirazione della
     cache corrente è rimpiazzata da <parameter>new_cache_expire</parameter>.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.session-write-close">
   <refnamediv>
    <refname>session_write_close</refname>
    <refpurpose>Scrive i dati di sessione e termina la sessione</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descrizione</title>
     <methodsynopsis>
      <type>void</type><methodname>session_write_close</methodname>
      <void/>
     </methodsynopsis>
    <para>
     Termina la sessione corrente e archivia i dati di sessione.
    </para>
    <para>
     I dati di sessione sono di solito archiviati dopo che il vostro script
     è terminato senza il bisogno di chiamare <function>session_write_close</function>, 
     ma poichè i dati di sessione vengono bloccati per prevenire scritture contemporanee
     solo uno script può operare su una sessione in qualsiasi momento.
     Quando utilizzerete i framesets assieme alla sessione vedrete che 
     i frames vengono caricati uno per uno a causa di questo bloccaggio.
     Potete ridurre il tempo necessario per caricare tutti i frames
     terminando la sessione appena tutti i cambi alle variabili di sessione
     sono stati fatti.
    </para>
<!-- commented out until final decision on implementation
    <para>
     See also: <function>session_readonly</function>.
    </para>
-->
   </refsect1>
  </refentry>

<!-- commented out until final decision on implementation
  <refentry id="function.session-readonly">
   <refnamediv>
    <refname>session_readonly</refname>
    <refpurpose>Begin session - reinitializes freezed variables, but no writeback on request end</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
      <type>void</type><methodname>session_readonly</methodname>
      <void/>
     </methodsynopsis>
    <para>
     Read in session data without locking the session data. Changing
     session data is not possible, but frameset performance will be improved.
    </para>
   </refsect1>
  </refentry>
-->
 </reference>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
