<?xml version="1.0" encoding="iso-8859-1"?>
 <reference id="ref.sockets">
  <title>Funzioni relative ai Socket</title>
  <titleabbrev>Sockets</titleabbrev>

  <partintro>
	   &warn.experimental;
   <simpara>
    Questa estensione implementa una interfaccia a basso livello
    verso i socket, fornendo la possibilità di agire sia come
    server sia come client.
   </simpara>
   <para>
    Le funzioni relative ai socket qui descritte, sono parte di una estensione
    di PHP che deve essere abilitata durante la fase di compila tramite
    l'opzione <option role="configure">--enable-sockets</option> di 
    <command>configure</command>.
   </para>
   <para>
    Per un esempio di una interfaccia generica lato client, 
    vedere <function>fsockopen</function> e
    <function>pfsockopen</function>.
   </para>
   <para>
    Per l'utilizzo di queste funzioni, è importante ricordare che
    molte di esse hanno il medesimo nome della loro controparte in C,
    ma spesso hanno dichiarazioni differenti. Ricordarsi di leggere
    la descrizione per evitare confusione.
   </para>
   <para>
    Per chi non ha famigliarità con la programmazione dei socket, può 
    trovare utili informazioni nelle pagine del manuale di Unix, ed inoltre
    sul web si può trovare diversi tutorial sulla programmazione
    dei socket in C, molti dei quali possono essere utilizzati, con
    lievi modifiche, nella programmazione dei socket in PHP.
   </para>
   <para>
    <example>
     <title>Esempio di programma con i socket: semplice server TCP/IP</title>
     <para>
      Questo esempio mostra un semplice server. Occorre modificare
      le variabili <varname>address</varname> e <varname>port</varname>
      per adeguarle ai parametri della macchina su cui sarà eseguito.  Ci si può
      connettere al server con un comando simile a <command>telnet 192.168.1.53
      10000</command> (dove l'indirizzo e la porta devono essere uguali a quanto
      indicato nel setup). Qualsiasi lettara sarà digitata, verrà visualizzata sul server
      e sul client. Per disconnettersi digitare 'quit'.
     </para>
     <programlisting role="php">
<![CDATA[
#!/usr/local/bin/php -q
<?php
error_reporting (E_ALL);

/* Si indica allo script di non uscire mentre attende una connessione */
set_time_limit (0);

/* Abilita lo scarico dell'output così si è in grado di vedere cosa passa
 * non appena arrivano i dati al server. */
ob_implicit_flush ();

$address = '192.168.1.53';
$port = 10000;

if (($sock = socket_create (AF_INET, SOCK_STREAM, 0)) < 0) {
    echo "socket_create() fallito: motivo: " . socket_strerror ($sock) . "\n";
}

if (($ret = socket_bind ($sock, $address, $port)) < 0) {
    echo "socket_bind() fallito: motivo: " . socket_strerror ($ret) . "\n";
}

if (($ret = socket_listen ($sock, 5)) < 0) {
    echo "socket_listen() fallito: motivo: " . socket_strerror ($ret) . "\n";
}

do {
    if (($msgsock = socket_accept($sock)) < 0) {
        echo "socket_accept() fallito: motivo: " . socket_strerror ($msgsock) . "\n";
        break;
    }
    /* Invio delle istruzioni */
    $msg = "\nBenvenuti al server di test in PHP. \n" .
        "Per uscire, digitare 'quit'. Per chiudere il server digitare 'shutdown'.\n";
    socket_write($msgsock, $msg, strlen($msg));

    do {
        if (FALSE === ($buf = socket_read ($msgsock, 2048))) {
            echo "socket_read() fallito: motivo: " . socket_strerror ($ret) . "\n";
            break 2;
        }
        if (!$buf = trim ($buf)) {
            continue;
        }
        if ($buf == 'quit') {
            break;
        }
        if ($buf == 'shutdown') {
            socket_close ($msgsock);
            break 2;
        }
        $talkback = "PHP: Testo scritto '$buf'.\n";
        socket_write ($msgsock, $talkback, strlen ($talkback));
        echo "$buf\n";
    } while (true);
    socket_close ($msgsock);
} while (true);

socket_close ($sock);
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    <example>
     <title>Esempio di programma con i socket: semplice client TCP/IP</title>
     <para>
      In questo esempio sarà illustrato un semplice client HTTP. Questo,
      molto semplicemente, si collega ad un server, invia una richiesta HEAD,
      visualizza la risposta ed esce.
     </para>
     <programlisting>
<![CDATA[
<?php
error_reporting (E_ALL);

echo "<h2>Connessione TCP/IP </h2>\n";

/* Ottiene la porta per il servizio WWW. */
$service_port = getservbyname ('www', 'tcp');

/* Ottiene l'indirizzo IP per il server cercato. */
$address = gethostbyname ('www.php.net');

/* Crea un socket TCP/IP. */
$socket = socket_create (AF_INET, SOCK_STREAM, 0);
if ($socket < 0) {
    echo "socket_create() fallito: motivo: " . socket_strerror ($socket) . "\n";
} else {
    echo "OK.\n";
}

echo "Tentativo di connessione a '$address' sulla porta '$service_port'...";
$result = socket_connect ($socket, $address, $service_port);
if ($result < 0) {
    echo "socket_connect() fallito.\nMotivo: ($result) " . socket_strerror($result) . "\n";
} else {
    echo "OK.\n";
}

$in = "HEAD / HTTP/1.0\r\n\r\n";
$out = '';

echo "Invio HTTP HEAD...";
socket_write ($socket, $in, strlen ($in));
echo "OK.\n";

echo "Lettura della risposta:\n\n";
while ($out = socket_read ($socket, 2048)) {
    echo $out;
}

echo "Chiusura del socket...";
socket_close ($socket);
echo "OK.\n\n";
?>
]]>
      </programlisting>
     </example>
    </para>
  </partintro>








































&reference.sockets.functions;

 </reference>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->

