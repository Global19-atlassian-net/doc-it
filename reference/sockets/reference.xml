<?xml version="1.0" encoding="iso-8859-1"?>
<!-- EN-Revision: 1.19 Maintainer: darvina Status: ready -->
 <reference id="ref.sockets">
  <title>Funzioni relative ai Socket</title>
  <titleabbrev>Sockets</titleabbrev>

  <partintro>

   <section id="sockets.intro">
    &reftitle.intro;
    <para>
     Questa estensione implementa una interfaccia a basso livello
     verso i socket, fornendo la possibilità di agire sia come
     server sia come client.
    </para>
    <para>
     Per un esempio di una interfaccia generica lato client, 
     vedere <function>stream_socket_client</function>,
     <function>stream_socket_server</function>,
     <function>fsockopen</function> e
     <function>pfsockopen</function>.
    </para>
    <para>
     Per l'utilizzo di queste funzioni, è importante ricordare che
     molte di esse hanno il medesimo nome della loro controparte in C,
     ma spesso hanno dichiarazioni differenti. Ricordarsi di leggere
     la descrizione per evitare confusione.
    </para>
    <para>
     Per chi non ha familiarità con la programmazione dei socket, può 
     trovare utili informazioni nelle pagine del manuale di Unix, ed inoltre
     sul web si può trovare diversi tutorial sulla programmazione
     dei socket in C, molti dei quali possono essere utilizzati, con
     lievi modifiche, nella programmazione dei socket in PHP. Il link <ulink url="&url.socket.faq;">Unix Socket
     FAQ</ulink> può essere un buon punto di partenza.
    </para>
    &warn.experimental;
   </section>

   <section id="sockets.requirements">
    &reftitle.required;
    &no.requirement;
   </section>
   &reference.sockets.configure;
   
   <section id="sockets.configuration">
    &reftitle.runtime;
    &no.config;
   </section>

   <section id="sockets.resources">
    &reftitle.resources;
    &no.resource;
   </section>

   &reference.sockets.constants;

   <section id="sockets.errors">
    <title>Errori dei socket</title>
    <para>
     L'estensione dei socket è stata scritta per fornire una pratica interfaccia
     ai potenti socket BSD. Si noti che le funzioni girano correttamente
     sia su sistemi Unix sia su sistemi Win32. Quasi tutte le funzioni dei socket
     possono fallire in certe situazioni e quindi generare un messaggio di tipo
     <constant>E_WARNING</constant> per descrivere l'errore. Qualche volta 
     ciò non accade secondo le aspettative dello sviluppatore. Ad esempio la funzione
     <function>socket_read</function> improvvisamente può generare un messaggio di 
     <constant>E_WARNING</constant> a causa di una interruzione inaspettata della
     connessione. E' prassi comune sopprimere i messaggi di warning con l'operatore
     <literal>@</literal> ed intercettare il codice dell'errore utilizzando
     la funzione <function>socket_last_error</function>. Si può anche richiamare
     la funzione <function>socket_strerror</function> con questo codice di errore
     per avere un testo descrittivo del problema. Per maggiori dettagli vedere la descrizione
     delle funzioni.
    </para>
    <note>
     <para>
      I messaggi <constant>E_WARNING</constant> generati dal modulo dei
      socket sono in inglese, mentre i messaggi di errore recuperati dipendono
      dalle correnti impostazioni locali (<constant>LC_MESSAGES</constant>):
      <programlisting role="php">
<![CDATA[
Warning - socket_bind() unable to bind address [98]: Die Adresse wird bereits verwendet
]]>
      </programlisting>
     </para>
    </note>
   </section>

   <section id="sockets.examples">
    &reftitle.examples;
    <para>
     <example>
      <title>Esempio di programma con i socket: semplice server TCP/IP</title>
      <para>
       Questo esempio illustra un semplice server. Occorre modificare
       le variabili <varname>address</varname> e <varname>port</varname>
       per adeguarle ai parametri della macchina su cui sarà eseguito.  Ci si può
       connettere al server con un comando simile a <command>telnet 192.168.1.53
       10000</command> (dove l'indirizzo e la porta devono essere uguali a quanto
       indicato nel setup). Qualsiasi lettera sarà digitata, verrà visualizzata sul server
       e sul client. Per disconnettersi, digitare 'quit'.
      </para>
      <programlisting role="php">
<![CDATA[
#!/usr/local/bin/php -q
<?php
error_reporting(E_ALL);

/* Si indica allo script di non uscire mentre attende una connessione */
set_time_limit(0);

/* Abilita lo scarico dell'output così si è in grado di vedere cosa passa
 * non appena arrivano i dati al server. */
ob_implicit_flush();

$address = '192.168.1.53';
$port = 10000;

if (($sock = socket_create(AF_INET, SOCK_STREAM, SOL_TCP)) < 0) {
    echo "socket_create() fallito: motivo: " . socket_strerror($sock) . "\n";
}

if (($ret = socket_bind($sock, $address, $port)) < 0) {
    echo "socket_bind() fallito: motivo: " . socket_strerror($ret) . "\n";
}

if (($ret = socket_listen($sock, 5)) < 0) {
    echo "socket_listen() fallito: motivo: " . socket_strerror($ret) . "\n";
}

do {
    if (($msgsock = socket_accept($sock)) < 0) {
        echo "socket_accept() fallito: motivo: " . socket_strerror ($msgsock) . "\n";
        break;
    }
    /* Invio delle istruzioni */
    $msg = "\nBenvenuti al server di test in PHP. \n" .
        "Per uscire, digitare 'quit'. Per chiudere il server digitare 'shutdown'.\n";
    socket_write($msgsock, $msg, strlen($msg));

    do {
        if (FALSE === ($buf = socket_read($msgsock, 2048, PHP_NORMAL_READ))) {
            echo "socket_read() fallito: motivo: " . socket_strerror($ret) . "\n";
            break 2;
        }
        if (!$buf = trim($buf)) {
            continue;
        }
        if ($buf == 'quit') {
            break;
        }
        if ($buf == 'shutdown') {
            socket_close($msgsock);
            break 2;
        }
        $talkback = "PHP: Testo scritto '$buf'.\n";
        socket_write($msgsock, $talkback, strlen $talkback));
        echo "$buf\n";
    } while (true);
    socket_close($msgsock);
} while (true);

socket_close($sock);
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     <example>
      <title>Esempio di programma con i socket: semplice client TCP/IP</title>
      <para>
       In questo esempio sarà illustrato un semplice client HTTP. Questo,
       molto semplicemente, si collega ad un server, invia una richiesta HEAD,
       visualizza la risposta ed esce.
      </para>
      <programlisting role="php">
<![CDATA[
<?php
error_reporting(E_ALL);

echo "<h2>Connessione TCP/IP </h2>\n";

/* Ottiene la porta per il servizio WWW. */
$service_port = getservbyname('www', 'tcp');

/* Ottiene l'indirizzo IP per il server cercato. */
$address = gethostbyname('www.php.net');

/* Crea un socket TCP/IP. */
$socket = socket_create(AF_INET, SOCK_STREAM, SOL_TCP);
if ($socket < 0) {
    echo "socket_create() fallito: motivo: " . socket_strerror($socket) . "\n";
} else {
    echo "OK.\n";
}

echo "Tentativo di connessione a '$address' sulla porta '$service_port'...";
$result = socket_connect($socket, $address, $service_port);
if ($result < 0) {
    echo "socket_connect() fallito.\nMotivo: ($result) " . socket_strerror($result) . "\n";
} else {
    echo "OK.\n";
}
$in = "HEAD / HTTP/1.1\r\n"; 
$in .= "Host: www.example.com\r\n"; 
$in .= "Connection: Close\r\n\r\n";
$out = '';

echo "Invio HTTP HEAD...";
socket_write($socket, $in, strlen ($in));
echo "OK.\n";

echo "Lettura della risposta:\n\n";
while ($out = socket_read($socket, 2048)) {
    echo $out;
}

echo "Chiusura del socket...";
socket_close($socket);
echo "OK.\n\n";
?>
]]>
      </programlisting>
     </example>
    </para>
   </section>
  </partintro>


&reference.sockets.functions;

 </reference>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->

