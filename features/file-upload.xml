<?xml version="1.0" encoding="iso-8859-1"?>
<!-- EN-Revision: 1.59 Maintainer: donelli Status: ready -->
 <chapter id="features.file-upload">
  <title>Caricare file</title>

  <sect1 id="features.file-upload.post-method">
   <title>Metodo POST per caricamento di file</title>

   <simpara>
    PHP è in grado di ricevere file caricati da qualsiasi browser compatibile
    con le specifiche RFC-1867 (che comprende Netscape Navigator 3 o successivo,
    Microsoft Internet Explorer 3 con una modifica di Microsoft, o
    versioni successive senza modifica). Questa caratteristica permette di caricare sia file di testo
    che binari.  Utilizzando le funzioni di PHP per l'autenticazione e manipolazione dei file,
    è possibile avere pieno controllo su chi ha i permessi per caricare un file e su
    ciò che deve essere fatto una volta che il file è stato caricato.
   </simpara>

   <note>
     <title>Note relative alla configurazione</title>
     <para>
      Si vedano i parametri <link linkend="ini.file-uploads">file_uploads</link>,
      <link linkend="ini.upload-max-filesize">upload_max_filesize</link>,
      <link linkend="ini.upload-tmp-dir">upload_tmp_dir</link>, e
      <link linkend="ini.post-max-size">post_max_size</link>
      nel &php.ini;
     </para>
    </note>

   <para>
    Si noti che PHP permette l'upload di file con metodo PUT come utilizzato dai
    programmi Netscape Composer e W3C Amaya. Si veda <link
    linkend="features.file-upload.put-method">Supporto per metodo PUT
    </link> per maggiori dettagli.
   </para>
   <para>
    La schermata di caricamento di un file può essere costruita con una form
    particolare, di questo tipo:
    <example>
     <title>Form di caricamento file</title>
     <programlisting role="html">
<![CDATA[
<form enctype="multipart/form-data" action="_URL_" method="post">
<input type="hidden" name="MAX_FILE_SIZE" value="30000">
Invia questo file: <input name="userfile" type="file">
<input type="submit" value="Invia File">
</form>
]]>
     </programlisting>
    </example>
    Il valore della action _URL_ dovrebbe puntare a un file PHP.  Il campo nascosto MAX_FILE_SIZE
    deve precedere il campo di immissione del file e il suo valore è la
    dimensione massima accettata del file.  Il valore è in byte.
    <warning>
     <para>
      Il valore MAX_FILE_SIZE è consigliato al browser. E' facile aggirare 
      questo valore, quindi non fate affidamento sul fatto che il
      navigatore si comporti come desiderato! L'impostazione PHP lato server per la dimensione
      massima non può comunque essere aggirata. Tuttavia si può comunque inserire
      MAX_FILE_SIZE per evitare all'utente di attendere il trasferimento di un file
      prima di scoprire che è di dimensioni eccessive.
     </para>
   </warning>
   </para>
 
   <para>
    Le variabili definite per i file inviati differiscono in base
    alla versione di PHP ed alla configurazione. La variabile globale
    <link linkend="reserved.variables.files">$_FILES</link>
    esiste a partire dalla versione 4.1.0 di PHP. La matrice
    <varname>$HTTP_POST_FILES</varname> esiste dalla versione 4.0.0.
    Tutte queste matrici conterranno tutte le informazioni dei file inviati.
    Si consiglia di preferire l'uso di <varname>$_FILES</varname>.
    Se il parametro <link linkend="ini.register-globals">register_globals</link> è
    impostato a <emphasis>on</emphasis>, esisteranno anche le relative variabili.
    Attenzione che per default il parametro  <link linkend="ini.register-globals">register_globals</link>
    viene impostato a <emphasis>off</emphasis> dalla versione <ulink url="&url.php.release4.2.0;">4.2.0</ulink>
    di PHP.
   </para>
   <para>
    Di seguito verrà illustrato il contenuto di
    <link linkend="reserved.variables.files">$_FILES</link> nel caso dell'esempio precedente. Si
    noti che si assume come nome del file inviato <emphasis>userfile</emphasis>, come nell'esempio
    precedente.
    <variablelist>
     <varlistentry>
      <term><varname>$_FILES['userfile']['name']</varname></term>
      <listitem>
       <para>
        Il nome originale del file sulla macchina dell'utente.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><varname>$_FILES['userfile']['type']</varname></term>
      <listitem>
       <para>
        Il mime-type del file, se il browser fornisce questa informazione. 
	Un esempio potrebbe essere <literal>"image/gif"</literal>.
        </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><varname>$_FILES['userfile']['size']</varname></term>
      <listitem>
       <para>
        La dimensione, in bytes, del file caricato.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><varname>$_FILES['userfile']['tmp_name']</varname></term>
      <listitem>
       <para>
        Il nome del file temporaneo in cui il file caricato è salvato 
	sul server.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><varname>$_FILES['userfile']['error']</varname></term>
      <listitem>
       <para>
        Il <link linkend="features.file-upload.errors">codice di errore</link>
        associato all'upload di questo file. Il campo <emphasis>['error']</emphasis>
        è stato aggiunto nella versione 4.2.0 di PHP.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
   <note> 
    <para> 
     Nelle versioni di PHP precedenti alla 4.1.0 questa variabile era chiamata
     <varname>$HTTP_POST_FILES</varname> e non era una variabile
     <link linkend="language.variables.superglobals">autoglobal</link> 
     come è <varname>$_FILES</varname>. La versione 3 di PHP non supporta
     <varname>$HTTP_POST_FILES</varname>. 
    </para> 
   </note> 
   
   <para> 
    Quando <link linkend="ini.register-globals">register_globals</link> 
    è impostato a <emphasis>on</emphasis> nel &php.ini;, sono disponibili 
    variabili addizionali. Da esempio,
    <varname>$userfile_name</varname> sarà uguale a
    <varname>$_FILES['userfile']['name']</varname>, 
    <varname>$userfile_type</varname> sarà uguale a
    <varname>$_FILES['userfile']['type']</varname>, eccetera. Si ricordi 
    che a partire dalla versione 4.2.0 di PHP il parametro register_globals viene impostato a off per default.
    E' preferibile non fare affidamento su questo parametro.
   </para>

   <para>
    I file sono, di default, salvati in una directory temporanea sul server, a meno 
    che un diverso percorso sia specificato nella direttiva <link
    linkend="ini.upload-tmp-dir">upload_tmp_dir</link> nel file 
    &php.ini;. La directory del server predefinita può essere 
    cambiata impostando la variabile di ambiente <envar>TMPDIR</envar> in cui 
    è in esecuzione PHP. Non è possibile impostare questa variabile utilizzando 
    la funzione <function>putenv</function> da uno script PHP. 
    Questa variabile di ambiente può anche essere usata per assicurarsi che
    anche altre operazioni stiano lavorando sui file caricati.
        <example>
     <title>Verifica dell'upload di file</title>
     <para>
      Si vedano le definizioni delle funzioni <function>is_uploaded_file</function> e
      <function>move_uploaded_file</function> per maggiori dettagli.
      L'esempio seguente illustra il processamento di un file inviato tramite un
      form.
     </para>
     <programlisting role="php">
<![CDATA[
<?php
// Nelle versioni di PHP precedenti alla 4.1.0 si deve utilizzare  $HTTP_POST_FILES anzichè $_FILES.
// Nelle versioni di PHP precedenti alla 4.0.3, si utilizzi copy() e is_uploaded_file() anzichè move_uploaded_file

$uploaddir = '/var/www/uploads/';
print "<pre>";
if (move_uploaded_file($_FILES['userfile']['tmp_name'], $uploaddir . $_FILES['userfile']['name'])) { 
    print "Il file è valido, e inviato con successo.  Ecco alcune informazioni:\n"; 
    print_r($_FILES);
} else {
    print "Possibile attacco tramite file upload! Alcune informazioni:\n"; 
    print_r($_FILES);
}
 
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Lo script PHP che riceve il file caricato dovrebbe implementare la  
    logica necessaria per determinare cosa deve essere fatto con il file 
    caricato.  E' possibile, per esempio, utilizzare la variabile 
    <varname>$_FILES['userfile']['size']</varname> per eliminare file che siano troppo 
    grandi o troppo piccoli.  E' possibile utillizzare la variabile 
    <varname>$_FILES['userfile']['type']</varname> per eliminare tutti i file che non soddisfano certi criteri. 
    A partire da PHP 4.2.0, si può utilizzare <varname>$_FILES['userfile']['error']</varname> 
    ed organizzare la logica in base ai <link 
    linkend="features.file-upload.errors">codici di errore</link>.
    Quale che sia la logica, bisognerebbe comunque sempre
    cancellare il file dalla directory temporanea e spostarlo da qualche
    altra parte.
   </simpara>
   <simpara>
    Il file sarà eliminato dalla directory temporanea al termine della richiesta
     se non è stato mosso e rinominato.
   </simpara>
  </sect1>
 
  <sect1 id="features.file-upload.errors"> 
   <title>Spiegazione dei messaggi di errore</title> 
    <simpara> 
    Dalla versione 4.2.0, il PHP restituisce un codice di errore nella matrice del file.
    Il codice di errore si trova nell'indice <emphasis>['error']</emphasis>
    e viene valorizzato durante
    l'upload del file da parte del PHP. In altre parole l'errore può essere 
    trovato in <varname>$_FILES['userfile']['error']</varname>. 
   </simpara> 
    <para> 
     <variablelist> 
      <varlistentry> 
       <term><varname>UPLOAD_ERR_OK</varname></term> 
        <listitem> 
         <para> 
         Valore: 0; Non vi sono errori, l'upload è stato eseguito con successo.
       </para> 
      </listitem> 
     </varlistentry> 
     <varlistentry> 
      <term><varname>UPLOAD_ERR_INI_SIZE</varname></term> 
      <listitem> 
       <para> 
        Valore: 1; Il file inviato eccede le dimensioni specificate nel parametro
        <link linkend="ini.upload-max-filesize">upload_max_filesize</link> 
        di &php.ini;. 
        </para> 
       </listitem> 
      </varlistentry> 
      <varlistentry> 
      <term><varname>UPLOAD_ERR_FORM_SIZE</varname></term> 
      <listitem> 
       <para> 
        Valore: 2; Il file inviato eccede le dimensioni specificate
        nel parametro <emphasis>MAX_FILE_SIZE</emphasis> del form.
       </para> 
      </listitem> 
      </varlistentry> 
      <varlistentry> 
       <term><varname>UPLOAD_ERR_PARTIAL</varname></term> 
       <listitem> 
         <para> 
         Valore: 3; Upload eseguito parzialmente. 
        </para> 
       </listitem> 
      </varlistentry> 
      <varlistentry> 
       <term><varname>UPLOAD_ERR_NO_FILE</varname></term> 
       <listitem> 
        <para> 
         Valore: 4; Nessun file è stato inviato. 
       </para> 
       </listitem> 
      </varlistentry> 
     </variablelist> 
    </para> 
    <note> 
     <para> 
      Questi valori sono diventate costanti PHP a partire dal PHP 4.3.0. 
     </para> 
    </note> 
   </sect1>

  <sect1 id="features.file-upload.common-pitfalls">
   <title>Common Pitfalls</title>
   <simpara>
    La voce <literal>MAX_FILE_SIZE</literal> non può specificare una dimensione del 
     file maggiore di quella impostata dal parametro <link
    linkend="ini.upload-max-filesize">upload_max_filesize</link> del file php.ini.
    L'impostazione di default è 2 Megabytes.
   </simpara>
   <simpara>
    Se si è impostato un limite di memoria <link
    linkend="ini.memory-limit">memory_limit</link> può essere necessario ampliarlo. 
    Occorre essere certi di impostare <link linkend="ini.memory-limit">memory_limit</link>
    alle dimensioni appropriate.
   </simpara>
   <simpara>
    Se <link linkend="ini.max-execution-time">max_execution_time</link>
    è impostato ad un valore basso, l'esecuzione dello script può eccedere tale valore.
    Ampliare <literal>max_execution_time</literal> ad un tempo sufficiente per l'upload.
   </simpara>
   <note>
    <simpara>
     <link linkend="ini.max-execution-time">max_execution_time</link> influisce solo
     sul tempo di esecuzione dello script. Il tempo utilizzato per attività
     esterno allo script, tipo le chiamate di sistema
     <function>system</function>, o la funzione 
     <function>sleep</function>, le query nei database, il tempo inpiegato
     nell'upload del file non è considerato nel computo del tempo
     di esecuzione dello script.
    </simpara>
   </note>
   <simpara>
    Se <link linkend="ini.post-max-size">post_max_size</link> è impostato ad un valore
    troppo piccolo, non si può inviare file di grosse dimensioni.
    Impostare <literal>post_max_size</literal> alle dimensioni appropriate.
   </simpara>
 
   <simpara>
    Non controllare il file su cui si sta operando potrebbe dare agli utenti 
	accesso a informazioni sensibili contenute in altre directory.
   </simpara>
   <simpara>
    Si noti che che il server http CERN sembra eliminare qualsiasi cosa a partire
    dal primo spazio nell'header mime content-type che riceve dal client.
    Fino a che questo si verificherà, il server http CERN non supporterà la possibilità
    di caricare file.
   </simpara>
 
   <simpara>
    A causa della varietà di formati di directory, non si è in grado di
    garantire che nomi di file strani (ad esempio contenenti spazi) siano gestiti correttamente.
   </simpara>
  </sect1>

  <sect1 id="features.file-upload.multiple">
   <title>Caricamento di più file</title>
   <simpara>
    E' possibile inviare più file contemporanemante utilizzando in
    <literal>input</literal> <literal>nomi</literal> differenti.
   </simpara>
   <simpara>
    E' possibile caricare più file contemporaneamente e avere 
    le informazioni organizzate automaticamente in array. Per questo 
    è necessario utilizzare la medesima sintassi di invio di array da form HTML che 
	è utilizzata con select e checkbox multipli:
  </simpara>
   <note>
    <para>
     Il supporto per il caricamento di file multipli è presente dalla versione 3.0.10.
    </para>
   </note>
   <para>
    <example>
     <title>Caricamento di più file</title>
     <programlisting role="html">
<![CDATA[
<form action="file-upload.php" method="post" enctype="multipart/form-data">
  Send these files:<br>
  <input name="userfile[]" type="file"><br>
  <input name="userfile[]" type="file"><br>
  <input type="submit" value="Send files">
</form>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Quando la form è inviata, gli array
    <varname>$_FILES['userfile']</varname>,
    <varname>$_FILES['userfile']['name']</varname>, e
    <varname>$_FILES['userfile']['size']</varname> saranno
    inizializzati (come sarà valorizzato $HTTP_POST_FILES
    per le versioni di PHP precedenti la 4.1.0).
    Quando il parametro  <literal>register_globals</literal> è impostato a on
    saranno presenti anche le variabili globali. Ognuno di questi è un array indicizzato numericamente 
    con i valori relativi ai diversi file caricati.
   </simpara>
   <simpara>
    Per esempio, si supponga che i nomi di file
    <filename>/home/test/review.html</filename> e
    <filename>/home/test/xwp.out</filename> siano inviati.  In questo 
    caso, <varname>$_FILES['userfile']['name'][0]</varname> conterrebbe
    il valore <filename>review.html</filename>,
    e <varname>$_FILES['userfile']['name'][1]</varname> conterrebbe
    il valore
    <filename>xwp.out</filename>. Analogamente,
    <varname>$_FILES['userfile']['size'][0]</varname> conterrebbe la dimensione di 
    <filename>review.html</filename>, e così via.
   </simpara>
   <simpara>
   	Anche
    <varname>$_FILES['userfile']['name'][0]</varname>,
    <varname>$_FILES['userfile']['tmp_name'][0]</varname>,
    <varname>$_FILES['userfile']['size'][0]</varname>, e
    <varname>$_FILES['userfile']['type'][0]</varname> sono impostati.
   </simpara>
  </sect1>

  <sect1 id="features.file-upload.put-method">
   <title>Supporto per metodo PUT</title>
   <simpara>
    Il supporto al metodo PUT è cambiato tra PHP 3 e PHP 4.
    In PHP 4 occorre utilizzare il flusso standard di input per leggere
    il contenuto di un PUT HTTP.
   </simpara>
   <para>
    <example>
     <title>Salvataggio di un file HTTP PUT con PHP 4</title>
      <programlisting role="php">
<![CDATA[
<?php
/* I dati PUT arrivano in stdin */
$putdata = fopen("php://stdin","r");
 
/* Apertura del file in scrittura */
$fp = fopen("myputfile.ext","w");
/* Lettura dei dati d 1kb alla volta e scrittura nel file */
while ($data = fread($putdata,1024))
  fwrite($fp,$data);
 
/* Chiusura */
fclose($fp);
fclose($putdata);
?>
]]>
     </programlisting>
    </example>
   </para>
   <note>
    <para>
     Tutta la documentazione che segue si applica solo a PHP 3. 
    </para>
   </note>
   <para>
    PHP fornisce supporto per il metodo HTTP PUT utilizzato da programmi 
    come Netscape Composer e W3C Amaya.  Le richieste PUT sono molto più semplici
    rispetto al caricamento di un file, e assomigliano a 
    <informalexample>
     <programlisting>
PUT /percorso/nomefile.html HTTP/1.1
     </programlisting>
    </informalexample>
   </para>
   <para>
    Questo significa che normalmente il programma remoto intende salvare 
    il contenuto della richesta come : /percorso/nomefile.html nel filesystem sul server web.
    Non è ovviamente una buona idea per Apache o PHP lasciare a un qualsiasi utente la 
    possibilità di sovrascrivere file sul server web.  Quindi, per gestire questa 
    richiesta si deve chiedere al server web che si vuole che sia un certo script PHP a 
    gestire la richiesta stessa. In Apache si ottiene questo con la direttiva
    <emphasis>Script</emphasis>.  Può essere posta quasi ovunque nel file di
    configurazione di Apache.  Un posto frequente è all'interno di un blocco 
     &lt;Directory&gt; oppurte all'interno del blocco 
     &lt;Virtualhost&gt;.  Un linea come la seguente è sufficiente:
    <informalexample>
     <programlisting>
Script PUT /put.php
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Questo chiede ad Apache di inviare tutte le richieste PUT che soddisfano
    il contesto in cui si è inserito questo comando allo script put.php.  Questo 
    richiede, naturalmente, che sia abilitato PHP per l'estensione .php e che 
    PHP sia attivo.
   </simpara>
   <simpara>
    All'interno del file put.php si può inserire qualcosa del tipo:
   </simpara>
   <para>
    <informalexample><programlisting role="php">
<![CDATA[
<?php copy($PHP_UPLOADED_FILE_NAME,$DOCUMENT_ROOT.$REQUEST_URI); ?>
]]>
    </programlisting></informalexample>
   </para>
   <simpara>
    Questo copia il file nella posizione chiesta dal programma
	remoto.  E' probabile che si vogliano effettuare dei controlli o 
	autenticazioni dell'utente prima di effettuare questa copia.  L'unica magia 
    qui presente è che quando PHP vede una richiesta con metodo PUT memorizza il file caricato in 
    un file temporaneo così come per i file caricati con il <link
    linkend="features.file-upload.post-method">metodo POST</link>.
    Quando la richiesta termina, questo file temporaneo è eliminato. Quindi il gestore della
    richiesta PUT deve copiare il file da qualche parte.  Il nome del file temporaneo è 
    memorizzato nella variabile $PHP_PUT_FILENAME, 
	ed è possibile vedere il nome del file di destinazione nella variabile 
    $REQUEST_URI (potrebbe variare su web server diversi da Apache).  Qusto nome di file di 
    destinazione è quello specificato dal client remoto.
    Non è necessario seguire le indicazioni del client.  E' possibile, per esempio,
    copiare tutti i file caricati in una apposita directory.
   </simpara>
  </sect1>

 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
