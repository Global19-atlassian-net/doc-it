<?xml version="1.0" encoding="iso-8859-1"?>
<!-- EN-Revision: 1.42 Maintainer: cortesi Status: ready -->
<!-- CREDITS: matteobug -->
 <chapter xml:id="features.http-auth" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>Autenticazione HTTP usando PHP</title>

  <simpara>
   I meccanismi di Autenticazione <acronym>HTTP</acronym> sono disponibili in PHP solo quando questo
   viene usato come un modulo di Apache ed esso non è quindi disponibile nella versione CGI.
   In uno script PHP modulo di Apache, &egrave; possibile usare la 
   funzione <function>header</function> per inviare un messaggio di "Authentication Required" 
   al browser dell'utente, provocando quindi l'apertura di una finestra contenente una richiesta di
   Nome utente/Password. Una volta che l'utente ha compilato i campi nome utente e password, 
   l'URL contenente lo script PHP verrà richiamato nuovamente usando le 
   <link linkend="reserved.variables">variabili predefinite</link>, <varname>PHP_AUTH_USER</varname>, 
   <varname>PHP_AUTH_PW</varname> e 
   <varname>AUTH_TYPE</varname> impostate con, rispettivamente:
   nome, password e tipo di autenticazione. Queste variabili predefinite possono essere trovate
   negli array <link linkend="reserved.variables.server">$_SERVER</link> e 
   <varname>$HTTP_SERVER_VARS</varname>. Saranno supportati entrambi i 
   metodi di autenticazione, "Basic" e "Digest" (a partire dal PHP 5.1.0).
   Fare riferimento alla funzione <function>header</function>
   per ulteriori informazioni.
  </simpara>
   
  <note>
   <title>Nota sulla versione di PHP</title>
   <para>
    Le <link linkend="language.variables.superglobals">variabili autoglobali</link>, 
    come <link linkend="reserved.variables.server">$_SERVER</link>, esistono 
    a partire da PHP <link xlink:href="&url.php.release4.1.0;">4.1.0</link>. 
    <varname>$HTTP_SERVER_VARS</varname> è disponibile a partire da PHP 3.
   </para>
  </note>

  <para>
   Un frammento di script di esempio che richiede l'autenticazione da parte del browser
   su una pagina, potrebbe essere il seguente:
  </para>
  <para>
   <example>
    <title>Esempio di Autenticazione HTTP "Basic"</title>
    <programlisting role="php">
<![CDATA[
<?php
  if (!isset($_SERVER['PHP_AUTH_USER'])) {
    header('WWW-Authenticate: Basic realm="Il mio realm"');
    header('HTTP/1.0 401 Unauthorized');
    echo 'Messaggio da inviare se si preme il tasto Cancel';
    exit;
  } else {
    echo "<p>Ciao {$_SERVER['PHP_AUTH_USER']}.</p>";
    echo "<p>Hai inserito {$_SERVER['PHP_AUTH_PW']} come tua password.</p>";
  }
?>
]]>
    </programlisting>
   </example>
  </para>
 
  <para>
   <example>
    <title>Esempio di autenticazione HTTP "Digest"</title>
    <para>
     Questo esempio illustra come implementare una autenticazione
     Digest. Per maggiori dettagli vedere <link
      xlink:href="&url.rfc;2617">RFC 2617</link>.
    </para>
    <programlisting role="php">
<![CDATA[
<?php
$realm = 'Restricted area';
 
//user => password
$users = array('admin' => 'mypass', 'guest' => 'guest');
 
 
if (!isset($_SERVER['PHP_AUTH_DIGEST'])) {
    header('HTTP/1.1 401 Unauthorized');
    header('WWW-Authenticate: Digest realm="'.$realm.
           '" qop="auth" nonce="'.uniqid().'" opaque="'.md5($realm).'"');
 
    die('Text to send if user hits Cancel button');
}
 
// analisi della variabile PHP_AUTH_DIGEST
preg_match('/username="(?P<username>.*)",\s*realm="(?P<realm>.*)",\s*nonce="(?P<nonce>.*)",\s*uri="(?P<uri>.*)",\s*response="(?P<response>.*)",\s*opaque="(?P<opaque>.*)",\s*qop=(?P<qop>.*),\s*nc=(?P<nc>.*),\s*cnonce="(?P<cnonce>.*)"/', $_SERVER['PHP_AUTH_DIGEST'], $digest);
 
if (!isset($users[$digest['username']]))
    die('Username not valid!');
 
 
// generazione di una risposta valida
$A1 = md5($digest['username'] . ':' . $realm . ':' . $users[$digest['username']]);
$A2 = md5($_SERVER['REQUEST_METHOD'].':'.$digest['uri']);
$valid_response = md5($A1.':'.$digest['nonce'].':'.$digest['nc'].':'.$digest['cnonce'].':'.$digest['qop'].':'.$A2);
 
if ($digest['response'] != $valid_response)
    die('Wrong Credentials!');
 
// Ok, utente/passworrd validi
echo 'Your are logged in as: ' . $digest['username'];
  	 
?>
]]>
    </programlisting>
   </example>
  </para>

  <note>
   <title>Note sulla compatibilità</title>
   <para>
    Fare molta attenzione quando si scrive codice per le intestazioni HTTP. Per ottenere la  massima
    compatibilità con tutti i client, la paorla-chiave "Basic" deve essere scritta con una
    "B" maiuscola, la stringa realm deve essere racchiusa in virgolette doppie (non singole),
    ed esattamente uno spazio deve precedere il codice <emphasis>401</emphasis> nella linea 
    di intestazione <emphasis>HTTP/1.0 401</emphasis>.
   </para>
  </note>

  <para>
   Invece di stampare semplicemente <varname>PHP_AUTH_USER</varname> e
   <varname>PHP_AUTH_PW</varname>, probabilmente si vorrà controllare 
   la validità dello username e della password. 
   Probabilmente inviando una chiamata al database,
   o cercando un utente in un file dbm.
   </para>

  <para>
   Si faccia attenzione ad alcune versioni di Internet Explorer. Sembra
   che siano molto schizzinosi riguardo all'ordine delle intestazioni. Inviare l'intestazione
   <emphasis>WWW-Authenticate</emphasis> prima dell'intestazione
   <literal>HTTP/1.0 401</literal> sembra sistemare le cose per
   il momento.
  </para>

  <simpara>
   A partire da PHP 4.3.0, al fine di prevenire che qualcuno scriva uno script che rivela
   la password di una pagina che era stata autenticata tramite un tradizionale
   meccanismo esterno, le variabili PHP_AUTH non verranno
   impostate se è abilitata l'autenticazione esterna per quella determinata
   pagina e &safemode; &egrave; abilitato. Ci&ograve; nonostante, la variabile <varname>REMOTE_USER</varname> può essere 
   usata per identificare un utente autenticato esternamente.  Quindi, potete usare 
   <varname>$_SERVER['REMOTE_USER']</varname>.
  </simpara>

  <note>
   <title>Nota sulla Configurazione</title>
   <para>
    PHP usa la presenza di una direttiva <literal>AuthType</literal>
    per determinare se viene utilizzata l'autenticazione esterna.
   </para>
  </note>

  <simpara>
   Si fa notare, però, che quanto scritto sopra non impedisce a qualcuno che
   controlla un URL non autenticato di sottrarre password da
   URL autenticati presenti sullo stesso server.
  </simpara>
  <simpara>
   Sia Netscape Navigator che Internet Explorer cancellano la cache locale
   della finestra del browser, per quanto riguarda il realm, al ricevimento
   di una risposta 401 da parte del server. Questo &egrave; effettivamente un meccanismo di "log out" per l'utente,
   che lo forza a reinserire lo username e la password. Alcune persone
   usano questo per fare il "time out" dei login, o per rendere disponibili bottoni di "log-out".
  </simpara>
   <para>
    <example>
     <title>Esempio di Autenticazione HTTP che impone l'inserimento di nuovo username/password</title>
     <programlisting role="php">
<![CDATA[
<?php
  function authenticate() {
    header('WWW-Authenticate: Basic realm="Prova del Sistema di Autenticazione"');
    header('HTTP/1.0 401 Unauthorized');
    echo "Per poter accedere a questa risorsa occorre inserire una coppia login e password valide\n";
    exit;
  }

  if (!isset($_SERVER['PHP_AUTH_USER']) ||
      ($_POST['SeenBefore'] == 1 && $_POST['OldAuth'] == $_SERVER['PHP_AUTH_USER'])) {
   authenticate();
  } 
  else {
   echo "<p>Benvenuto: {$_SERVER['PHP_AUTH_USER']}<br>";
   echo "Vecchio: {$_REQUEST['OldAuth']}";
   echo "<form action='{$_SERVER['PHP_SELF']}' METHOD='POST'>\n";
   echo "<input type='hidden' name='SeenBefore' value='1'>\n";
   echo "<input type='hidden' name='OldAuth' value='{$_SERVER['PHP_AUTH_USER']}'>\n";
   echo "<input type='submit' value='Ri autentifica'>\n";
   echo "</form></p>\n";
  }
?>
]]>
    </programlisting>
   </example>
  </para>
  <simpara>
   Questo comportamento non è richiesto dallo standard di autenticazione HTTP 
   Basic, quindi non si dovrebbe mai fare affidamento su di esso. Test effettuati con Lynx
   mostrano che Lynx non cancella le credenziali di autenticazione
   al ricevimento del codice di risposta 401 da parte del server, quindi, premendo indietro e avanti
   nuovamente, darà nuovamente accesso alla risorsa, ammesso che le rispettive richieste di credenziali
   non siano cambiate. L'utente può però premere il
   tasto '_' al fine di cancellare le sue informazioni di autenticazione.
  </simpara>
  <simpara>
   Si noti anche che questo non funziona con il server IIS di Microsoft e
   con la versione CGI di PHP a causa di una limitazione di IIS.
   Si noti anche che, prima di PHP 4.3.3, l'Autenticazione HTTP non funzionava 
   usando il server IIS di Microsoft e con la versione CGI di PHP a causa di una
   limitazione di IIS. Al fine di farla funzionare in PHP 4.3.3+, 
   si deve modificare la vostra configurazione di IIS "Directory Security". Cliccare 
   su "Edit" e selezionare solo "Anonymous Access", tutti gli altri campi 
   dovrebbero essere lasciati deselezionati.
  </simpara>

  <simpara>
   Un'altra limitazione &egrave; che se si usa il modulo IIS (ISAPI) e PHP 4, non si possono
   usare le variabili <literal>PHP_AUTH_*</literal> ma, al contrario, la variabile
   <literal>HTTP_AUTHORIZATION</literal> &egrave; disponibile. Per esempio, si consideri
   il seguente codice: <literal>list($user, $pw) = explode(':',
   base64_decode(substr($_SERVER['HTTP_AUTHORIZATION'], 6)));</literal>
  </simpara>
  <note>
   <title>Nota su IIS:</title>
   <simpara>
    Al fine di fare funzionare la Autenticazione HTTP con IIS, la direttiva PHP
    <link linkend="ini.cgi.rfc2616-headers">cgi.rfc2616_headers</link> deve
    essere impostata al valore <literal>0</literal> (il valore predefinito).
   </simpara>
  </note>
  <note>
   <para>
    Se è abilitato <link linkend="ini.safe-mode">safe mode</link> viene 
    aggiunto lo uid dello script al <literal>realm</literal>
    dell'header <literal>WWW-Authenticate</literal>.
   </para>
  </note>

 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
