<?xml version="1.0" encoding="iso-8859-1"?>
<!-- EN-Revision: 1.28 Maintainer: cortesi Status: ready -->
 <chapter id="features.http-auth">
  <title>Autenticazione HTTP usando PHP</title>

  <simpara>
   I meccanismi di Autenticazione HTTP sono disponibili in PHP solo quando questo
   viene usato come un modulo di Apache ed esso non è quindi disponibile nella versione CGI.
   In uno script PHP modulo di Apache, &egrave; possibile usare la 
   funzione <function>header</function> per inviare un messaggio di "Authentication Required" 
   al browser dell'utente, provocando quindi l'apertura di una finestra contenente una richiesta di
   Nome utente/Password. Una volta che l'utente ha compilato i campi nome utente e password, 
   l'URL contenente lo script PHP verrà richiamato nuovamente usando le 
   <link linkend="reserved.variables">variabili predefinite</link>, <varname>PHP_AUTH_USER</varname>, 
   <varname>PHP_AUTH_PW</varname> e 
   <varname>PHP_AUTH_TYPE</varname> impostate con, rispettivamente:
   nome, password e tipo di autenticazione. Queste variabili predefinite possono essere trovate
   negli array <link linkend="reserved.variables.server">$_SERVER</link> e 
   <varname>$HTTP_SERVER_VARS</varname>. Solamente il tipo di autenticazione "Basic"
   &egrave; al momento supportato. Fare riferimento alla funzione <function>header</function>
   per ulteriori informazioni.
  </simpara>
   
  <note>
   <title>Nota sulla versione di PHP</title>
   <para>
    Le <link linkend="language.variables.superglobals">variabili autoglobali</link>, 
    come <link linkend="reserved.variables.server">$_SERVER</link>, esistono 
    in PHP dalla versione <ulink url="&url.php.release4.1.0;">4.1.0</ulink>. 
    <varname>$HTTP_SERVER_VARS</varname> è disponibile a partire da PHP 3.
   </para>
  </note>

  <para>
   Un frammento di script di esempio che richiede l'autenticazione da parte del browser
   su una pagina, potrebbe essere il seguente:
  </para>
  <para>
   <example>
    <title>Esempio di Autenticazione HTTP</title>
    <programlisting role="php">
<![CDATA[
<?php
  if (!isset($_SERVER['PHP_AUTH_USER'])) {
    header('WWW-Authenticate: Basic realm="Il mio realm"');
    header('HTTP/1.0 401 Unauthorized');
    echo 'Messaggio da inviare se si preme il tasto Cancel';
    exit;
  } else {
    echo "<p>Ciao {$_SERVER['PHP_AUTH_USER']}.</p>";
    echo "<p>Hai inserito {$_SERVER['PHP_AUTH_PW']} come tua password.</p>";
  }
?>
]]>
    </programlisting>
   </example>
  </para>

  <note>
   <title>Note sulla compatibilità</title>
   <para>
    Fare molta attenzione quando si scrive codice per le intestazioni HTTP. Per ottenere la  massima
    compatibilità con tutti i client, la paorla-chiave "Basic" deve essere scritta con una
    "B" maiuscola, la stringa realm deve essere racchiusa in virgolette doppie (non singole),
    ed esattamente uno spazio deve precedere il codice <emphasis>401</emphasis> nella linea 
    di intestazione <emphasis>HTTP/1.0 401</emphasis>.
   </para>
  </note>

  <para>
   Invece di stampare semplicemente <varname>PHP_AUTH_USER</varname> e
   <varname>PHP_AUTH_PW</varname>, probabilmente si vorrà controllare 
   la validità dello username e della password. 
   Probabilmente inviando una chiamata al database,
   o cercando un utente in un file dbm.
   </para>

  <para>
   Si faccia attenzione ad alcune versioni di Internet Explorer. Sembra
   che siano molto schizzinosi riguardo all'ordine delle intestazioni. Inviare l'intestazione
   <emphasis>WWW-Authenticate</emphasis> prima dell'intestazione
   <literal>HTTP/1.0 401</literal> sembra sistemare le cose per
   il momento.
  </para>

  <simpara>
   Al fine di prevenire che qualcuno scriva uno script che rivela
   la password di una pagina che era stata autenticata tramite un tradizionale
   meccanismo esterno, le variabili PHP_AUTH non verranno
   impostate se è abilitata l'autenticazione esterna per quella determinata
   pagina. In questo caso, la variabile <varname>REMOTE_USER</varname> può essere 
   usata per identificare un utente autenticato esternamente.  Così, 
   <varname>$_SERVER['REMOTE_USER']</varname>.
  </simpara>

  <note>
   <title>Nota sulla Configurazione</title>
   <para>
    PHP usa la presenza di una direttiva <literal>AuthType</literal>
    per determinare se viene utilizzata l'autenticazione esterna.
    Evitare questa direttiva nel contesto dove si intende
    usare l'autenticazione con PHP (altrimenti ogni tentativo di autenticazione
    fallirà).
   </para>
  </note>

  <simpara>
   Si fa notare, però, che quanto scritto sopra non impedisce a qualcuno che
   controlla un URL non autenticato di sottrarre password da
   URL autenticati presenti sullo stesso server.
  </simpara>
  <simpara>
   Sia Netscape Navigator che Internet Explorer cancellano la cache locale
   della finestra del browser, per quanto riguarda il realm, al ricevimento
   di una risposta 401 da parte del server. Questo &egrave; effettivamente un meccanismo di "log out" per l'utente,
   che lo forza a reinserire lo username e la password. Alcune persone
   usano questo per fare il "time out" dei login, o per rendere disponibili bottoni di "log-out".
  </simpara>
   <para>
    <example>
      <title>Esempio di Autenticazione HTTP che impone l'inserimento di nuovo username/password</title>
      <programlisting role="php">
<![CDATA[
<?php
  function authenticate() {
    header('WWW-Authenticate: Basic realm="Prova del Sistema di Autenticazione"');
    header('HTTP/1.0 401 Unauthorized');
    echo "Per poter accedere a questa risorsa occorre inserire una coppia login e password valide\n";
    exit;
  }
 
  if (!isset($_SERVER['PHP_AUTH_USER']) || ($_POST['SeenBefore'] == 1 && $_POST['OldAuth'] == $_SERVER['PHP_AUTH_USER'])) {
   authenticate();
  } 
  else {
   echo "<p>Benvenuto: {$_SERVER['PHP_AUTH_USER']}<br>";
   echo "Vecchio: {$_REQUEST['OldAuth']}";
   echo "<form action='{$_SERVER['PHP_SELF']}' METHOD='POST'>\n";
   echo "<input type='hidden' name='SeenBefore' value='1'>\n";
   echo "<input type='hidden' name='OldAuth' value='{$_SERVER['PHP_AUTH_USER']}'>\n";
   echo "<input type='submit' value='Ri autentifica'>\n";
   echo "</form></p>\n";
  }
?>
]]>
    </programlisting>
   </example>
  </para>
  <simpara>
   Questo comportamento non è richiesto dallo standard di autenticazione HTTP 
   Basic, quindi non si dovrebbe mai fare affidamento su di esso. Test effettuati con Lynx
   mostrano che Lynx non cancella le credenziali di autenticazione
   al ricevimento del codice di risposta 401 da parte del server, quindi, premendo indietro e avanti
   nuovamente, darà nuovamente accesso alla risorsa, ammesso che le rispettive richieste di credenziali
   non siano cambiate. L'utente può però premere il
   tasto '_' al fine di cancellare le sue informazioni di autenticazione.
  </simpara>
  <simpara>
   Si noti anche che questo non funziona con il server IIS di Microsoft e
   con la versione CGI di PHP a causa di una limitazione di IIS.
  </simpara>

  <note>
   <para>
    Se è abilitato <link linkend="ini.safe-mode">safe mode</link> viene 
    aggiunto lo uid dello script al <literal>realm</literal>
    dell'header <literal>WWW-Authenticate</literal>.
   </para>
  </note>

 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
