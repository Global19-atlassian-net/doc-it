<?xml version="1.0" encoding="UTF-8"?>
<!-- EN-Revision: 1.27 Maintainer: maxim  Status: ready -->
<appendix xml:id="migration" xmlns="http://docbook.org/ns/docbook">
 <title>Migrazione da PHP/FI 2 a PHP 3</title>

 <section xml:id="migration.about">
  <title>IncompatibilitÃ  in 3.0</title>

  <simpara>
   PHP 3.0 è stato riscritto da capo. Ha un proprio parser che è
   molto più robusto e coerente di quello della versione 2.0. PHP 3.0 è anche
   significativamente più veloce ed usa meno memoria. Tuttavia, alcuni di
   questi miglioramenti non sarebbero stati possibili senza a modifiche della
   compatibilità, sia nella sintassi che nelle funzionalità.
  </simpara>

  <simpara>
   Inoltre, gli sviluppatori di PHP hanno cercato di ripulire sia la sintassi
   che la semantica nel PHP versione 3.0, e anche questo ha causato alcune
   incompatibilità. A lungo termine, crediamo che questi cambiamenti siano
   un miglioramento.
 </simpara>

  <simpara>
   Questo capitolo proverà a guidare lo sviluppatore tra le incompatibilità
   che si potrebbero incontrare passando da PHP/FI 2.0 a PHP 3.0 ed autare
   a resolverle. Le nuove funzionalità non sono descritte a meno che non sia
   necessario.
  </simpara>

  <simpara>
   Esiste un programma di conversione che può convertire automaticamente i
   vecchi script PHP/FI 2.0. Si trova nella cartella
   <filename class="directory">convertor</filename>  della
   distribuzione di PHP 3.0. Questo programma, comunque, intercetta solo le modifiche sintattiche,
   quindi è comunque opportuno leggere attentamente questo capitolo.
  </simpara>
 </section>

 <section xml:id="migration.old-function">
  <title><literal>old_function</literal></title>
  <simpara>
   L'istruzione <literal>old_function</literal> permette di dichiarare
   una funzione utilizzando una sintassi identica a PHP/FI2 (a parte il fatto che si deve
   sostituire 'function' con 'old_function').
  </simpara>
  <simpara>
   Questa è un'opzione sconsigliata e dovrebbe essere utilizzata solo
   dal convertitore PHP/FI2-&gt;PHP 3.
  </simpara>
  <warning>
   <para>
    Le funzioni dichiarate come <literal>old_function</literal> non possono
    essere chiamate dal codice interno di PHP. Tra le altre cose, questo significa
    che non si possono utilizzare in funzioni quali
    <function>usort</function>, <function>array_walk</function> e
    <function>register_shutdown_function</function>. Si può aggirare questa
    limitazione scrivendo un proprio wrapper (nella forma usuale di
    PHP 3) che chiami la <literal>old_function</literal>.
   </para>
  </warning>
 </section>
 
 <section xml:id="migration.startendtags">
  <title>Inizio/fine tag di PHP</title>

  <para>
   La prima cosa che probabilmente si noterà è la modifica dei tag
   di inizio e fine di PHP.  Il vecchio <literal>&lt;? &gt;</literal>
   è stato sostituito da tre nuove forme possibili: 
   <example>
    <title>Migrazione: vecchio tag di inizio/fine</title>
    <programlisting role="php">
<![CDATA[
<? echo "Questo è codice in PHP/FI 2.0\n"; >
]]>
    </programlisting>
   </example>
   Dalla versione 2.0, PHP/FI supporta anche questa variante:
   <example>
    <title>Migrazione: nuovo tag di inizio/fine (prima variante)</title>
    <programlisting role="php">
<![CDATA[
<? echo "Questo è codice in PHP 3.0!\n"; ?>
]]>
    </programlisting>
   </example>

   Si noti che il tag di chiusura ora consiste di un punto interrogativo  e di un
   carattere '&gt;' piuttosto che del solo carattere '&gt;'. Comunque, se si
   ha intenzione di usare XML sul server, ci sareanno dei problemi con
   questa variante, in quanto PHP può provare ad eseguire il markup XML
   dei documenti XML come se fosse codice PHP. Per questa ragione è stata
   introdotta la seguente variante:

   <example>
    <title>Migrazione: nuovo tag di inizio/fine (seconda variante)</title>
    <programlisting role="php">
<![CDATA[
<?php echo "Questo è codice di PHP 3.0!\n"; ?>
]]>
    </programlisting>
   </example>

   Si sono verificati problemi con editor che non riconoscono
   i tag di Processing Instruction. Microsoft FrontPage è uno
   di questi, e come workaround è stata introdotta la seguente
   variante:

   <example>
    <title>Migrazione: nuovo tag di inizio/fine (terza variante)</title>
    <programlisting role="php">
<![CDATA[
<script language="php">

  echo "Questo è codice in PHP 3.0!\n";

</script>
]]>
    </programlisting>
   </example>
  </para>
 </section>

 <section xml:id="migration.if-endif">
  <title>Sintassi di if..endif</title>

  <para>
   Il modo `alternativo' di scrivere le istruzioni if/elseif/else usando
   if(); elseif(); else; endif; non può essere implementato in modo efficiente senza
   aggiungere complessità al parser 3.0. Per questo motivo,
   la sintassi è stata cambiata:
   <example>
    <title>Migrazione: vecchia sintassi di if..endif</title>
    <programlisting role="php">
<![CDATA[
if ($foo);
    echo "Si\n";
elseif ($bar);
    echo "Quasi\n";
else;
    echo "No\n";
endif;
]]>
    </programlisting>
   </example>
   <example>
    <title>Migrazione: nuova sintassi di if..endif</title>
    <programlisting role="php">
<![CDATA[
if ($foo):
    echo "Si\n";
elseif ($bar):
    echo "Quasi\n";
else:
    echo "No\n";
endif;
]]>
    </programlisting>
   </example>

   Si noti che i punti e virgola sono stati sostituiti con i due punti in tutte
   le istruzioni tranne quella che termina l'espressione (endif).
  </para>
 </section>

 <section xml:id="migration.while">
  <title>Sintassi di while</title>
  <para>
   Esattamente come per if..endif, la sintassi di while..endwhile è cambiata
   allo stesso modo:
   <example>
    <title>Migrazione: vecchia sintassi di while..endwhile</title>
    <programlisting role="php">
<![CDATA[
while ($variabile);
    ...
endwhile;
]]>
    </programlisting>
   </example>
   <example>
    <title>Migrazione: nuova sintassi di while..endwhile</title>
    <programlisting role="php">
<![CDATA[
while ($variabile):
    ...
endwhile;
]]>
    </programlisting>
   </example>
  </para>
  <warning>
   <simpara>
    Usando la vecchia sintassi di while..endwhile in PHP 3.0,
	   si otterrebbe un ciclo infinito.
   </simpara>
  </warning>
 </section>

 <section xml:id="migration.expr">
  <title>Tipi di espressione</title>
  <simpara>
   PHP/FI 2.0 usava il lato sinistro delle espressioni per determinare di che tipo
   dovesse essere il risultato.  PHP 3.0 considera entrambi i lati quando
   determina il tipo del risultato, e questo può causare un comportamento
   inaspettato degli script 2.0 sulla versione 3.0.
  </simpara>
  <para>
   Si consideri questo esempio:
   <informalexample>
    <programlisting role="php">
<![CDATA[
$a[0]=5;
$a[1]=7;

$key = key($a);
while ("" != $key) {
    echo "$keyn";
    next($a);
}
]]>
    </programlisting>
   </informalexample>

   In PHP/FI 2.0, questo visualizzerebbe entrambi gli indici di $a. In PHP
   3.0, invece, non visualizza nulla. Il motivo è che in PHP 2.0,
   siccome il tipo del'argomento sinistro è una stringa, viene fatta una
   comparazione fra stringhe, e <literal>""</literal> non è uguale a
   <literal>"0"</literal>, quindi la condizione è verificata. In PHP 3.0,
   quando una stringa è comparata con un intero, viene eseguita una comparazione tra intera
   (la stringa è convertita in intero). Questo provoca una
   comparazione tra <literal>atoi("")</literal> che è
   <literal>0</literal>, e <literal>variablelist</literal> che &egrave;
   pure <literal>0</literal>, e siccome <literal>0==0</literal>, la condizione
   del ciclo non è mai verificata.
  </para>
  <para>
   La soluzione è semplice.  Sostituire l'espressione while con:
   <informalexample>
    <programlisting role="php">
<![CDATA[
while ((string)$key != "") {
]]>
    </programlisting>
   </informalexample>
  </para>
 </section>

 <section xml:id="migration.errors">
  <title>I messaggi di errore sono cambiati</title>
  <simpara>
   I messaggi di errore in PHP 3.0 sono spesso più accurati di quelli di 2.0,
   ma non è più visualizzato il frammento di codice che causa l'errore.
   Sono comunque visualizzati il nome del file e la linea sulla quale 
   l'errore si è verificato.
  </simpara>
 </section>

 <section xml:id="migration.booleval">
  <title>Valutazione booleana cortocircuitata</title>
  <simpara>
   In PHP 3.0 la valutazione booleana è cortocircuitata. Questo significa che
   in una espressione come <literal>(1 || testami())</literal>, la
   funzione <function>testami</function> non è eseguita poiché
   niente può cambiare il risultato dell'espressione dopo
   <literal>1</literal>.
  </simpara>

  <simpara>
   Questo è un problema di compatibilità meno grave, ma può causare
   effetti collaterali inattesi.
  </simpara>
 </section>

 <section xml:id="migration.truefalse">
  <title>Valori di ritorno &true;/&false; delle funzioni</title>
  <simpara>
   La maggior parte delle funzioni interne sono state riscritte in modo che ritornino &true;
   in caso di successo e &false; in caso di fallimento, invece di, rispettivamente, 0 e -1 
   in PHP/FI 2.0. Il nuovo comportamento permette di ottenere un codice
   più logico, come <literal>$fp = fopen("/tuo/file") or
   fail("fallito!");</literal>. Dato che PHP/FI 2.0 non ha regole chiare
   sui valori di ritorno di una funzione in caso di fallimento, probabilmente la
   la maggior parte degli script dovrà essere verificata manualmente dopo aver usato
   il convertitore dalla versione 2.0 alla versione 3.0.
  </simpara>
  <para>
   <example>
    <title>Migrazione da 2.0: valori di ritorno, vecchio codice</title>
    <programlisting role="php">
<![CDATA[
$fp = fopen($file, "r");
if ($fp == -1);
    echo("Apertura in la lettura del $file fallita<br />\n");
endif;
]]>
    </programlisting>
   </example>
   <example>
    <title>Migrazione da 2.0: valori di ritorno, nuovo codice</title>
    <programlisting role="php">
<![CDATA[
$fp = @fopen($file, "r") or print("Apertura in la lettura del $file fallita<br />\n");
]]>
    </programlisting>
   </example>
  </para>
 </section>

 <section xml:id="migration.other">
  <title>Altre incompatibilità</title>

  <itemizedlist>
   <listitem><simpara>
    Il modulo Apache per PHP 3.0 non supporta più le versioni Apache
    inferiori a 1.2. La versione 1.2 (o superiore) di Apache è necessaria.
   </simpara></listitem>

   <listitem><simpara>
    <function>echo</function> non supporta più la stringa di formato.
    Si usi piuttosto la funzione <function>printf</function>.
   </simpara></listitem>

   <listitem><simpara>
    In PHP/FI 2.0, un effetto collaterale dell'implementazione faceva sì che
    <literal>$foo[0]</literal> avesse lo stesso effetto di
    <literal>$foo</literal>. Questo non è più vero in PHP 3.0.
   </simpara></listitem>

   <listitem>
    <simpara>
     Non è più supportata la lettura degli array con
     <literal>$array[]</literal>.
    </simpara>
    <simpara>
     Questo significa che non si può attraversare un array con un ciclo che esegue
     <literal>$data = $array[]</literal>.  Usare <function>current</function>
     e <function>next</function> per ottenere lo stesso comportamento.
    </simpara>
    <simpara>
     Inoltre, <literal>$array1[] = $array2</literal> non
     aggiunge i valori di <literal>$array2</literal> a
     <literal>$array1</literal>, invece aggiunge
     <literal>$array2</literal> come ultima elemento di
     <literal>$array1</literal>. Vedere anche il supporto di array 
     multidimensionali.
    </simpara>
   </listitem>

   <listitem>
    <simpara>
     <literal>"+"</literal> non è più usato come un operatore
	    di concatenazione per le stringhe, ma converte i suoi argumenti
	    in numeri e realizza l'addizione numerica. Usare invece
     <literal>"."</literal>.
    </simpara>
   </listitem>
  </itemizedlist>

  <example>
   <title>Migrazione da 2.0: concatenazione delle stringhe</title>
   <programlisting role="php">
<![CDATA[
echo "1" + "1";
]]>
   </programlisting>
   <para> 
    In PHP 2.0 questo visualizza 11, in PHP 3.0 invece visualizza 2.
    Al suo posto si usi:
    <programlisting role="php">
<![CDATA[
echo "1"."1";
]]>
    </programlisting>
    <programlisting role="php">
<![CDATA[
$a = 1;
$b = 1;
echo $a + $b;
]]>
    </programlisting>
   </para>
   <para>
    Questo visualizza 2 sia in PHP 2.0 che in PHP 3.0.
    <programlisting role="php">
<![CDATA[
$a = 1;
$b = 1;
echo $a.$b;
]]>
    </programlisting>
    Questo visualizza 11 in PHP 3.0.
   </para>
  </example>
 </section>

</appendix>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
